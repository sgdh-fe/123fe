---
title: 淘淘优惠小助手项目总结
date: 2019-06-21 11:57:44
tags: 总结
category: 项目总结
author: 胡丽娟
---

### 遇到的问题
* canvas画跨域图片
* canvas绘制图片模糊
* qrcode在安卓9.0下生成二维码的HTML与其他设备不同
* IOS上遇到的click事件bug;

<!-- More -->

以上前两个问题都是在生成微信分享图时遇到的，下面分别介绍生成微信分享图的步骤和用的API。

### 生成微信分享图的步骤
1. 把所有需要的信息绘制到canvas画布上
2. 把画布上的信息转换成base64的png图片

步骤2用到的API
> ##### canvas.toDataURL(type, encoderOptions)
将canvas画布上的信息转换成base64编码格式的图片使用的API是toDataURL，改方法返回一个包含图片展示的 data URI。参数：
- type(可选)：图片格式，默认为 image/png
- encoderOptions(可选)：在指定图片格式为 image/jpeg 或 image/webp的情况下，可以从 0 到 1 的区间内选择图片的质量。如果超出取值范围，将会使用默认值 0.92。其他参数会被忽略

步骤1绘制图片用到的API
> ##### context.drawImage(img,x,y,width,height)
使用上面API画图时，如果img是外链图片，受限于CORS策略，会存在跨域问题。此时可以将图片正常绘制到canvas画布上，但是绘制到画布上会污染画布，一旦一个画布被污染,就无法提取画布的数据，比如无法使用使用画布toBlob(),toDataURL(),或getImageData()方法；当使用这些方法的时候会抛出安全错误。

### canvas画跨域图片问题
使用img的crossorigin属性
img的crossorigin属性决定了图片获取过程中是否开启CORS功能，该属性有两个取值：
- anonymous：如果使用这个值的话就会在请求中的header中的带上Origin属性，但请求不会带上cookie和其他的一些认证信息
- use-credentials：这个就同时会在跨域请求中带上cookie和其他的一些认证信息
[小demo](https://codepen.io/hulijuan410/pen/vwoQee?editors=1010)

> ##### CORS
跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。
对于简单请求，浏览器直接发出CORS请求，在头信息之中，增加一个Origin字段。Origin字段用来说明，本次请求属于哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

### canvas绘图模糊问题
##### 基本概念：
- 物理像素：设备像素，设备屏幕实际拥有的像素点，屏幕的基本单元
- 设备独立性素：逻辑像素，css像素
- 设备像素比：dpr = 物理像素 ／ 逻辑像素
- 位图canvas绘制的是位图）：位图又叫像素图或栅格图，它是通过记录图像中每一个点的颜色、深度等信息来存储和显示图像。每个位图像素不可以再进一步分割，因此，理论上一个位图像素应该对应着一个物理像素
- canvas的width和height：
`<canvas width="600" height="300" style="width: 300px; height: 150px"></canvas>`
>- style中的width和height分别代表canvas这个元素在界面上所占据的宽高，即样式上的宽高
>- attribute中的width和height则代表canvas实际像素的宽高

##### 模糊原因
假设我们有如下代码，该代码将展示在iphone4的retina屏上：
`<canvas width="320" height="150" style="width: 320px; height: 150px"></canvas>`
iphone4本身的物理像素为640 980，而设备独立像素为320 480，这代表着1个css像素实际由4个物理像素构成；
canvas的像素为320 150，其css像素为320 150，则代表1个css像素将会由1个canvas元素构成；
这样进行换算，在retina屏幕下，1个canvas像素（或者说是1个位图像素）将会填充4个物理像素，由于单个位图像素不可以再进一步分割，所以只能就近取色，从而导致图片模糊。
下面图片可以帮助理解：
![canvas](./canvas.png)

##### 模糊解决方法
###### 让1个canvas像素和一个物理像素挂等号
`canvas.width = width * window.devicePixelRatio;`
`canvas.height = height * window.devicePixelRatio;`
`canvas.style.width = width + 'px';`
`canvas.style.height = height + 'px';`

### qrcode在安卓9.0下生成二维码的HTML与其他设备不同
非安卓9.0机型
![qrcodeimg](./qrcode_other.png)

生成的二维码在img中，直接通过img的src获取图片就好；
安卓9.0机型
![qrcodeimg](./qrcode_android9.png)
生成的二维码在canvas中，要获取图片需将canvas转换成图片，使用toDataURL()方法;

### IOS上使用委托事件时的点击bug
IOS上当使用委托，给一个元素添加click事件时，如果事件是委托到document 或 body 上，并且委托的元素是默认不可点击的(如 div, span 等)，此时 click 事件会失效。

#### 解决方法
1. 将 click 事件直接绑定到目标元素上
2. 将目标元素换成 `<a>` 或者 `<button>` 等可点击的元素
3. 给目标元素添加一个空的 `onclick=""`
4. 把 click 改成 touchend 或 touchstart（注意加上preventDefault）
5. 将 click 元素委托到非 document 或 body 的父级元素上
6. 给目标元素加一条样式规则 `cursor: pointer`

[小demo](https://codepen.io/hulijuan410/pen/OeJpKK?editors=1010)

