{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/cactus-dark/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/theme overview.psd","path":"images/theme overview.psd","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"6211c7971e7c73fcde3c235ab6183fd4fbdbcf67","modified":1534925205000},{"_id":"themes/cactus-dark/LICENSE","hash":"4d5f5f360a18c68f0fd1897bdb1eb1210c2893e3","modified":1534925205000},{"_id":"themes/cactus-dark/README.md","hash":"f38b2f4771eeccc0ae0959ac3e3c485a9d159d4a","modified":1534925205000},{"_id":"themes/cactus-dark/_config.yml","hash":"f1092ae4efec86586f1e6708d42f2aa3a40775f6","modified":1534925376000},{"_id":"source/_posts/IE-8循环引用导致的内存泄露.md","hash":"03e2de36c63dcdf6ec0db7df686c9fa736ea49a6","modified":1534925205000},{"_id":"source/_posts/JavaScript内存那点事.md","hash":"0cda63b8338f8cb2f3c07e45058135f674e88c0c","modified":1534925205000},{"_id":"source/_posts/async-vs-defer.md","hash":"361e064d02650907fd6b2fb42224a3351db7d2ab","modified":1534925205000},{"_id":"source/_posts/css-zIndex.md","hash":"f9a5ed6006ddacc04cf405ea2119d8b32e09f845","modified":1534925205000},{"_id":"source/_posts/init.md","hash":"1a69967967b808bf667a6da750e5565b38bd4c0c","modified":1534925344000},{"_id":"source/_posts/requestAnimationFrame.md","hash":"9d3af6ebca126e6f58f7726ee32a934da1751926","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事.md","hash":"2e915e4c30fd3b4961652caba2896c617b1f6d66","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事.md","hash":"e1716a9a1f51c5608286ad841d21f03b0f9481c3","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners.md","hash":"db5551ec99cd9b04e12dd18d8a7e2d88b72b5307","modified":1534925205000},{"_id":"source/_posts/内存泄露之jQuery-cache.md","hash":"685aeee3197e146e6bb6ba2f262cb60e540a9497","modified":1534925205000},{"_id":"source/_posts/浏览器渲染简述.md","hash":"3eb937e147af7de557c9fb1b7cc0e730c87a07ab","modified":1534925205000},{"_id":"source/about/index.html","hash":"f91db5b719c7fc7d29e7e49c5a531164185b512b","modified":1534925205000},{"_id":"themes/cactus-dark/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1534925205000},{"_id":"themes/cactus-dark/layout/index.ejs","hash":"1a16231e9ce5bd09d8ac0e3cf8f2733c4c157a12","modified":1534925205000},{"_id":"themes/cactus-dark/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1534925205000},{"_id":"themes/cactus-dark/layout/page.ejs","hash":"b6b7b1e6dc856a0e62f35da0151f67ba41143e04","modified":1534925205000},{"_id":"themes/cactus-dark/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1534925205000},{"_id":"themes/cactus-dark/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1534925205000},{"_id":"themes/cactus-dark/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1534925205000},{"_id":"source/_posts/JavaScript内存那点事/cycle.png","hash":"cf9958415e58e7af46bcf695e49d4648105a1935","modified":1534925205000},{"_id":"source/_posts/JavaScript内存那点事/life-cycle.png","hash":"36c1188b40a1faa2ada23d11bfbef3c86177660a","modified":1534925205000},{"_id":"source/_posts/JavaScript内存那点事/no-cycle.png","hash":"5d894fa7c5911f6d3a03bc4b4fc854e2be828b7e","modified":1534925205000},{"_id":"source/_posts/async-vs-defer/legend.svg","hash":"0242b6d7f1d194fb80b2f441671def4f3014bb20","modified":1534925205000},{"_id":"source/_posts/async-vs-defer/script-async.svg","hash":"ad7dc71402604b8faeb136f3ba92170a5e704ce2","modified":1534925205000},{"_id":"source/_posts/async-vs-defer/script-defer.svg","hash":"6b02c3f7322fccd9f167c0477234d50754960edd","modified":1534925205000},{"_id":"source/_posts/async-vs-defer/script.svg","hash":"a578f6355a6b14cac35fc6e4af48d06dd7bba83f","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.png","hash":"467242b5fe6952256f9deb21b3dddc1222da2cb3","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事/closure.png","hash":"4ac2598655f181befd322eae79f8d9774ac69362","modified":1534925205000},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery.jpg","hash":"dfb84e73decd4b50e7455f36b88ae08a04dc9b39","modified":1534925205000},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery_cache_1_x.png","hash":"65f1c5374f0a31c5a6a44502388725497ef7c27c","modified":1534925205000},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery_cache_2_x.png","hash":"755ad521a6ba49a0d5b9c8eb2bd1675bfdd1e2d1","modified":1534925205000},{"_id":"source/_posts/浏览器渲染简述/render.png","hash":"635cdeb948f5954f331f6f5f663054d34bc07ce8","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/head.ejs","hash":"7782e6b1ce72fcf121f0017d383e2fb87e72c539","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/scripts.ejs","hash":"6cffa3adb2f5b93a47f29549ac589c8bce8c223e","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/styles.ejs","hash":"e62b799d8ac369d1f1b36bd2649ecc34aec3384c","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_extend.styl","hash":"faca25132d55e8989d1c1d638e55d1e97de3c561","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_variables.styl","hash":"80345f77f0e601669047cbb3c44491720c3b5c13","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/style.styl","hash":"ede737ff18ca19420ca65aacd1d31399ccff2a16","modified":1534925205000},{"_id":"themes/cactus-dark/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1534925205000},{"_id":"themes/cactus-dark/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1534925205000},{"_id":"themes/cactus-dark/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1534925205000},{"_id":"themes/cactus-dark/source/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1534925205000},{"_id":"themes/cactus-dark/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1534925205000},{"_id":"source/_posts/requestAnimationFrame/arf.png","hash":"bb24777516237651c52bf35c0deacb60637d7e4d","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/async-network.png","hash":"5056be23b1a31e794c1d6527c383aa3563e4c90d","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/async-network1.png","hash":"e9586915ed4c6df4fef034213d83a34821dac22f","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/async.png","hash":"a70167fdb163e189687283c562f57c176785675a","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/default-network.png","hash":"499e55e1146a6fe7bff0da967f2aed70688af16a","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/media-network.png","hash":"040baff4d17cd7bcf7cc8288eac4b1bc793523c6","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/media.png","hash":"73b6c03849561e8ac621be6dd4aa3091e7ebc5ec","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/script-network.png","hash":"3cc9e3ca4e95a5eb444a29750346eaac0e712d6c","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/script.png","hash":"5910b915601f4afcdac68af6ce6451d257884b90","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet-default.png","hash":"85c33491724afcd70553522704567fee95627fcb","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners/listener_location.png","hash":"9f9a510b333b117b4d896764cad5013391ef8d24","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/contents.xml","hash":"2fef4a611c3c8cf1eff16a8769a88061993574d7","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/viewState.plist","hash":"6f2f7999d50e8ccfa1d13c9f72ac119da517c59c","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事/closure2.png","hash":"091a279732357ca7d5790d6462edd1c26f02a4ff","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事/closure3.png","hash":"688c5eb2cfe3ef308f0b1bba0bf5f782ec951423","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners/listeners_event.png","hash":"2dea6583ab164a3490c899db234befb253a90247","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/actions_desktop.ejs","hash":"063ae931a6902f192e086fe5cceae587d27ed196","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/actions_mobile.ejs","hash":"64d0f85480997a4fa53c99954e9454c189595e9c","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1534925205000},{"_id":"themes/cactus-dark/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/article.styl","hash":"202b775a966d7bc35bf5adc693b62463dec106bb","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/footer.styl","hash":"b7570de60eaf9aa6b0192bf9c71b9172ff11bfbc","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/header.styl","hash":"63707d9103a283147ca222fd6f8ff9bffbffe427","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/index.styl","hash":"cf43702450ea1e5617541501886982a394cff8ec","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/pagination.styl","hash":"03a1b81d60dae3dd55963b7e74a6fee83470e6bb","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1534925205000},{"_id":"source/_posts/JavaScript内存那点事/mark-sweep.gif","hash":"fd13ddb270cd612668b97015a01cd2ec3ab937b1","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事/closure4.png","hash":"f765361ae7248a18c91f31b4538a36e80d8c915d","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事/closure5.png","hash":"56972df77d755eee3346f9bac1e0a95b32d2938d","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners/listeners_fixed.png","hash":"4681dba3574b4da97d76177236f21b7ed06bb09b","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners/listeners_resize.png","hash":"d4458465f2db6087b47394e7c1fcb4be64df5fd3","modified":1534925205000},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery1_x.png","hash":"9b18da36937eb3a668a5752d3a8bc91684a61eb2","modified":1534925205000},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery2_x.png","hash":"596199653248639e87d02b3b5b7ef5a83a4670c2","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/style.mindnodestyle/contents.xml","hash":"e1ed5eb03e419add20371f2f3aa595c7a0a18f02","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/style.mindnodestyle/metadata.plist","hash":"5afc7f0891e0599decc407be87bb0486b35050d2","modified":1534925205000},{"_id":"source/_posts/关于闭包也许你不知道的事/closure1.png","hash":"45989ef2609317ba1984647890aa2b596bfb1416","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners/listeners_resize_after.png","hash":"7062c2446d38aa22ba84fd8b630abeeb0e25f038","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/post/actions_desktop.styl","hash":"2bbbb20ae8a99bc08fb95ba0ec8f39ed6ccb8534","modified":1534925205000},{"_id":"themes/cactus-dark/source/css/_partial/post/actions_mobile.styl","hash":"e6a802d7ee1023c5fc5fac18bb0ba3dc03ef2ac8","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1534925205000},{"_id":"source/_posts/IE-8循环引用导致的内存泄露/leakage.png","hash":"84d9b8945d6fc27522dc34027f7743b40261986d","modified":1534925205000},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/QuickLook/Preview.jpg","hash":"b4656d0e7b77b48f19d5ed7a77661f8b498aecfa","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1534925205000},{"_id":"source/_posts/浏览器渲染简述/tiles.png","hash":"0f5a23cc8c42f8b38b70fba4dea5c147dca25b86","modified":1534925205000},{"_id":"source/_posts/内存泄露之Listeners/listeners_performance.png","hash":"cc4a507bdbe21b724c17db5533779f73c0f0d6e0","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1534925205000},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1534925205000},{"_id":"themes/cactus-dark/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1534925205000},{"_id":"public/about/index.html","hash":"9eb8c59dda52a72d13bd3c9faa80263fd52f52f7","modified":1534925985087},{"_id":"public/2017/08/28/init/index.html","hash":"bd08df3dd636d18960a01e166ab1cad037b19e72","modified":1534925985087},{"_id":"public/archives/index.html","hash":"16a8db25065b51bdc8aad1d7ec9ba0097250e07c","modified":1534925985087},{"_id":"public/archives/page/2/index.html","hash":"90da819b713b67ad8110a8a3394c3897e012d2fd","modified":1534925985087},{"_id":"public/archives/2017/index.html","hash":"91281bfa63fecb7b0d36129e69b662f21ab15182","modified":1534925985087},{"_id":"public/archives/2017/page/2/index.html","hash":"622decaad42b074ace37046edb7fadafc3c048b9","modified":1534925985087},{"_id":"public/archives/2017/08/index.html","hash":"7efe15e25c81eb03b63d3dcd9549b1cccb51f69f","modified":1534925985087},{"_id":"public/archives/2017/09/index.html","hash":"bc916fd455106ce5ffd749c16ed1b10fb7f90999","modified":1534925985088},{"_id":"public/archives/2017/11/index.html","hash":"5f1dfe31d1120cfc87d5eb875ece234651c11df9","modified":1534925985088},{"_id":"public/categories/memory/index.html","hash":"41beb077e2ee60a2cbb9da9b33b3dd7e1a92231b","modified":1534925985088},{"_id":"public/index.html","hash":"407410405cec7d22b602d7aa10884abc5d035489","modified":1534925985088},{"_id":"public/page/2/index.html","hash":"356861c2f7e7d330ee0430085c4c6540370246fb","modified":1534925985088},{"_id":"public/tags/IE6/index.html","hash":"e867d4580a866870d7284c3db173e3f4d3f2697b","modified":1534925985088},{"_id":"public/tags/内存泄露/index.html","hash":"bab7ab650584b6308c649d4b1866fbf0bc615dfb","modified":1534925985088},{"_id":"public/tags/优化/index.html","hash":"e7efb6fbd0342ef7b3ead08d17a2f2979d5fb3a2","modified":1534925985088},{"_id":"public/tags/内存/index.html","hash":"c570176dd7b77ac1d754bccc2d613f0be1a0efef","modified":1534925985088},{"_id":"public/tags/CG/index.html","hash":"c32f8a7a9c7cccabbce9732911d460839077c5f6","modified":1534925985088},{"_id":"public/tags/垃圾回收/index.html","hash":"28aa2ecd57c0239210ccc02806b8a13ad059a04c","modified":1534925985088},{"_id":"public/tags/defer/index.html","hash":"e4139310fe9c6ba59594b547c0a8e63b0f043ed7","modified":1534925985088},{"_id":"public/tags/async/index.html","hash":"e42c37eda05411db01a03c6568ce1f998f43e73f","modified":1534925985088},{"_id":"public/tags/css/index.html","hash":"10593f3ae6049f02a755ef54ec68bc4de8458e13","modified":1534925985088},{"_id":"public/tags/requestAnimationFrame/index.html","hash":"5677869b13531fb9c0d0de8994c804c97ed7e8b2","modified":1534925985088},{"_id":"public/tags/动画/index.html","hash":"6416d008bfce0c615ce9398e7d10bf8bbfc75dc8","modified":1534925985088},{"_id":"public/tags/style-sheet/index.html","hash":"823f0afd80e9b6db9fe46136f2266671bc819d84","modified":1534925985088},{"_id":"public/tags/闭包/index.html","hash":"17d2dac99514167c0d6e629bbe0bc06fe257b0b3","modified":1534925985088},{"_id":"public/tags/closure/index.html","hash":"e8b96df50eb60b5b9385e4b946fab98c6f838e27","modified":1534925985089},{"_id":"public/tags/listeners/index.html","hash":"6465c3b8ee9e0c9529a8c5ab1d116ad3b8d65cba","modified":1534925985089},{"_id":"public/tags/cache/index.html","hash":"04754f1e296086f3c6d4e8f2092511944891d1d6","modified":1534925985089},{"_id":"public/tags/jquery/index.html","hash":"326f323bed0abf7d58f9cd97009d8ab1517bbaa4","modified":1534925985089},{"_id":"public/tags/渲染/index.html","hash":"cd4c5d7c814c902246869288765093791c9d8329","modified":1534925985089},{"_id":"public/tags/render/index.html","hash":"5be6fa584008c97b062d45e9352466b5dbcac405","modified":1534925985089},{"_id":"public/tags/硬件加速/index.html","hash":"be0a78b7665191c36eff321a77892d9e695915e7","modified":1534925985089},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/index.html","hash":"eefed576b607524477da488fb70f7e94d2f60b89","modified":1534925985089},{"_id":"public/2017/11/23/requestAnimationFrame/index.html","hash":"02dea53bc52f48833dbcbf5198a53e15aa239e66","modified":1534925985089},{"_id":"public/2017/11/21/浏览器渲染简述/index.html","hash":"528932cb53f04f10b998a00c12af9e5a252d93d5","modified":1534925985089},{"_id":"public/2017/11/13/内存泄露之jQuery-cache/index.html","hash":"8c6933b28af9861eff2991ccf6a7a46947cc626a","modified":1534925985089},{"_id":"public/2017/11/10/IE-8循环引用导致的内存泄露/index.html","hash":"26f637dd3ea68a3e32d5a07fee126c93d2e0e823","modified":1534925985089},{"_id":"public/2017/11/01/内存泄露之Listeners/index.html","hash":"b0502f08f55dfcf6d64ac69eaa1622ca8a6762f2","modified":1534925985089},{"_id":"public/2017/09/30/JavaScript内存那点事/index.html","hash":"d1891ab6b932c8fa77a4614805ace635107e5415","modified":1534925985089},{"_id":"public/2017/09/19/async-vs-defer/index.html","hash":"ea1f4f23c55c6ec5ac40aab6399e6d23c3443744","modified":1534925985089},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/index.html","hash":"fe6e19df465264315ca0cd4d37429e6cfb23c446","modified":1534925985089},{"_id":"public/2017/08/29/css-zIndex/index.html","hash":"865d570d17d88a51bdb22a44412c500dba22e6fd","modified":1534925985089},{"_id":"public/CNAME","hash":"6211c7971e7c73fcde3c235ab6183fd4fbdbcf67","modified":1534925985099},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1534925985099},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1534925985099},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1534925985099},{"_id":"public/images/logo.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1534925985099},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet.mindnode/style.mindnodestyle/contents.xml","hash":"e1ed5eb03e419add20371f2f3aa595c7a0a18f02","modified":1534925985099},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet.mindnode/style.mindnodestyle/metadata.plist","hash":"5afc7f0891e0599decc407be87bb0486b35050d2","modified":1534925985099},{"_id":"public/2017/11/21/浏览器渲染简述/render.png","hash":"635cdeb948f5954f331f6f5f663054d34bc07ce8","modified":1534925985099},{"_id":"public/2017/09/30/JavaScript内存那点事/cycle.png","hash":"cf9958415e58e7af46bcf695e49d4648105a1935","modified":1534925985099},{"_id":"public/2017/09/30/JavaScript内存那点事/life-cycle.png","hash":"36c1188b40a1faa2ada23d11bfbef3c86177660a","modified":1534925985099},{"_id":"public/2017/09/30/JavaScript内存那点事/no-cycle.png","hash":"5d894fa7c5911f6d3a03bc4b4fc854e2be828b7e","modified":1534925985099},{"_id":"public/2017/09/19/async-vs-defer/legend.svg","hash":"0242b6d7f1d194fb80b2f441671def4f3014bb20","modified":1534925985099},{"_id":"public/2017/09/19/async-vs-defer/script-async.svg","hash":"ad7dc71402604b8faeb136f3ba92170a5e704ce2","modified":1534925985099},{"_id":"public/2017/09/19/async-vs-defer/script-defer.svg","hash":"6b02c3f7322fccd9f167c0477234d50754960edd","modified":1534925985099},{"_id":"public/2017/09/19/async-vs-defer/script.svg","hash":"a578f6355a6b14cac35fc6e4af48d06dd7bba83f","modified":1534925985100},{"_id":"public/2017/11/13/内存泄露之jQuery-cache/jquery.jpg","hash":"dfb84e73decd4b50e7455f36b88ae08a04dc9b39","modified":1534925985100},{"_id":"public/2017/11/13/内存泄露之jQuery-cache/jquery_cache_2_x.png","hash":"755ad521a6ba49a0d5b9c8eb2bd1675bfdd1e2d1","modified":1534925985100},{"_id":"public/2017/11/13/内存泄露之jQuery-cache/jquery_cache_1_x.png","hash":"65f1c5374f0a31c5a6a44502388725497ef7c27c","modified":1534925985100},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/closure.png","hash":"4ac2598655f181befd322eae79f8d9774ac69362","modified":1534925985100},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet.mindnode/contents.xml","hash":"2fef4a611c3c8cf1eff16a8769a88061993574d7","modified":1534925985100},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet.mindnode/viewState.plist","hash":"6f2f7999d50e8ccfa1d13c9f72ac119da517c59c","modified":1534925985100},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet.png","hash":"467242b5fe6952256f9deb21b3dddc1222da2cb3","modified":1534925985100},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1534925985337},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1534925985338},{"_id":"public/2017/11/23/requestAnimationFrame/arf.png","hash":"bb24777516237651c52bf35c0deacb60637d7e4d","modified":1534925985338},{"_id":"public/2017/11/01/内存泄露之Listeners/listener_location.png","hash":"9f9a510b333b117b4d896764cad5013391ef8d24","modified":1534925985338},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet.mindnode/QuickLook/Preview.jpg","hash":"b4656d0e7b77b48f19d5ed7a77661f8b498aecfa","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/async-network.png","hash":"5056be23b1a31e794c1d6527c383aa3563e4c90d","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/async-network1.png","hash":"e9586915ed4c6df4fef034213d83a34821dac22f","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/default-network.png","hash":"499e55e1146a6fe7bff0da967f2aed70688af16a","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/async.png","hash":"a70167fdb163e189687283c562f57c176785675a","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/media-network.png","hash":"040baff4d17cd7bcf7cc8288eac4b1bc793523c6","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/media.png","hash":"73b6c03849561e8ac621be6dd4aa3091e7ebc5ec","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/script.png","hash":"5910b915601f4afcdac68af6ce6451d257884b90","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/style-sheet-default.png","hash":"85c33491724afcd70553522704567fee95627fcb","modified":1534925985339},{"_id":"public/2017/09/19/关于external-style-sheets你不知道的事/script-network.png","hash":"3cc9e3ca4e95a5eb444a29750346eaac0e712d6c","modified":1534925985339},{"_id":"public/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1534925985345},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1534925985345},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1534925985345},{"_id":"public/css/style.css","hash":"6a755b1c4149a9d0adbdca8a8496a780e43d3ad6","modified":1534925985345},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1534925985345},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1534925985345},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1534925985345},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1534925985345},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1534925985345},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1534925985345},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1534925985345},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/closure2.png","hash":"091a279732357ca7d5790d6462edd1c26f02a4ff","modified":1534925985345},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/closure3.png","hash":"688c5eb2cfe3ef308f0b1bba0bf5f782ec951423","modified":1534925985345},{"_id":"public/2017/11/01/内存泄露之Listeners/listeners_event.png","hash":"2dea6583ab164a3490c899db234befb253a90247","modified":1534925985346},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/closure4.png","hash":"f765361ae7248a18c91f31b4538a36e80d8c915d","modified":1534925985352},{"_id":"public/2017/09/30/JavaScript内存那点事/mark-sweep.gif","hash":"fd13ddb270cd612668b97015a01cd2ec3ab937b1","modified":1534925985352},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/closure5.png","hash":"56972df77d755eee3346f9bac1e0a95b32d2938d","modified":1534925985353},{"_id":"public/2017/11/01/内存泄露之Listeners/listeners_fixed.png","hash":"4681dba3574b4da97d76177236f21b7ed06bb09b","modified":1534925985353},{"_id":"public/2017/11/01/内存泄露之Listeners/listeners_resize.png","hash":"d4458465f2db6087b47394e7c1fcb4be64df5fd3","modified":1534925985354},{"_id":"public/2017/11/13/内存泄露之jQuery-cache/jquery1_x.png","hash":"9b18da36937eb3a668a5752d3a8bc91684a61eb2","modified":1534925985354},{"_id":"public/2017/11/13/内存泄露之jQuery-cache/jquery2_x.png","hash":"596199653248639e87d02b3b5b7ef5a83a4670c2","modified":1534925985354},{"_id":"public/2017/11/23/关于闭包也许你不知道的事/closure1.png","hash":"45989ef2609317ba1984647890aa2b596bfb1416","modified":1534925985361},{"_id":"public/2017/11/01/内存泄露之Listeners/listeners_resize_after.png","hash":"7062c2446d38aa22ba84fd8b630abeeb0e25f038","modified":1534925985362},{"_id":"public/2017/11/10/IE-8循环引用导致的内存泄露/leakage.png","hash":"84d9b8945d6fc27522dc34027f7743b40261986d","modified":1534925985368},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1534925985375},{"_id":"public/2017/11/21/浏览器渲染简述/tiles.png","hash":"0f5a23cc8c42f8b38b70fba4dea5c147dca25b86","modified":1534925985400},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1534925985406},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1534925985406},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1534925985406},{"_id":"public/2017/11/01/内存泄露之Listeners/listeners_performance.png","hash":"cc4a507bdbe21b724c17db5533779f73c0f0d6e0","modified":1534925985407},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1534925985411},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1534925985411},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1534925985412},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1534925985413},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1534925985415},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1534925985416},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1534925985417},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1534925985417},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1534925985418},{"_id":"public/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1534925985440}],"Category":[{"name":"memory","_id":"cjl4vata600041hn96fz5igqm"}],"Data":[],"Page":[{"title":"About","_content":"\n<style type=\"text/css\">\n    .type-wr{\n        padding-top: 4rem;\n    }\n    .skills {\n        width: 382px;\n        width: 100%;\n        max-width: 360px;\n        overflow: hidden;\n        border-right: .1em solid #d44375;\n        white-space: nowrap;\n        margin: 0 auto;\n        letter-spacing: .1em;\n        font-weight: 300;\n        color: #2C3E50;\n        font-size: 1.45rem;\n        \n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n    }\n    .skills .sg{\n        color:#d44375;\n        font-weight: bold;\n    }\n    .skills b{\n        font-weight: 700;\n        font-style: normal;\n    }\n    .skills .dot{\n        font-size: 12px;\n    }\n    .typewriter {\n        animation: typing 6s steps(40, end), blink-caret .75s step-end infinite;\n    }\n    /* The typing effect */\n    @keyframes typing {\n        from {\n            width: 0;\n        }\n        to {\n            width: 382px;\n            width: 100%;\n        }\n    }\n    /* The typewriter cursor effect */\n    @keyframes blink-caret {\n        from,\n        to {\n            border-color: transparent;\n        }\n        50% {\n            border-color: #d44375;\n        }\n    }\n    @media screen and (min-width: 320px) and (max-width: 480px) {\n        .skills{\n            font-size: 1.08rem;\n            max-width: 272px;\n        }\n    }\n</style>\n\n<div class=\"type-wr\">\n    <div class=\"skills typewriter\">Hi,<span class=\"sg\">搜狗</span><b>导航前端</b>开发组🐳🐳<span class=\"dot\">..</span></div>\n</div>\n","source":"about/index.html","raw":"---\ntitle: About\n---\n\n<style type=\"text/css\">\n    .type-wr{\n        padding-top: 4rem;\n    }\n    .skills {\n        width: 382px;\n        width: 100%;\n        max-width: 360px;\n        overflow: hidden;\n        border-right: .1em solid #d44375;\n        white-space: nowrap;\n        margin: 0 auto;\n        letter-spacing: .1em;\n        font-weight: 300;\n        color: #2C3E50;\n        font-size: 1.45rem;\n        \n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n    }\n    .skills .sg{\n        color:#d44375;\n        font-weight: bold;\n    }\n    .skills b{\n        font-weight: 700;\n        font-style: normal;\n    }\n    .skills .dot{\n        font-size: 12px;\n    }\n    .typewriter {\n        animation: typing 6s steps(40, end), blink-caret .75s step-end infinite;\n    }\n    /* The typing effect */\n    @keyframes typing {\n        from {\n            width: 0;\n        }\n        to {\n            width: 382px;\n            width: 100%;\n        }\n    }\n    /* The typewriter cursor effect */\n    @keyframes blink-caret {\n        from,\n        to {\n            border-color: transparent;\n        }\n        50% {\n            border-color: #d44375;\n        }\n    }\n    @media screen and (min-width: 320px) and (max-width: 480px) {\n        .skills{\n            font-size: 1.08rem;\n            max-width: 272px;\n        }\n    }\n</style>\n\n<div class=\"type-wr\">\n    <div class=\"skills typewriter\">Hi,<span class=\"sg\">搜狗</span><b>导航前端</b>开发组🐳🐳<span class=\"dot\">..</span></div>\n</div>\n","date":"2018-08-22T08:06:45.000Z","updated":"2018-08-22T08:06:45.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjl4vatc3001q1hn9zhlvtf60","content":"\n<style type=\"text/css\">\n    .type-wr{\n        padding-top: 4rem;\n    }\n    .skills {\n        width: 382px;\n        width: 100%;\n        max-width: 360px;\n        overflow: hidden;\n        border-right: .1em solid #d44375;\n        white-space: nowrap;\n        margin: 0 auto;\n        letter-spacing: .1em;\n        font-weight: 300;\n        color: #2C3E50;\n        font-size: 1.45rem;\n        \n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n    }\n    .skills .sg{\n        color:#d44375;\n        font-weight: bold;\n    }\n    .skills b{\n        font-weight: 700;\n        font-style: normal;\n    }\n    .skills .dot{\n        font-size: 12px;\n    }\n    .typewriter {\n        animation: typing 6s steps(40, end), blink-caret .75s step-end infinite;\n    }\n    /* The typing effect */\n    @keyframes typing {\n        from {\n            width: 0;\n        }\n        to {\n            width: 382px;\n            width: 100%;\n        }\n    }\n    /* The typewriter cursor effect */\n    @keyframes blink-caret {\n        from,\n        to {\n            border-color: transparent;\n        }\n        50% {\n            border-color: #d44375;\n        }\n    }\n    @media screen and (min-width: 320px) and (max-width: 480px) {\n        .skills{\n            font-size: 1.08rem;\n            max-width: 272px;\n        }\n    }\n</style>\n\n<div class=\"type-wr\">\n    <div class=\"skills typewriter\">Hi,<span class=\"sg\">搜狗</span><b>导航前端</b>开发组🐳🐳<span class=\"dot\">..</span></div>\n</div>\n","site":{"data":{}},"excerpt":"","more":"\n<style type=\"text/css\">\n    .type-wr{\n        padding-top: 4rem;\n    }\n    .skills {\n        width: 382px;\n        width: 100%;\n        max-width: 360px;\n        overflow: hidden;\n        border-right: .1em solid #d44375;\n        white-space: nowrap;\n        margin: 0 auto;\n        letter-spacing: .1em;\n        font-weight: 300;\n        color: #2C3E50;\n        font-size: 1.45rem;\n        \n        -webkit-box-sizing: border-box;\n        -moz-box-sizing: border-box;\n        box-sizing: border-box;\n    }\n    .skills .sg{\n        color:#d44375;\n        font-weight: bold;\n    }\n    .skills b{\n        font-weight: 700;\n        font-style: normal;\n    }\n    .skills .dot{\n        font-size: 12px;\n    }\n    .typewriter {\n        animation: typing 6s steps(40, end), blink-caret .75s step-end infinite;\n    }\n    /* The typing effect */\n    @keyframes typing {\n        from {\n            width: 0;\n        }\n        to {\n            width: 382px;\n            width: 100%;\n        }\n    }\n    /* The typewriter cursor effect */\n    @keyframes blink-caret {\n        from,\n        to {\n            border-color: transparent;\n        }\n        50% {\n            border-color: #d44375;\n        }\n    }\n    @media screen and (min-width: 320px) and (max-width: 480px) {\n        .skills{\n            font-size: 1.08rem;\n            max-width: 272px;\n        }\n    }\n</style>\n\n<div class=\"type-wr\">\n    <div class=\"skills typewriter\">Hi,<span class=\"sg\">搜狗</span><b>导航前端</b>开发组🐳🐳<span class=\"dot\">..</span></div>\n</div>\n"}],"Post":[{"title":"IE<8循环引用导致的内存泄露","date":"2017-11-10T10:05:58.000Z","author":"singsong","_content":"\n![leakage](./leakage.png)\n\n在IE<8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。因此JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用，这从而导致内存泄露。\n在IE6中，循环引用只在IE浏览器程序退出时才会被解除，而在IE7中，离开当前页面时，才会解除页面中的循环引用。IE8修复该问题，JScript垃圾回收器会将引用的DOM对象视为JScript对象，从而避免循环引用不能被解除的问题（_注：这里循环引用解除是指浏览器自动解除循环引用_）。\n\nIE6-7中管理DOM对象的垃圾回收器是基于引用计数策略，如果DOM对象与js对象存在循环引用。需要将DOM对象上的expando属性设置为null或重新赋值。这样才能回收DOM对象。(_注：这里只是针对DOM的回收_)\n```html\n<html>\n    <head>\n        <script language=\"JScript\">\n        var myGlobalObject;\n        function SetupLeak()\n        {\n            myGlobalObject = document.getElementById(\"LeakedDiv\");// ← js对象引用DOM对象\n            document.getElementById(\"LeakedDiv\").expandoProperty = myGlobalObject;// ← DOM对象的expando属性引用js对象\n        }\n        function BreakLeak()\n        {\n            document.getElementById(\"LeakedDiv\").expandoProperty = null;// ← 设置为null或重新赋新值\n        }\n        </script>\n    </head>\n\n    <body onload=\"SetupLeak()\" onunload=\"BreakLeak()\">\n        <div id=\"LeakedDiv\"></div>\n    </body>\n</html>\n```\n上述代码的循环引用不是很复杂，很容易发现。不过实际项目中可能会存在循环链很长的情况：\n```js\n    (function(){\n        var d={b:document.body}\n        var obj={doc:d}; // ← obj.doc.b === document.body\n        document.body.o=obj; // ← 循环引用: document.body.o.doc.b === document.body\n    })();\n```\n另外一种常见的循环引用发生在闭包中：\n```js\n(function(){\n    var b=document.body; // ← 创建一个引用document.body的变量\"b\"\n    b.onclick=function() { // ← b.onclick引用function\n    // 通过闭包能在函数中能访问到\"b\"\n    // do something...\n    };\n})();\n```\n## 为什么DOM的垃圾回收器是基于引用计数策略？\nIE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM(component object model，组件对象模型)对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。在IE9把BOM和DOM对象转换为真正的js对象。\n\n除了低版本的IE外，在低版本的Firefox(如Firefox3.0)中也存在类似问题。它也是通过COM来管理DOM，与Windows的COM类似，Mozilla的XPCOM也是基于引用计数策略。\n\n## 如何避免及修复？\n循环引用是导致低版本IE和Firefox浏览器内存泄露的真正原因，因此最直接的方法是避免在DOM和JS之间创建相互引用。确保总是JS对象单向引用DOM对象，或DOM对象单向引用JS对象。虽然说起来简单，但实际情况是很难做到的。那如何修复循环引用就很重要了，可以维护一个存在循环引用DOM对象的队列，在页面unload时，做如下处理：\n```js\n(function(){\n    var unLoaders=[];\n    myDomNode.object=new myObject(); // ← 假设这里创建一个循环引用，会引起内存泄露\n    unLoaders.push(myDomNode); // ← 缓存myDomNode\n\n    var unload=function(){ // ← unload回调函数\n    for(var i=unLoaders.length-1;i>-1;i–){\n        unLoaders[i].object=null; // ← 切断循环引用\n    }\n    };\n    window.addEvnetListener(’unload’, unload); // ← 绑定unload\n})();\n```\njquery在处理IE低版本类似问题时，采用的也是上述方法，[jquery源码](https://github.com/jquery/jquery/blob/1.4.4rc1/src/event.js#L1169)：\n```js\n// Prevent memory leaks in IE\n// Window isn't included so as not to unbind existing unload events\n// More info:\n//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/\nif ( window.attachEvent && !window.addEventListener ) {\n\tjQuery(window).bind(\"unload\", function() {\n\t\tfor ( var id in jQuery.cache ) {\n\t\t\tif ( jQuery.cache[ id ].handle ) {\n\t\t\t\t// Try/Catch is to handle iframes being unloaded, see #4280\n\t\t\t\ttry {\n\t\t\t\t\tjQuery.event.remove( jQuery.cache[ id ].handle.elem );\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t}\n\t});\n}\n```\n\n\n\n>This memory leak occurs because DOM objects are non-JScript objects. DOM objects are not in the mark-and-sweep garbage collection scheme of JScript. Therefore, the circular reference between the DOM objects and the JScript handlers will not be broken until the browser completely tears down the page. This memory leak will end when the browser opens a new Web page or when the browser window is closed.\n\n\n## 总结\n随着移动互联网的飞速发展，IE也向W3C标准靠拢，低版本浏览器正逐渐被淘汰。不过实际业务中，还是存在对某些低版本进行支持，虽然概率很少，不过为了保证用户体验，需要对本文涉及的知识点有所了解。也许你的业务中，不需要对低版本浏览器支持。那就把本文当成浏览器发展史来了解吧，也希望你能从文章有所收获。\n\n\n## 参考文章：\n- [Circular Memory Leak Mitigation](https://msdn.microsoft.com/en-us/library/dd361842(v=vs.85).aspx)\n- [DOM: why is this a memory leak?](https://stackoverflow.com/questions/15761094/dom-why-is-this-a-memory-leak)\n- [Internet Explorer Event Handler Leaks](http://www.reigndropsfall.net/2011/01/05/internet-explorer-event-handler-leaks/)\n- [Avoiding leaks in JavaScript XPCOM components](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Avoiding_leaks_in_JavaScript_components)\n- [JScript Memory Leaks](http://www.crockford.com/javascript/memory/leak.html)\n- [Memory Leaks in Microsoft Internet Explorer](http://isaacschlueter.com/2006/10/msie-memory-leaks/trackback/index.html)","source":"_posts/IE-8循环引用导致的内存泄露.md","raw":"---\ntitle: IE<8循环引用导致的内存泄露\ndate: 2017-11-10 18:05:58\ntags: [IE6, 内存泄露, 优化]\nauthor: singsong\n---\n\n![leakage](./leakage.png)\n\n在IE<8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。因此JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用，这从而导致内存泄露。\n在IE6中，循环引用只在IE浏览器程序退出时才会被解除，而在IE7中，离开当前页面时，才会解除页面中的循环引用。IE8修复该问题，JScript垃圾回收器会将引用的DOM对象视为JScript对象，从而避免循环引用不能被解除的问题（_注：这里循环引用解除是指浏览器自动解除循环引用_）。\n\nIE6-7中管理DOM对象的垃圾回收器是基于引用计数策略，如果DOM对象与js对象存在循环引用。需要将DOM对象上的expando属性设置为null或重新赋值。这样才能回收DOM对象。(_注：这里只是针对DOM的回收_)\n```html\n<html>\n    <head>\n        <script language=\"JScript\">\n        var myGlobalObject;\n        function SetupLeak()\n        {\n            myGlobalObject = document.getElementById(\"LeakedDiv\");// ← js对象引用DOM对象\n            document.getElementById(\"LeakedDiv\").expandoProperty = myGlobalObject;// ← DOM对象的expando属性引用js对象\n        }\n        function BreakLeak()\n        {\n            document.getElementById(\"LeakedDiv\").expandoProperty = null;// ← 设置为null或重新赋新值\n        }\n        </script>\n    </head>\n\n    <body onload=\"SetupLeak()\" onunload=\"BreakLeak()\">\n        <div id=\"LeakedDiv\"></div>\n    </body>\n</html>\n```\n上述代码的循环引用不是很复杂，很容易发现。不过实际项目中可能会存在循环链很长的情况：\n```js\n    (function(){\n        var d={b:document.body}\n        var obj={doc:d}; // ← obj.doc.b === document.body\n        document.body.o=obj; // ← 循环引用: document.body.o.doc.b === document.body\n    })();\n```\n另外一种常见的循环引用发生在闭包中：\n```js\n(function(){\n    var b=document.body; // ← 创建一个引用document.body的变量\"b\"\n    b.onclick=function() { // ← b.onclick引用function\n    // 通过闭包能在函数中能访问到\"b\"\n    // do something...\n    };\n})();\n```\n## 为什么DOM的垃圾回收器是基于引用计数策略？\nIE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM(component object model，组件对象模型)对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。在IE9把BOM和DOM对象转换为真正的js对象。\n\n除了低版本的IE外，在低版本的Firefox(如Firefox3.0)中也存在类似问题。它也是通过COM来管理DOM，与Windows的COM类似，Mozilla的XPCOM也是基于引用计数策略。\n\n## 如何避免及修复？\n循环引用是导致低版本IE和Firefox浏览器内存泄露的真正原因，因此最直接的方法是避免在DOM和JS之间创建相互引用。确保总是JS对象单向引用DOM对象，或DOM对象单向引用JS对象。虽然说起来简单，但实际情况是很难做到的。那如何修复循环引用就很重要了，可以维护一个存在循环引用DOM对象的队列，在页面unload时，做如下处理：\n```js\n(function(){\n    var unLoaders=[];\n    myDomNode.object=new myObject(); // ← 假设这里创建一个循环引用，会引起内存泄露\n    unLoaders.push(myDomNode); // ← 缓存myDomNode\n\n    var unload=function(){ // ← unload回调函数\n    for(var i=unLoaders.length-1;i>-1;i–){\n        unLoaders[i].object=null; // ← 切断循环引用\n    }\n    };\n    window.addEvnetListener(’unload’, unload); // ← 绑定unload\n})();\n```\njquery在处理IE低版本类似问题时，采用的也是上述方法，[jquery源码](https://github.com/jquery/jquery/blob/1.4.4rc1/src/event.js#L1169)：\n```js\n// Prevent memory leaks in IE\n// Window isn't included so as not to unbind existing unload events\n// More info:\n//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/\nif ( window.attachEvent && !window.addEventListener ) {\n\tjQuery(window).bind(\"unload\", function() {\n\t\tfor ( var id in jQuery.cache ) {\n\t\t\tif ( jQuery.cache[ id ].handle ) {\n\t\t\t\t// Try/Catch is to handle iframes being unloaded, see #4280\n\t\t\t\ttry {\n\t\t\t\t\tjQuery.event.remove( jQuery.cache[ id ].handle.elem );\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t}\n\t});\n}\n```\n\n\n\n>This memory leak occurs because DOM objects are non-JScript objects. DOM objects are not in the mark-and-sweep garbage collection scheme of JScript. Therefore, the circular reference between the DOM objects and the JScript handlers will not be broken until the browser completely tears down the page. This memory leak will end when the browser opens a new Web page or when the browser window is closed.\n\n\n## 总结\n随着移动互联网的飞速发展，IE也向W3C标准靠拢，低版本浏览器正逐渐被淘汰。不过实际业务中，还是存在对某些低版本进行支持，虽然概率很少，不过为了保证用户体验，需要对本文涉及的知识点有所了解。也许你的业务中，不需要对低版本浏览器支持。那就把本文当成浏览器发展史来了解吧，也希望你能从文章有所收获。\n\n\n## 参考文章：\n- [Circular Memory Leak Mitigation](https://msdn.microsoft.com/en-us/library/dd361842(v=vs.85).aspx)\n- [DOM: why is this a memory leak?](https://stackoverflow.com/questions/15761094/dom-why-is-this-a-memory-leak)\n- [Internet Explorer Event Handler Leaks](http://www.reigndropsfall.net/2011/01/05/internet-explorer-event-handler-leaks/)\n- [Avoiding leaks in JavaScript XPCOM components](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Avoiding_leaks_in_JavaScript_components)\n- [JScript Memory Leaks](http://www.crockford.com/javascript/memory/leak.html)\n- [Memory Leaks in Microsoft Internet Explorer](http://isaacschlueter.com/2006/10/msie-memory-leaks/trackback/index.html)","slug":"IE-8循环引用导致的内存泄露","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vat9x00001hn9nsy7m8yf","content":"<p><img src=\"./leakage.png\" alt=\"leakage\"></p>\n<p>在IE&lt;8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。因此JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用，这从而导致内存泄露。<br>在IE6中，循环引用只在IE浏览器程序退出时才会被解除，而在IE7中，离开当前页面时，才会解除页面中的循环引用。IE8修复该问题，JScript垃圾回收器会将引用的DOM对象视为JScript对象，从而避免循环引用不能被解除的问题（<em>注：这里循环引用解除是指浏览器自动解除循环引用</em>）。</p>\n<p>IE6-7中管理DOM对象的垃圾回收器是基于引用计数策略，如果DOM对象与js对象存在循环引用。需要将DOM对象上的expando属性设置为null或重新赋值。这样才能回收DOM对象。(<em>注：这里只是针对DOM的回收</em>)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">language</span>=<span class=\"string\">\"JScript\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\">        var myGlobalObject;</span></div><div class=\"line\"><span class=\"undefined\">        function SetupLeak()</span></div><div class=\"line\"><span class=\"undefined\">        &#123;</span></div><div class=\"line\"><span class=\"undefined\">            myGlobalObject = document.getElementById(\"LeakedDiv\");// ← js对象引用DOM对象</span></div><div class=\"line\"><span class=\"undefined\">            document.getElementById(\"LeakedDiv\").expandoProperty = myGlobalObject;// ← DOM对象的expando属性引用js对象</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">        function BreakLeak()</span></div><div class=\"line\"><span class=\"undefined\">        &#123;</span></div><div class=\"line\"><span class=\"undefined\">            document.getElementById(\"LeakedDiv\").expandoProperty = null;// ← 设置为null或重新赋新值</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"SetupLeak()\"</span> <span class=\"attr\">onunload</span>=<span class=\"string\">\"BreakLeak()\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"LeakedDiv\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>上述代码的循环引用不是很复杂，很容易发现。不过实际项目中可能会存在循环链很长的情况：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> d=&#123;<span class=\"attr\">b</span>:<span class=\"built_in\">document</span>.body&#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> obj=&#123;<span class=\"attr\">doc</span>:d&#125;; <span class=\"comment\">// ← obj.doc.b === document.body</span></div><div class=\"line\">    <span class=\"built_in\">document</span>.body.o=obj; <span class=\"comment\">// ← 循环引用: document.body.o.doc.b === document.body</span></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>另外一种常见的循环引用发生在闭包中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> b=<span class=\"built_in\">document</span>.body; <span class=\"comment\">// ← 创建一个引用document.body的变量\"b\"</span></div><div class=\"line\">    b.onclick=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// ← b.onclick引用function</span></div><div class=\"line\">    <span class=\"comment\">// 通过闭包能在函数中能访问到\"b\"</span></div><div class=\"line\">    <span class=\"comment\">// do something...</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<h2 id=\"为什么DOM的垃圾回收器是基于引用计数策略？\"><a href=\"#为什么DOM的垃圾回收器是基于引用计数策略？\" class=\"headerlink\" title=\"为什么DOM的垃圾回收器是基于引用计数策略？\"></a>为什么DOM的垃圾回收器是基于引用计数策略？</h2><p>IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM(component object model，组件对象模型)对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。在IE9把BOM和DOM对象转换为真正的js对象。</p>\n<p>除了低版本的IE外，在低版本的Firefox(如Firefox3.0)中也存在类似问题。它也是通过COM来管理DOM，与Windows的COM类似，Mozilla的XPCOM也是基于引用计数策略。</p>\n<h2 id=\"如何避免及修复？\"><a href=\"#如何避免及修复？\" class=\"headerlink\" title=\"如何避免及修复？\"></a>如何避免及修复？</h2><p>循环引用是导致低版本IE和Firefox浏览器内存泄露的真正原因，因此最直接的方法是避免在DOM和JS之间创建相互引用。确保总是JS对象单向引用DOM对象，或DOM对象单向引用JS对象。虽然说起来简单，但实际情况是很难做到的。那如何修复循环引用就很重要了，可以维护一个存在循环引用DOM对象的队列，在页面unload时，做如下处理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> unLoaders=[];</div><div class=\"line\">    myDomNode.object=<span class=\"keyword\">new</span> myObject(); <span class=\"comment\">// ← 假设这里创建一个循环引用，会引起内存泄露</span></div><div class=\"line\">    unLoaders.push(myDomNode); <span class=\"comment\">// ← 缓存myDomNode</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> unload=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// ← unload回调函数</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=unLoaders.length<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;i–)&#123;</div><div class=\"line\">        unLoaders[i].object=<span class=\"literal\">null</span>; <span class=\"comment\">// ← 切断循环引用</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"built_in\">window</span>.addEvnetListener(’unload’, unload); <span class=\"comment\">// ← 绑定unload</span></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>jquery在处理IE低版本类似问题时，采用的也是上述方法，<a href=\"https://github.com/jquery/jquery/blob/1.4.4rc1/src/event.js#L1169\" target=\"_blank\" rel=\"external\">jquery源码</a>：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Prevent memory leaks in IE</span></div><div class=\"line\"><span class=\"comment\">// Window isn't included so as not to unbind existing unload events</span></div><div class=\"line\"><span class=\"comment\">// More info:</span></div><div class=\"line\"><span class=\"comment\">//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/</span></div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"built_in\">window</span>.attachEvent &amp;&amp; !<span class=\"built_in\">window</span>.addEventListener ) &#123;</div><div class=\"line\">\tjQuery(<span class=\"built_in\">window</span>).bind(<span class=\"string\">\"unload\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> id <span class=\"keyword\">in</span> jQuery.cache ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( jQuery.cache[ id ].handle ) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// Try/Catch is to handle iframes being unloaded, see #4280</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tjQuery.event.remove( jQuery.cache[ id ].handle.elem );</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>This memory leak occurs because DOM objects are non-JScript objects. DOM objects are not in the mark-and-sweep garbage collection scheme of JScript. Therefore, the circular reference between the DOM objects and the JScript handlers will not be broken until the browser completely tears down the page. This memory leak will end when the browser opens a new Web page or when the browser window is closed.</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>随着移动互联网的飞速发展，IE也向W3C标准靠拢，低版本浏览器正逐渐被淘汰。不过实际业务中，还是存在对某些低版本进行支持，虽然概率很少，不过为了保证用户体验，需要对本文涉及的知识点有所了解。也许你的业务中，不需要对低版本浏览器支持。那就把本文当成浏览器发展史来了解吧，也希望你能从文章有所收获。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/dd361842(v=vs.85\" target=\"_blank\" rel=\"external\">Circular Memory Leak Mitigation</a>.aspx)</li>\n<li><a href=\"https://stackoverflow.com/questions/15761094/dom-why-is-this-a-memory-leak\" target=\"_blank\" rel=\"external\">DOM: why is this a memory leak?</a></li>\n<li><a href=\"http://www.reigndropsfall.net/2011/01/05/internet-explorer-event-handler-leaks/\" target=\"_blank\" rel=\"external\">Internet Explorer Event Handler Leaks</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Avoiding_leaks_in_JavaScript_components\" target=\"_blank\" rel=\"external\">Avoiding leaks in JavaScript XPCOM components</a></li>\n<li><a href=\"http://www.crockford.com/javascript/memory/leak.html\" target=\"_blank\" rel=\"external\">JScript Memory Leaks</a></li>\n<li><a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/trackback/index.html\" target=\"_blank\" rel=\"external\">Memory Leaks in Microsoft Internet Explorer</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"./leakage.png\" alt=\"leakage\"></p>\n<p>在IE&lt;8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。因此JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用，这从而导致内存泄露。<br>在IE6中，循环引用只在IE浏览器程序退出时才会被解除，而在IE7中，离开当前页面时，才会解除页面中的循环引用。IE8修复该问题，JScript垃圾回收器会将引用的DOM对象视为JScript对象，从而避免循环引用不能被解除的问题（<em>注：这里循环引用解除是指浏览器自动解除循环引用</em>）。</p>\n<p>IE6-7中管理DOM对象的垃圾回收器是基于引用计数策略，如果DOM对象与js对象存在循环引用。需要将DOM对象上的expando属性设置为null或重新赋值。这样才能回收DOM对象。(<em>注：这里只是针对DOM的回收</em>)<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">language</span>=<span class=\"string\">\"JScript\"</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"undefined\">        var myGlobalObject;</span></div><div class=\"line\"><span class=\"undefined\">        function SetupLeak()</span></div><div class=\"line\"><span class=\"undefined\">        &#123;</span></div><div class=\"line\"><span class=\"undefined\">            myGlobalObject = document.getElementById(\"LeakedDiv\");// ← js对象引用DOM对象</span></div><div class=\"line\"><span class=\"undefined\">            document.getElementById(\"LeakedDiv\").expandoProperty = myGlobalObject;// ← DOM对象的expando属性引用js对象</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">        function BreakLeak()</span></div><div class=\"line\"><span class=\"undefined\">        &#123;</span></div><div class=\"line\"><span class=\"undefined\">            document.getElementById(\"LeakedDiv\").expandoProperty = null;// ← 设置为null或重新赋新值</span></div><div class=\"line\"><span class=\"undefined\">        &#125;</span></div><div class=\"line\"><span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">\"SetupLeak()\"</span> <span class=\"attr\">onunload</span>=<span class=\"string\">\"BreakLeak()\"</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"LeakedDiv\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>上述代码的循环引用不是很复杂，很容易发现。不过实际项目中可能会存在循环链很长的情况：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> d=&#123;<span class=\"attr\">b</span>:<span class=\"built_in\">document</span>.body&#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> obj=&#123;<span class=\"attr\">doc</span>:d&#125;; <span class=\"comment\">// ← obj.doc.b === document.body</span></div><div class=\"line\">    <span class=\"built_in\">document</span>.body.o=obj; <span class=\"comment\">// ← 循环引用: document.body.o.doc.b === document.body</span></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>另外一种常见的循环引用发生在闭包中：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> b=<span class=\"built_in\">document</span>.body; <span class=\"comment\">// ← 创建一个引用document.body的变量\"b\"</span></div><div class=\"line\">    b.onclick=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// ← b.onclick引用function</span></div><div class=\"line\">    <span class=\"comment\">// 通过闭包能在函数中能访问到\"b\"</span></div><div class=\"line\">    <span class=\"comment\">// do something...</span></div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<h2 id=\"为什么DOM的垃圾回收器是基于引用计数策略？\"><a href=\"#为什么DOM的垃圾回收器是基于引用计数策略？\" class=\"headerlink\" title=\"为什么DOM的垃圾回收器是基于引用计数策略？\"></a>为什么DOM的垃圾回收器是基于引用计数策略？</h2><p>IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM(component object model，组件对象模型)对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。在IE9把BOM和DOM对象转换为真正的js对象。</p>\n<p>除了低版本的IE外，在低版本的Firefox(如Firefox3.0)中也存在类似问题。它也是通过COM来管理DOM，与Windows的COM类似，Mozilla的XPCOM也是基于引用计数策略。</p>\n<h2 id=\"如何避免及修复？\"><a href=\"#如何避免及修复？\" class=\"headerlink\" title=\"如何避免及修复？\"></a>如何避免及修复？</h2><p>循环引用是导致低版本IE和Firefox浏览器内存泄露的真正原因，因此最直接的方法是避免在DOM和JS之间创建相互引用。确保总是JS对象单向引用DOM对象，或DOM对象单向引用JS对象。虽然说起来简单，但实际情况是很难做到的。那如何修复循环引用就很重要了，可以维护一个存在循环引用DOM对象的队列，在页面unload时，做如下处理：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> unLoaders=[];</div><div class=\"line\">    myDomNode.object=<span class=\"keyword\">new</span> myObject(); <span class=\"comment\">// ← 假设这里创建一个循环引用，会引起内存泄露</span></div><div class=\"line\">    unLoaders.push(myDomNode); <span class=\"comment\">// ← 缓存myDomNode</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> unload=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">// ← unload回调函数</span></div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=unLoaders.length<span class=\"number\">-1</span>;i&gt;<span class=\"number\">-1</span>;i–)&#123;</div><div class=\"line\">        unLoaders[i].object=<span class=\"literal\">null</span>; <span class=\"comment\">// ← 切断循环引用</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"built_in\">window</span>.addEvnetListener(’unload’, unload); <span class=\"comment\">// ← 绑定unload</span></div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure></p>\n<p>jquery在处理IE低版本类似问题时，采用的也是上述方法，<a href=\"https://github.com/jquery/jquery/blob/1.4.4rc1/src/event.js#L1169\" target=\"_blank\" rel=\"external\">jquery源码</a>：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Prevent memory leaks in IE</span></div><div class=\"line\"><span class=\"comment\">// Window isn't included so as not to unbind existing unload events</span></div><div class=\"line\"><span class=\"comment\">// More info:</span></div><div class=\"line\"><span class=\"comment\">//  - http://isaacschlueter.com/2006/10/msie-memory-leaks/</span></div><div class=\"line\"><span class=\"keyword\">if</span> ( <span class=\"built_in\">window</span>.attachEvent &amp;&amp; !<span class=\"built_in\">window</span>.addEventListener ) &#123;</div><div class=\"line\">\tjQuery(<span class=\"built_in\">window</span>).bind(<span class=\"string\">\"unload\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">for</span> ( <span class=\"keyword\">var</span> id <span class=\"keyword\">in</span> jQuery.cache ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( jQuery.cache[ id ].handle ) &#123;</div><div class=\"line\">\t\t\t\t<span class=\"comment\">// Try/Catch is to handle iframes being unloaded, see #4280</span></div><div class=\"line\">\t\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t\tjQuery.event.remove( jQuery.cache[ id ].handle.elem );</div><div class=\"line\">\t\t\t\t&#125; <span class=\"keyword\">catch</span>(e) &#123;&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>This memory leak occurs because DOM objects are non-JScript objects. DOM objects are not in the mark-and-sweep garbage collection scheme of JScript. Therefore, the circular reference between the DOM objects and the JScript handlers will not be broken until the browser completely tears down the page. This memory leak will end when the browser opens a new Web page or when the browser window is closed.</p>\n</blockquote>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>随着移动互联网的飞速发展，IE也向W3C标准靠拢，低版本浏览器正逐渐被淘汰。不过实际业务中，还是存在对某些低版本进行支持，虽然概率很少，不过为了保证用户体验，需要对本文涉及的知识点有所了解。也许你的业务中，不需要对低版本浏览器支持。那就把本文当成浏览器发展史来了解吧，也希望你能从文章有所收获。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"https://msdn.microsoft.com/en-us/library/dd361842(v=vs.85\" target=\"_blank\" rel=\"external\">Circular Memory Leak Mitigation</a>.aspx)</li>\n<li><a href=\"https://stackoverflow.com/questions/15761094/dom-why-is-this-a-memory-leak\" target=\"_blank\" rel=\"external\">DOM: why is this a memory leak?</a></li>\n<li><a href=\"http://www.reigndropsfall.net/2011/01/05/internet-explorer-event-handler-leaks/\" target=\"_blank\" rel=\"external\">Internet Explorer Event Handler Leaks</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Guide/Avoiding_leaks_in_JavaScript_components\" target=\"_blank\" rel=\"external\">Avoiding leaks in JavaScript XPCOM components</a></li>\n<li><a href=\"http://www.crockford.com/javascript/memory/leak.html\" target=\"_blank\" rel=\"external\">JScript Memory Leaks</a></li>\n<li><a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/trackback/index.html\" target=\"_blank\" rel=\"external\">Memory Leaks in Microsoft Internet Explorer</a></li>\n</ul>\n"},{"title":"JavaScript内存那点事","date":"2017-09-30T08:28:53.000Z","author":"singsong","_content":"\nC、C++语言需要手动管理内存的分配与释放（常用方法：malloc(), calloc(), realloc()和free()等）。而JavaScript与Java、C#相似，内置了垃圾回收器，能自动管理内存的分配与释放。\n\n## 内存生命周期:\n\n1. 分配内存\n2. 使用分配的内存(读与写操作)\n3. 当应用程序不再需要时，释放掉\b已分配的内存\n\n![lifecycle](./life-cycle.png)\n\n\b虽然\b\b内存自动进行\b分配、释放，但并不意味着\b开发者不需要关注内存管理\b。\b因为一些不好的编码会导致\b[内存泄露](https://en.wikipedia.org/wiki/Memory_leak#Reference_counting_and_cyclic_references)，即应用程序不再\b需要的内存没有被释放掉。因此了解内存管理是很重要的\n\n\n## Javascript中的\b内存分配\n\n\n当声明变量时，JavaScript会自动为变量分配内存\n```js\nvar numberVar = 100; //为\b整数分配内存\nvar stringVar = 'node simplified';  // 为字符串分配内存 \nvar objectVar = {a: 1}; // 为对象分配内存\nvar a = [1, null, 'abra']; // 为数组分配内存\nfunction f(a) {\n  return a + 2;\n} // 为函数\b分配内存 \n```\n\b当内存不再需要时，会自动释放掉。内存泄露和在释放内存时出现的大部分与内存相关的问题，而要找出那些被垃圾回收器跟踪\b不再需要的而又没有被释放的内存是很困难的。\n\n## GC(Garbage collection)\n\b垃圾回收是追踪并释放应用程序不再\b使用的内存过程。垃圾回收器通\b过算法来实现追踪应用程序不再使用的内存。\b\b主要涉及的垃圾回收算法如下：\n\n- Reference-counting garbage collection（引用计数）\n- Mark-and-sweep algorithm（标记清除）\n\n### Reference-counting garbage collection（引用计数）\n引用计数算法是\b一种最基础的垃圾回收算法，当一个\b对象的引用数为零时，会被自动回收。该算法将\b\b一个对象的引用数为0时视为应用程序不再\b需要的\b内存。\n\n```js\n!function (){\n  var o1 = {a: {b: 2}},// 两个对象被创建A:{a: {b: 2}}，B:{b: 2}，对象B被对象A的属性a引用，对象A被\b\b赋值给变量o1。\bA和B的引用数都为1，因此不能被回收。\n      o2 = o1; // 将对象A赋给\b变量o2。此时A引用数为2，B\b引用数1。\n      o1 = 1;// \b将变量o1对对象A引用切断。此时A引用数为1，B引用数1。\n  var oa = o2.a; // 将对象B赋值给变量oa。此时A引用数为1，B引用数2。\n      o2 = 'foo'; // 将变量o2对对象A\b引用切断。此时A引用数为0，B引用数1。因为对象A的a\b属性被\b变量oa引用，因此对象A不能被释放。\n      oa = null; // 将变量oa对对象B引用切断。此时A引用数为0，B引用数\b0。A与B会被\b回收。\n}()\n```\n\n#### 引用计数的\b限制：循环引用\n  循环引用存在一个限制。如下实例，两个对象相互引用，形成一个循环引用。正常情况下，当函数\b执行完后，\b对应的内存\b\b会被释放掉。而\b**引用计数算法**会将循环引用对象的引用数都视为至少为1，因此不能被回收。\n\n```js\nfunction f() {\n  var o = {};\n  var o2 = {};\n  o.a = o2; // o references o2\n  o2.a = o; // o2 references o\n\n  return 'azerty';\n}\n\nf();\n```\n![cycle](./cycle.png)\n\n\n#### 常见问题实例\n\n  IE6-7\b的DOM对象是基于计数引用\b\b\b算法进行垃圾回收的。而循环引用通常会导致内存\b泄露：\n\n```js\nvar div;\nwindow.onload = function() {\n  div = document.getElementById('myDivElement');\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join('*');\n};\n```\n如上述实例，DOM元素div通过自身的“circularReference”属性循环引用自己。如果没有显式将该属性删除或\b设为null，\b计数引用垃圾回收器会\b始终持有\b至少一个引用。即使DOM元素从DOM树种\b移除，DOM元素的内存\b会一直存在。如果DOM元素持有一些数据（如实例中“lotsData”属性），该数据对应的内存也无法\b被释放。\n\b\n\n### Mark-and-sweep algorithm（标记清除）\n\n该算法将“对象不再需要”的定义\b简化为“对象不可到达”。\n这个算法假设有一组\b被称为roots的对象（在JavaScript中，root就是全局对象）。垃圾回收器会\b定期地\b从这些roots开始，查找所有从根开始引用的对象，然后查找这些对象引用的对象……。\b从\broots开始，垃圾回收器会\b查找所有可到达对象，并回收不可到达的对象。\n\n为了确定对象是否需要，该算法要确定对象是否可到达。由如下步骤组成：\n\n1. 垃圾回收器会\b创建一组roots，roots通常是持有引用的全局变量。在JavaScript中，window对象就可作为root的全局变量。\n2. 垃圾回收器会检查所有的roots并标记为活跃状态。然后\b递归遍历所有的子变量。\b只要从root不能到达的都被标记为垃圾。\n3. \b所有没有被标记为活跃状态的内存块\b都被视为垃圾。\b垃圾回收器就可以释放\b这部分内存并把释放的内存返回给操作系统。\n\n![](./mark-sweep.gif)\n\n\n这个算法比引用计数算法更优，因为“\b\b零引\b用的对象”总是不可到达的，但\b反\b之则不一定，如\b循环引用。\n截至2012年，所有现代浏览器都内置了\b**标记清除垃圾回收器**。\b\b\b在过去几年里所有对JavaScript垃圾回收的改进（[generational/incremental/concurrent/parallel garbage collection](http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection)）都是基于**标记清除算法**来实现的，并没有改变**标记清除算法**本身和它对“对象不再需要”定义的简化。\n\b\n#### 循环引用不再\b是问题\n\b\b前面循环引用的实例中，在函数执行完后，两个对象不再被全局对象\b可访问的对象引用。因此\b\b这两\b个对象被\b垃圾回收器标记为不可到达\b，接着被回收掉。\n![](./no-cycle.png)\n\n#### 限制：需要明确无法到达的对象\n\b尽管这是一个\b限制，但实践中很少遇见这种情况，所以开发者不太会去关心垃圾回收机制。\n\n\n## 参考文章：\n\n- [Memory Management And Garbage Collection In Javascript](http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html)\n- [Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n- [How JavaScript works: memory management + how to handle 4 common memory leaks](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)\n- [Memory Management Reference](http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection)\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---","source":"_posts/JavaScript内存那点事.md","raw":"---\ntitle: JavaScript内存那点事\ndate: 2017-09-30 16:28:53\ncategory: memory\nauthor: singsong\ntags: [内存, CG, 垃圾回收]\n---\n\nC、C++语言需要手动管理内存的分配与释放（常用方法：malloc(), calloc(), realloc()和free()等）。而JavaScript与Java、C#相似，内置了垃圾回收器，能自动管理内存的分配与释放。\n\n## 内存生命周期:\n\n1. 分配内存\n2. 使用分配的内存(读与写操作)\n3. 当应用程序不再需要时，释放掉\b已分配的内存\n\n![lifecycle](./life-cycle.png)\n\n\b虽然\b\b内存自动进行\b分配、释放，但并不意味着\b开发者不需要关注内存管理\b。\b因为一些不好的编码会导致\b[内存泄露](https://en.wikipedia.org/wiki/Memory_leak#Reference_counting_and_cyclic_references)，即应用程序不再\b需要的内存没有被释放掉。因此了解内存管理是很重要的\n\n\n## Javascript中的\b内存分配\n\n\n当声明变量时，JavaScript会自动为变量分配内存\n```js\nvar numberVar = 100; //为\b整数分配内存\nvar stringVar = 'node simplified';  // 为字符串分配内存 \nvar objectVar = {a: 1}; // 为对象分配内存\nvar a = [1, null, 'abra']; // 为数组分配内存\nfunction f(a) {\n  return a + 2;\n} // 为函数\b分配内存 \n```\n\b当内存不再需要时，会自动释放掉。内存泄露和在释放内存时出现的大部分与内存相关的问题，而要找出那些被垃圾回收器跟踪\b不再需要的而又没有被释放的内存是很困难的。\n\n## GC(Garbage collection)\n\b垃圾回收是追踪并释放应用程序不再\b使用的内存过程。垃圾回收器通\b过算法来实现追踪应用程序不再使用的内存。\b\b主要涉及的垃圾回收算法如下：\n\n- Reference-counting garbage collection（引用计数）\n- Mark-and-sweep algorithm（标记清除）\n\n### Reference-counting garbage collection（引用计数）\n引用计数算法是\b一种最基础的垃圾回收算法，当一个\b对象的引用数为零时，会被自动回收。该算法将\b\b一个对象的引用数为0时视为应用程序不再\b需要的\b内存。\n\n```js\n!function (){\n  var o1 = {a: {b: 2}},// 两个对象被创建A:{a: {b: 2}}，B:{b: 2}，对象B被对象A的属性a引用，对象A被\b\b赋值给变量o1。\bA和B的引用数都为1，因此不能被回收。\n      o2 = o1; // 将对象A赋给\b变量o2。此时A引用数为2，B\b引用数1。\n      o1 = 1;// \b将变量o1对对象A引用切断。此时A引用数为1，B引用数1。\n  var oa = o2.a; // 将对象B赋值给变量oa。此时A引用数为1，B引用数2。\n      o2 = 'foo'; // 将变量o2对对象A\b引用切断。此时A引用数为0，B引用数1。因为对象A的a\b属性被\b变量oa引用，因此对象A不能被释放。\n      oa = null; // 将变量oa对对象B引用切断。此时A引用数为0，B引用数\b0。A与B会被\b回收。\n}()\n```\n\n#### 引用计数的\b限制：循环引用\n  循环引用存在一个限制。如下实例，两个对象相互引用，形成一个循环引用。正常情况下，当函数\b执行完后，\b对应的内存\b\b会被释放掉。而\b**引用计数算法**会将循环引用对象的引用数都视为至少为1，因此不能被回收。\n\n```js\nfunction f() {\n  var o = {};\n  var o2 = {};\n  o.a = o2; // o references o2\n  o2.a = o; // o2 references o\n\n  return 'azerty';\n}\n\nf();\n```\n![cycle](./cycle.png)\n\n\n#### 常见问题实例\n\n  IE6-7\b的DOM对象是基于计数引用\b\b\b算法进行垃圾回收的。而循环引用通常会导致内存\b泄露：\n\n```js\nvar div;\nwindow.onload = function() {\n  div = document.getElementById('myDivElement');\n  div.circularReference = div;\n  div.lotsOfData = new Array(10000).join('*');\n};\n```\n如上述实例，DOM元素div通过自身的“circularReference”属性循环引用自己。如果没有显式将该属性删除或\b设为null，\b计数引用垃圾回收器会\b始终持有\b至少一个引用。即使DOM元素从DOM树种\b移除，DOM元素的内存\b会一直存在。如果DOM元素持有一些数据（如实例中“lotsData”属性），该数据对应的内存也无法\b被释放。\n\b\n\n### Mark-and-sweep algorithm（标记清除）\n\n该算法将“对象不再需要”的定义\b简化为“对象不可到达”。\n这个算法假设有一组\b被称为roots的对象（在JavaScript中，root就是全局对象）。垃圾回收器会\b定期地\b从这些roots开始，查找所有从根开始引用的对象，然后查找这些对象引用的对象……。\b从\broots开始，垃圾回收器会\b查找所有可到达对象，并回收不可到达的对象。\n\n为了确定对象是否需要，该算法要确定对象是否可到达。由如下步骤组成：\n\n1. 垃圾回收器会\b创建一组roots，roots通常是持有引用的全局变量。在JavaScript中，window对象就可作为root的全局变量。\n2. 垃圾回收器会检查所有的roots并标记为活跃状态。然后\b递归遍历所有的子变量。\b只要从root不能到达的都被标记为垃圾。\n3. \b所有没有被标记为活跃状态的内存块\b都被视为垃圾。\b垃圾回收器就可以释放\b这部分内存并把释放的内存返回给操作系统。\n\n![](./mark-sweep.gif)\n\n\n这个算法比引用计数算法更优，因为“\b\b零引\b用的对象”总是不可到达的，但\b反\b之则不一定，如\b循环引用。\n截至2012年，所有现代浏览器都内置了\b**标记清除垃圾回收器**。\b\b\b在过去几年里所有对JavaScript垃圾回收的改进（[generational/incremental/concurrent/parallel garbage collection](http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection)）都是基于**标记清除算法**来实现的，并没有改变**标记清除算法**本身和它对“对象不再需要”定义的简化。\n\b\n#### 循环引用不再\b是问题\n\b\b前面循环引用的实例中，在函数执行完后，两个对象不再被全局对象\b可访问的对象引用。因此\b\b这两\b个对象被\b垃圾回收器标记为不可到达\b，接着被回收掉。\n![](./no-cycle.png)\n\n#### 限制：需要明确无法到达的对象\n\b尽管这是一个\b限制，但实践中很少遇见这种情况，所以开发者不太会去关心垃圾回收机制。\n\n\n## 参考文章：\n\n- [Memory Management And Garbage Collection In Javascript](http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html)\n- [Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)\n- [How JavaScript works: memory management + how to handle 4 common memory leaks](https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec)\n- [Memory Management Reference](http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection)\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---","slug":"JavaScript内存那点事","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vata000011hn9mizjdgi0","content":"<p>C、C++语言需要手动管理内存的分配与释放（常用方法：malloc(), calloc(), realloc()和free()等）。而JavaScript与Java、C#相似，内置了垃圾回收器，能自动管理内存的分配与释放。</p>\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期:\"></a>内存生命周期:</h2><ol>\n<li>分配内存</li>\n<li>使用分配的内存(读与写操作)</li>\n<li>当应用程序不再需要时，释放掉\b已分配的内存</li>\n</ol>\n<p><img src=\"./life-cycle.png\" alt=\"lifecycle\"></p>\n<p>\b虽然\b\b内存自动进行\b分配、释放，但并不意味着\b开发者不需要关注内存管理\b。\b因为一些不好的编码会导致\b<a href=\"https://en.wikipedia.org/wiki/Memory_leak#Reference_counting_and_cyclic_references\" target=\"_blank\" rel=\"external\">内存泄露</a>，即应用程序不再\b需要的内存没有被释放掉。因此了解内存管理是很重要的</p>\n<h2 id=\"Javascript中的内存分配\"><a href=\"#Javascript中的内存分配\" class=\"headerlink\" title=\"Javascript中的\b内存分配\"></a>Javascript中的\b内存分配</h2><p>当声明变量时，JavaScript会自动为变量分配内存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numberVar = <span class=\"number\">100</span>; <span class=\"comment\">//为\b整数分配内存</span></div><div class=\"line\"><span class=\"keyword\">var</span> stringVar = <span class=\"string\">'node simplified'</span>;  <span class=\"comment\">// 为字符串分配内存 </span></div><div class=\"line\"><span class=\"keyword\">var</span> objectVar = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;; <span class=\"comment\">// 为对象分配内存</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"string\">'abra'</span>]; <span class=\"comment\">// 为数组分配内存</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + <span class=\"number\">2</span>;</div><div class=\"line\">&#125; <span class=\"comment\">// 为函数\b分配内存</span></div></pre></td></tr></table></figure></p>\n<p>\b当内存不再需要时，会自动释放掉。内存泄露和在释放内存时出现的大部分与内存相关的问题，而要找出那些被垃圾回收器跟踪\b不再需要的而又没有被释放的内存是很困难的。</p>\n<h2 id=\"GC-Garbage-collection\"><a href=\"#GC-Garbage-collection\" class=\"headerlink\" title=\"GC(Garbage collection)\"></a>GC(Garbage collection)</h2><p>\b垃圾回收是追踪并释放应用程序不再\b使用的内存过程。垃圾回收器通\b过算法来实现追踪应用程序不再使用的内存。\b\b主要涉及的垃圾回收算法如下：</p>\n<ul>\n<li>Reference-counting garbage collection（引用计数）</li>\n<li>Mark-and-sweep algorithm（标记清除）</li>\n</ul>\n<h3 id=\"Reference-counting-garbage-collection（引用计数）\"><a href=\"#Reference-counting-garbage-collection（引用计数）\" class=\"headerlink\" title=\"Reference-counting garbage collection（引用计数）\"></a>Reference-counting garbage collection（引用计数）</h3><p>引用计数算法是\b一种最基础的垃圾回收算法，当一个\b对象的引用数为零时，会被自动回收。该算法将\b\b一个对象的引用数为0时视为应用程序不再\b需要的\b内存。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o1 = &#123;<span class=\"attr\">a</span>: &#123;<span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;&#125;,<span class=\"comment\">// 两个对象被创建A:&#123;a: &#123;b: 2&#125;&#125;，B:&#123;b: 2&#125;，对象B被对象A的属性a引用，对象A被\b\b赋值给变量o1。\bA和B的引用数都为1，因此不能被回收。</span></div><div class=\"line\">      o2 = o1; <span class=\"comment\">// 将对象A赋给\b变量o2。此时A引用数为2，B\b引用数1。</span></div><div class=\"line\">      o1 = <span class=\"number\">1</span>;<span class=\"comment\">// \b将变量o1对对象A引用切断。此时A引用数为1，B引用数1。</span></div><div class=\"line\">  <span class=\"keyword\">var</span> oa = o2.a; <span class=\"comment\">// 将对象B赋值给变量oa。此时A引用数为1，B引用数2。</span></div><div class=\"line\">      o2 = <span class=\"string\">'foo'</span>; <span class=\"comment\">// 将变量o2对对象A\b引用切断。此时A引用数为0，B引用数1。因为对象A的a\b属性被\b变量oa引用，因此对象A不能被释放。</span></div><div class=\"line\">      oa = <span class=\"literal\">null</span>; <span class=\"comment\">// 将变量oa对对象B引用切断。此时A引用数为0，B引用数\b0。A与B会被\b回收。</span></div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<h4 id=\"引用计数的限制：循环引用\"><a href=\"#引用计数的限制：循环引用\" class=\"headerlink\" title=\"引用计数的\b限制：循环引用\"></a>引用计数的\b限制：循环引用</h4><p>  循环引用存在一个限制。如下实例，两个对象相互引用，形成一个循环引用。正常情况下，当函数\b执行完后，\b对应的内存\b\b会被释放掉。而\b<strong>引用计数算法</strong>会将循环引用对象的引用数都视为至少为1，因此不能被回收。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">var</span> o2 = &#123;&#125;;</div><div class=\"line\">  o.a = o2; <span class=\"comment\">// o references o2</span></div><div class=\"line\">  o2.a = o; <span class=\"comment\">// o2 references o</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'azerty'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f();</div></pre></td></tr></table></figure>\n<p><img src=\"./cycle.png\" alt=\"cycle\"></p>\n<h4 id=\"常见问题实例\"><a href=\"#常见问题实例\" class=\"headerlink\" title=\"常见问题实例\"></a>常见问题实例</h4><p>  IE6-7\b的DOM对象是基于计数引用\b\b\b算法进行垃圾回收的。而循环引用通常会导致内存\b泄露：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> div;</div><div class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myDivElement'</span>);</div><div class=\"line\">  div.circularReference = div;</div><div class=\"line\">  div.lotsOfData = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">'*'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如上述实例，DOM元素div通过自身的“circularReference”属性循环引用自己。如果没有显式将该属性删除或\b设为null，\b计数引用垃圾回收器会\b始终持有\b至少一个引用。即使DOM元素从DOM树种\b移除，DOM元素的内存\b会一直存在。如果DOM元素持有一些数据（如实例中“lotsData”属性），该数据对应的内存也无法\b被释放。<br>\b</p>\n<h3 id=\"Mark-and-sweep-algorithm（标记清除）\"><a href=\"#Mark-and-sweep-algorithm（标记清除）\" class=\"headerlink\" title=\"Mark-and-sweep algorithm（标记清除）\"></a>Mark-and-sweep algorithm（标记清除）</h3><p>该算法将“对象不再需要”的定义\b简化为“对象不可到达”。<br>这个算法假设有一组\b被称为roots的对象（在JavaScript中，root就是全局对象）。垃圾回收器会\b定期地\b从这些roots开始，查找所有从根开始引用的对象，然后查找这些对象引用的对象……。\b从\broots开始，垃圾回收器会\b查找所有可到达对象，并回收不可到达的对象。</p>\n<p>为了确定对象是否需要，该算法要确定对象是否可到达。由如下步骤组成：</p>\n<ol>\n<li>垃圾回收器会\b创建一组roots，roots通常是持有引用的全局变量。在JavaScript中，window对象就可作为root的全局变量。</li>\n<li>垃圾回收器会检查所有的roots并标记为活跃状态。然后\b递归遍历所有的子变量。\b只要从root不能到达的都被标记为垃圾。</li>\n<li>\b所有没有被标记为活跃状态的内存块\b都被视为垃圾。\b垃圾回收器就可以释放\b这部分内存并把释放的内存返回给操作系统。</li>\n</ol>\n<p><img src=\"./mark-sweep.gif\" alt=\"\"></p>\n<p>这个算法比引用计数算法更优，因为“\b\b零引\b用的对象”总是不可到达的，但\b反\b之则不一定，如\b循环引用。<br>截至2012年，所有现代浏览器都内置了\b<strong>标记清除垃圾回收器</strong>。\b\b\b在过去几年里所有对JavaScript垃圾回收的改进（<a href=\"http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection\" target=\"_blank\" rel=\"external\">generational/incremental/concurrent/parallel garbage collection</a>）都是基于<strong>标记清除算法</strong>来实现的，并没有改变<strong>标记清除算法</strong>本身和它对“对象不再需要”定义的简化。<br>\b</p>\n<h4 id=\"循环引用不再是问题\"><a href=\"#循环引用不再是问题\" class=\"headerlink\" title=\"循环引用不再\b是问题\"></a>循环引用不再\b是问题</h4><p>\b\b前面循环引用的实例中，在函数执行完后，两个对象不再被全局对象\b可访问的对象引用。因此\b\b这两\b个对象被\b垃圾回收器标记为不可到达\b，接着被回收掉。<br><img src=\"./no-cycle.png\" alt=\"\"></p>\n<h4 id=\"限制：需要明确无法到达的对象\"><a href=\"#限制：需要明确无法到达的对象\" class=\"headerlink\" title=\"限制：需要明确无法到达的对象\"></a>限制：需要明确无法到达的对象</h4><p>\b尽管这是一个\b限制，但实践中很少遇见这种情况，所以开发者不太会去关心垃圾回收机制。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html\" target=\"_blank\" rel=\"external\">Memory Management And Garbage Collection In Javascript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"external\">Memory Management</a></li>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec\" target=\"_blank\" rel=\"external\">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li>\n<li><a href=\"http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection\" target=\"_blank\" rel=\"external\">Memory Management Reference</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>C、C++语言需要手动管理内存的分配与释放（常用方法：malloc(), calloc(), realloc()和free()等）。而JavaScript与Java、C#相似，内置了垃圾回收器，能自动管理内存的分配与释放。</p>\n<h2 id=\"内存生命周期\"><a href=\"#内存生命周期\" class=\"headerlink\" title=\"内存生命周期:\"></a>内存生命周期:</h2><ol>\n<li>分配内存</li>\n<li>使用分配的内存(读与写操作)</li>\n<li>当应用程序不再需要时，释放掉\b已分配的内存</li>\n</ol>\n<p><img src=\"./life-cycle.png\" alt=\"lifecycle\"></p>\n<p>\b虽然\b\b内存自动进行\b分配、释放，但并不意味着\b开发者不需要关注内存管理\b。\b因为一些不好的编码会导致\b<a href=\"https://en.wikipedia.org/wiki/Memory_leak#Reference_counting_and_cyclic_references\" target=\"_blank\" rel=\"external\">内存泄露</a>，即应用程序不再\b需要的内存没有被释放掉。因此了解内存管理是很重要的</p>\n<h2 id=\"Javascript中的内存分配\"><a href=\"#Javascript中的内存分配\" class=\"headerlink\" title=\"Javascript中的\b内存分配\"></a>Javascript中的\b内存分配</h2><p>当声明变量时，JavaScript会自动为变量分配内存<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> numberVar = <span class=\"number\">100</span>; <span class=\"comment\">//为\b整数分配内存</span></div><div class=\"line\"><span class=\"keyword\">var</span> stringVar = <span class=\"string\">'node simplified'</span>;  <span class=\"comment\">// 为字符串分配内存 </span></div><div class=\"line\"><span class=\"keyword\">var</span> objectVar = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;; <span class=\"comment\">// 为对象分配内存</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"literal\">null</span>, <span class=\"string\">'abra'</span>]; <span class=\"comment\">// 为数组分配内存</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> a + <span class=\"number\">2</span>;</div><div class=\"line\">&#125; <span class=\"comment\">// 为函数\b分配内存</span></div></pre></td></tr></table></figure></p>\n<p>\b当内存不再需要时，会自动释放掉。内存泄露和在释放内存时出现的大部分与内存相关的问题，而要找出那些被垃圾回收器跟踪\b不再需要的而又没有被释放的内存是很困难的。</p>\n<h2 id=\"GC-Garbage-collection\"><a href=\"#GC-Garbage-collection\" class=\"headerlink\" title=\"GC(Garbage collection)\"></a>GC(Garbage collection)</h2><p>\b垃圾回收是追踪并释放应用程序不再\b使用的内存过程。垃圾回收器通\b过算法来实现追踪应用程序不再使用的内存。\b\b主要涉及的垃圾回收算法如下：</p>\n<ul>\n<li>Reference-counting garbage collection（引用计数）</li>\n<li>Mark-and-sweep algorithm（标记清除）</li>\n</ul>\n<h3 id=\"Reference-counting-garbage-collection（引用计数）\"><a href=\"#Reference-counting-garbage-collection（引用计数）\" class=\"headerlink\" title=\"Reference-counting garbage collection（引用计数）\"></a>Reference-counting garbage collection（引用计数）</h3><p>引用计数算法是\b一种最基础的垃圾回收算法，当一个\b对象的引用数为零时，会被自动回收。该算法将\b\b一个对象的引用数为0时视为应用程序不再\b需要的\b内存。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o1 = &#123;<span class=\"attr\">a</span>: &#123;<span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;&#125;,<span class=\"comment\">// 两个对象被创建A:&#123;a: &#123;b: 2&#125;&#125;，B:&#123;b: 2&#125;，对象B被对象A的属性a引用，对象A被\b\b赋值给变量o1。\bA和B的引用数都为1，因此不能被回收。</span></div><div class=\"line\">      o2 = o1; <span class=\"comment\">// 将对象A赋给\b变量o2。此时A引用数为2，B\b引用数1。</span></div><div class=\"line\">      o1 = <span class=\"number\">1</span>;<span class=\"comment\">// \b将变量o1对对象A引用切断。此时A引用数为1，B引用数1。</span></div><div class=\"line\">  <span class=\"keyword\">var</span> oa = o2.a; <span class=\"comment\">// 将对象B赋值给变量oa。此时A引用数为1，B引用数2。</span></div><div class=\"line\">      o2 = <span class=\"string\">'foo'</span>; <span class=\"comment\">// 将变量o2对对象A\b引用切断。此时A引用数为0，B引用数1。因为对象A的a\b属性被\b变量oa引用，因此对象A不能被释放。</span></div><div class=\"line\">      oa = <span class=\"literal\">null</span>; <span class=\"comment\">// 将变量oa对对象B引用切断。此时A引用数为0，B引用数\b0。A与B会被\b回收。</span></div><div class=\"line\">&#125;()</div></pre></td></tr></table></figure>\n<h4 id=\"引用计数的限制：循环引用\"><a href=\"#引用计数的限制：循环引用\" class=\"headerlink\" title=\"引用计数的\b限制：循环引用\"></a>引用计数的\b限制：循环引用</h4><p>  循环引用存在一个限制。如下实例，两个对象相互引用，形成一个循环引用。正常情况下，当函数\b执行完后，\b对应的内存\b\b会被释放掉。而\b<strong>引用计数算法</strong>会将循环引用对象的引用数都视为至少为1，因此不能被回收。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> o = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">var</span> o2 = &#123;&#125;;</div><div class=\"line\">  o.a = o2; <span class=\"comment\">// o references o2</span></div><div class=\"line\">  o2.a = o; <span class=\"comment\">// o2 references o</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'azerty'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">f();</div></pre></td></tr></table></figure>\n<p><img src=\"./cycle.png\" alt=\"cycle\"></p>\n<h4 id=\"常见问题实例\"><a href=\"#常见问题实例\" class=\"headerlink\" title=\"常见问题实例\"></a>常见问题实例</h4><p>  IE6-7\b的DOM对象是基于计数引用\b\b\b算法进行垃圾回收的。而循环引用通常会导致内存\b泄露：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> div;</div><div class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  div = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myDivElement'</span>);</div><div class=\"line\">  div.circularReference = div;</div><div class=\"line\">  div.lotsOfData = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">'*'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>如上述实例，DOM元素div通过自身的“circularReference”属性循环引用自己。如果没有显式将该属性删除或\b设为null，\b计数引用垃圾回收器会\b始终持有\b至少一个引用。即使DOM元素从DOM树种\b移除，DOM元素的内存\b会一直存在。如果DOM元素持有一些数据（如实例中“lotsData”属性），该数据对应的内存也无法\b被释放。<br>\b</p>\n<h3 id=\"Mark-and-sweep-algorithm（标记清除）\"><a href=\"#Mark-and-sweep-algorithm（标记清除）\" class=\"headerlink\" title=\"Mark-and-sweep algorithm（标记清除）\"></a>Mark-and-sweep algorithm（标记清除）</h3><p>该算法将“对象不再需要”的定义\b简化为“对象不可到达”。<br>这个算法假设有一组\b被称为roots的对象（在JavaScript中，root就是全局对象）。垃圾回收器会\b定期地\b从这些roots开始，查找所有从根开始引用的对象，然后查找这些对象引用的对象……。\b从\broots开始，垃圾回收器会\b查找所有可到达对象，并回收不可到达的对象。</p>\n<p>为了确定对象是否需要，该算法要确定对象是否可到达。由如下步骤组成：</p>\n<ol>\n<li>垃圾回收器会\b创建一组roots，roots通常是持有引用的全局变量。在JavaScript中，window对象就可作为root的全局变量。</li>\n<li>垃圾回收器会检查所有的roots并标记为活跃状态。然后\b递归遍历所有的子变量。\b只要从root不能到达的都被标记为垃圾。</li>\n<li>\b所有没有被标记为活跃状态的内存块\b都被视为垃圾。\b垃圾回收器就可以释放\b这部分内存并把释放的内存返回给操作系统。</li>\n</ol>\n<p><img src=\"./mark-sweep.gif\" alt=\"\"></p>\n<p>这个算法比引用计数算法更优，因为“\b\b零引\b用的对象”总是不可到达的，但\b反\b之则不一定，如\b循环引用。<br>截至2012年，所有现代浏览器都内置了\b<strong>标记清除垃圾回收器</strong>。\b\b\b在过去几年里所有对JavaScript垃圾回收的改进（<a href=\"http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection\" target=\"_blank\" rel=\"external\">generational/incremental/concurrent/parallel garbage collection</a>）都是基于<strong>标记清除算法</strong>来实现的，并没有改变<strong>标记清除算法</strong>本身和它对“对象不再需要”定义的简化。<br>\b</p>\n<h4 id=\"循环引用不再是问题\"><a href=\"#循环引用不再是问题\" class=\"headerlink\" title=\"循环引用不再\b是问题\"></a>循环引用不再\b是问题</h4><p>\b\b前面循环引用的实例中，在函数执行完后，两个对象不再被全局对象\b可访问的对象引用。因此\b\b这两\b个对象被\b垃圾回收器标记为不可到达\b，接着被回收掉。<br><img src=\"./no-cycle.png\" alt=\"\"></p>\n<h4 id=\"限制：需要明确无法到达的对象\"><a href=\"#限制：需要明确无法到达的对象\" class=\"headerlink\" title=\"限制：需要明确无法到达的对象\"></a>限制：需要明确无法到达的对象</h4><p>\b尽管这是一个\b限制，但实践中很少遇见这种情况，所以开发者不太会去关心垃圾回收机制。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"http://www.nodesimplified.com/2017/08/javascript-memory-management-and.html\" target=\"_blank\" rel=\"external\">Memory Management And Garbage Collection In Javascript</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management\" target=\"_blank\" rel=\"external\">Memory Management</a></li>\n<li><a href=\"https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec\" target=\"_blank\" rel=\"external\">How JavaScript works: memory management + how to handle 4 common memory leaks</a></li>\n<li><a href=\"http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection\" target=\"_blank\" rel=\"external\">Memory Management Reference</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n"},{"title":"async-vs-defer","date":"2017-09-19T11:16:04.000Z","author":"singsong","_content":"\n> **async**与**defer**都是用来延迟（异步）加载脚本，但两者之间还是存在一些区别的，因此使用场景也有所不同。\n\n\n## Legend\n\n![legend](./legend.svg)\n\n\n## script\nscript标签不带\b**async**或**defer**特性时。当浏览器解析HTML遇到该script标签时，会暂停解析工作。然后会发起脚本请求，在脚本下载完便开始执行，只有在\b脚本执行完之后才恢复\b\b\b\bHTML解析。\n\n\n![script](./script.svg)\n\n## script with async\n\nscript标签带**async**特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，只有在脚本下载完\b开始执行时，才会阻塞HTML的解析。**async**可以不能保证脚本执行顺序（在文档中出现的\b顺序），因为执行顺序取决于下载完的\b顺序。\n\n\n![script](./script-async.svg)\n\n## script with defer\n\nscript标签带**defer**特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，脚本\u001f只有在\bHTML解析完之后才开始执行。**defer**可以保证脚本执行顺序（在文档中出现的\b顺序）。\n\n![script](./script-defer.svg)\n\n## 对比\n\n- ### 相同之处：\n  - 在脚本下载时，都不会阻塞文档解析\n  - 支持onload事件回调处理，用于一些初始化工作\n  - 对内联脚本无效\n  - 脚本中不能调用document.write()\n- ### 不同之处：\n  带有async特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有defer特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。\n\n## 使用规则\n一般尽可能使用**async**，然后考虑**defer**，最后不使用任何特性\n- 如果\b脚本是一个模块并且没有依赖于其他\b脚本时，\b使用**async**\n- 如果脚本依赖于其他脚本或被其他脚本依赖时，使用**defer**\n- 如果脚本较小，并且\b被\b其他带**async**的脚本依赖，可以将该脚本直接\b内联script标签中，并放置在**async**脚本之\b前\n\n\b\n## 兼容\n\n在<=IE9\b浏览器对**defer**的实现存在一些bug，如defer不能保证script的执行顺序，如果需要支持\b<=IE9，不建议使用**defer**，如果\bscirpts的执行顺序重要，可以不设置任何特性，[了解更多](https://github.com/h5bp/lazyweb-requests/issues/42)。\n\n## 参考文章：\n- [async vs defer attributes](http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html)\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---","source":"_posts/async-vs-defer.md","raw":"---\ntitle: async-vs-defer\ndate: 2017-09-19 19:16:04\ntags: [defer, async, 优化]\nauthor: singsong\n---\n\n> **async**与**defer**都是用来延迟（异步）加载脚本，但两者之间还是存在一些区别的，因此使用场景也有所不同。\n\n\n## Legend\n\n![legend](./legend.svg)\n\n\n## script\nscript标签不带\b**async**或**defer**特性时。当浏览器解析HTML遇到该script标签时，会暂停解析工作。然后会发起脚本请求，在脚本下载完便开始执行，只有在\b脚本执行完之后才恢复\b\b\b\bHTML解析。\n\n\n![script](./script.svg)\n\n## script with async\n\nscript标签带**async**特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，只有在脚本下载完\b开始执行时，才会阻塞HTML的解析。**async**可以不能保证脚本执行顺序（在文档中出现的\b顺序），因为执行顺序取决于下载完的\b顺序。\n\n\n![script](./script-async.svg)\n\n## script with defer\n\nscript标签带**defer**特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，脚本\u001f只有在\bHTML解析完之后才开始执行。**defer**可以保证脚本执行顺序（在文档中出现的\b顺序）。\n\n![script](./script-defer.svg)\n\n## 对比\n\n- ### 相同之处：\n  - 在脚本下载时，都不会阻塞文档解析\n  - 支持onload事件回调处理，用于一些初始化工作\n  - 对内联脚本无效\n  - 脚本中不能调用document.write()\n- ### 不同之处：\n  带有async特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有defer特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。\n\n## 使用规则\n一般尽可能使用**async**，然后考虑**defer**，最后不使用任何特性\n- 如果\b脚本是一个模块并且没有依赖于其他\b脚本时，\b使用**async**\n- 如果脚本依赖于其他脚本或被其他脚本依赖时，使用**defer**\n- 如果脚本较小，并且\b被\b其他带**async**的脚本依赖，可以将该脚本直接\b内联script标签中，并放置在**async**脚本之\b前\n\n\b\n## 兼容\n\n在<=IE9\b浏览器对**defer**的实现存在一些bug，如defer不能保证script的执行顺序，如果需要支持\b<=IE9，不建议使用**defer**，如果\bscirpts的执行顺序重要，可以不设置任何特性，[了解更多](https://github.com/h5bp/lazyweb-requests/issues/42)。\n\n## 参考文章：\n- [async vs defer attributes](http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html)\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---","slug":"async-vs-defer","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vata400031hn9uzcj3lzi","content":"<blockquote>\n<p><strong>async</strong>与<strong>defer</strong>都是用来延迟（异步）加载脚本，但两者之间还是存在一些区别的，因此使用场景也有所不同。</p>\n</blockquote>\n<h2 id=\"Legend\"><a href=\"#Legend\" class=\"headerlink\" title=\"Legend\"></a>Legend</h2><p><img src=\"./legend.svg\" alt=\"legend\"></p>\n<h2 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h2><p>script标签不带\b<strong>async</strong>或<strong>defer</strong>特性时。当浏览器解析HTML遇到该script标签时，会暂停解析工作。然后会发起脚本请求，在脚本下载完便开始执行，只有在\b脚本执行完之后才恢复\b\b\b\bHTML解析。</p>\n<p><img src=\"./script.svg\" alt=\"script\"></p>\n<h2 id=\"script-with-async\"><a href=\"#script-with-async\" class=\"headerlink\" title=\"script with async\"></a>script with async</h2><p>script标签带<strong>async</strong>特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，只有在脚本下载完\b开始执行时，才会阻塞HTML的解析。<strong>async</strong>可以不能保证脚本执行顺序（在文档中出现的\b顺序），因为执行顺序取决于下载完的\b顺序。</p>\n<p><img src=\"./script-async.svg\" alt=\"script\"></p>\n<h2 id=\"script-with-defer\"><a href=\"#script-with-defer\" class=\"headerlink\" title=\"script with defer\"></a>script with defer</h2><p>script标签带<strong>defer</strong>特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，脚本\u001f只有在\bHTML解析完之后才开始执行。<strong>defer</strong>可以保证脚本执行顺序（在文档中出现的\b顺序）。</p>\n<p><img src=\"./script-defer.svg\" alt=\"script\"></p>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><ul>\n<li><h3 id=\"相同之处：\"><a href=\"#相同之处：\" class=\"headerlink\" title=\"相同之处：\"></a>相同之处：</h3><ul>\n<li>在脚本下载时，都不会阻塞文档解析</li>\n<li>支持onload事件回调处理，用于一些初始化工作</li>\n<li>对内联脚本无效</li>\n<li>脚本中不能调用document.write()</li>\n</ul>\n</li>\n<li><h3 id=\"不同之处：\"><a href=\"#不同之处：\" class=\"headerlink\" title=\"不同之处：\"></a>不同之处：</h3>带有async特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有defer特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。</li>\n</ul>\n<h2 id=\"使用规则\"><a href=\"#使用规则\" class=\"headerlink\" title=\"使用规则\"></a>使用规则</h2><p>一般尽可能使用<strong>async</strong>，然后考虑<strong>defer</strong>，最后不使用任何特性</p>\n<ul>\n<li>如果\b脚本是一个模块并且没有依赖于其他\b脚本时，\b使用<strong>async</strong></li>\n<li>如果脚本依赖于其他脚本或被其他脚本依赖时，使用<strong>defer</strong></li>\n<li>如果脚本较小，并且\b被\b其他带<strong>async</strong>的脚本依赖，可以将该脚本直接\b内联script标签中，并放置在<strong>async</strong>脚本之\b前</li>\n</ul>\n<p>\b</p>\n<h2 id=\"兼容\"><a href=\"#兼容\" class=\"headerlink\" title=\"兼容\"></a>兼容</h2><p>在&lt;=IE9\b浏览器对<strong>defer</strong>的实现存在一些bug，如defer不能保证script的执行顺序，如果需要支持\b&lt;=IE9，不建议使用<strong>defer</strong>，如果\bscirpts的执行顺序重要，可以不设置任何特性，<a href=\"https://github.com/h5bp/lazyweb-requests/issues/42\" target=\"_blank\" rel=\"external\">了解更多</a>。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html\" target=\"_blank\" rel=\"external\">async vs defer attributes</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><strong>async</strong>与<strong>defer</strong>都是用来延迟（异步）加载脚本，但两者之间还是存在一些区别的，因此使用场景也有所不同。</p>\n</blockquote>\n<h2 id=\"Legend\"><a href=\"#Legend\" class=\"headerlink\" title=\"Legend\"></a>Legend</h2><p><img src=\"./legend.svg\" alt=\"legend\"></p>\n<h2 id=\"script\"><a href=\"#script\" class=\"headerlink\" title=\"script\"></a>script</h2><p>script标签不带\b<strong>async</strong>或<strong>defer</strong>特性时。当浏览器解析HTML遇到该script标签时，会暂停解析工作。然后会发起脚本请求，在脚本下载完便开始执行，只有在\b脚本执行完之后才恢复\b\b\b\bHTML解析。</p>\n<p><img src=\"./script.svg\" alt=\"script\"></p>\n<h2 id=\"script-with-async\"><a href=\"#script-with-async\" class=\"headerlink\" title=\"script with async\"></a>script with async</h2><p>script标签带<strong>async</strong>特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，只有在脚本下载完\b开始执行时，才会阻塞HTML的解析。<strong>async</strong>可以不能保证脚本执行顺序（在文档中出现的\b顺序），因为执行顺序取决于下载完的\b顺序。</p>\n<p><img src=\"./script-async.svg\" alt=\"script\"></p>\n<h2 id=\"script-with-defer\"><a href=\"#script-with-defer\" class=\"headerlink\" title=\"script with defer\"></a>script with defer</h2><p>script标签带<strong>defer</strong>特性时。当浏览器解析HTML遇到该script标签时，此时脚本的下载不会阻塞HTML的解析，脚本\u001f只有在\bHTML解析完之后才开始执行。<strong>defer</strong>可以保证脚本执行顺序（在文档中出现的\b顺序）。</p>\n<p><img src=\"./script-defer.svg\" alt=\"script\"></p>\n<h2 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h2><ul>\n<li><h3 id=\"相同之处：\"><a href=\"#相同之处：\" class=\"headerlink\" title=\"相同之处：\"></a>相同之处：</h3><ul>\n<li>在脚本下载时，都不会阻塞文档解析</li>\n<li>支持onload事件回调处理，用于一些初始化工作</li>\n<li>对内联脚本无效</li>\n<li>脚本中不能调用document.write()</li>\n</ul>\n</li>\n<li><h3 id=\"不同之处：\"><a href=\"#不同之处：\" class=\"headerlink\" title=\"不同之处：\"></a>不同之处：</h3>带有async特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有defer特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。</li>\n</ul>\n<h2 id=\"使用规则\"><a href=\"#使用规则\" class=\"headerlink\" title=\"使用规则\"></a>使用规则</h2><p>一般尽可能使用<strong>async</strong>，然后考虑<strong>defer</strong>，最后不使用任何特性</p>\n<ul>\n<li>如果\b脚本是一个模块并且没有依赖于其他\b脚本时，\b使用<strong>async</strong></li>\n<li>如果脚本依赖于其他脚本或被其他脚本依赖时，使用<strong>defer</strong></li>\n<li>如果脚本较小，并且\b被\b其他带<strong>async</strong>的脚本依赖，可以将该脚本直接\b内联script标签中，并放置在<strong>async</strong>脚本之\b前</li>\n</ul>\n<p>\b</p>\n<h2 id=\"兼容\"><a href=\"#兼容\" class=\"headerlink\" title=\"兼容\"></a>兼容</h2><p>在&lt;=IE9\b浏览器对<strong>defer</strong>的实现存在一些bug，如defer不能保证script的执行顺序，如果需要支持\b&lt;=IE9，不建议使用<strong>defer</strong>，如果\bscirpts的执行顺序重要，可以不设置任何特性，<a href=\"https://github.com/h5bp/lazyweb-requests/issues/42\" target=\"_blank\" rel=\"external\">了解更多</a>。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"http://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html\" target=\"_blank\" rel=\"external\">async vs defer attributes</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n"},{"title":"关于z-index的一些事","date":"2017-08-29T06:14:24.000Z","author":"Singsong","_content":"\n一般**z-index\b**失效基本上都是不了解**z-index**是如何工作导致的（这没有看这篇[blog\b](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)之前，至少我也是这样的）。它不复杂，但如果不花时间去查看z-index文档，可能会不了解一些关键技术点。\n\n不信？\b能否解答如下问题，作为检验你是否真正了解**z-index**：\n\n## 问题：\n\nHTML结构如下：\n\n```HTML\n<div>\n  <span class=\"red\">Red</span>\n</div>\n<div>\n  <span class=\"green\">Green</span>\n</div>\n<div>\n  <span class=\"blue\">Blue</span>\n</div>\n```\nCSS如下：\n\n```css\n.red, .green, .blue {\n  position: absolute;\n}\n.red {\n  background: red;\n  z-index: 1;\n}\n.green {\n  background: green;\n}\n.blue {\n  background: blue;\n}\n```\n\n### 如何将“红色块”放置“绿色块”之后，需要满足如下条件：\n\n- 不能修改html结构\n- 不能修改任何元素的z-index属性\n- 不能修改任何元素的position属性\n\n### codepen\b：\n<iframe height='320' scrolling='no' title='JyNRxj' src='//codepen.io/zhansingsong/embed/JyNRxj/?height=330&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/zhansingsong/pen/JyNRxj/'>JyNRxj</a> by zhansingsong (<a href='https://codepen.io/zhansingsong'>@zhansingsong</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n## 解决方法\n\n给\b第一个`div`（即\b\b\b“\b红色块”的\b父节点）添加如下样式：\n\n```css\n  div:first-child {\n    opacity: .99;\n  }\n```\n\n或许你会\b好奇为什么这个`opacity`会让\b“红色块”置于“绿色块”之后（当时我看这个答案也是一脸懵逼了\b😑\b）。希望下文能解惑你的好奇。\n\n### z-index [specification](https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index)\n**z-index**只对**positioned元素**（即该元素的`position`不等于默认`static`外的值）起作用。对应`positoned box`（positioned元素)，**z-index**主要：\n1. 指定该元素在当前**stacking context**的stack层级\n2. 该元素是否创建新的**stacking context**\n\n**z-index**可以取如下值：\n\n- **(integer)整数**：表示当前元素在当前的**stacking context**的stack层级，并会让当前元素创建一个新的**stacking context**\n\n- **auto**: 表示当前元素在当前的**stacking context**的stack层级为0，如果该元素不是**root**元素，就不会创建新的**stacking context**\n\n\n### stacking order\n**stacking context**可以相互嵌套，每个元素（box）都属于一个**stacking context**（自包含），每个`positoned box`在一个**stacking context**中都有一个整数的stack层级，它表示在同一个**stacking context**中的z轴方向stack层级位置。stack层级越大在**stacking context**中的位置越靠前。如果stack层级相同，按其在DOM文档中出现顺序绘制。\n\n### stacking context\n>**The stacking context** is a three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user who is assumed to be facing the viewport or the webpage. HTML elements occupy this space in priority order based on element attributes.——MDN\n\n\n\n**stacking context**的形成条件：\n\n* 文档根节点（HTML）| Root element of document (HTML).\n* 元素的position属性值为`absolute`或`relative`，并且z-index属性为除`auto`外的值 | Element with a position value \"absolute\" or \"relative\" and z-index value other than \"auto\".\n* 元素的position属性值为`fixed`或`sticky` | Element with a position value \"fixed\" or \"sticky\" (sticky for all mobile browsers, but not older desktop).\n* 元素是flexbox容器的子元素，带有z-index属性，且值为除`auto`外的值 | Element that is a child of a flex (flexbox) container, with z-index value other than \"auto\".\n* 元素的opcity属性值小于1 | Element with a opacity value less than 1 (See the specification for opacity).\n* 元素的[mix-blend-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)属性值为除`normal`外的值 | Element with a mix-blend-mode value other than \"normal\".\n* 元素的如下属性值为除`none`外的值 | Element with any of the following properties with value other than \"none\":\n    * [transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)\n    * [filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)\n    * [perspective](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective)\n    * [clip-path](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path)\n    * [mask](https://developer.mozilla.org/en-US/docs/Web/CSS/mask) / [mask-image](https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image) / [mask-border](https://developer.mozilla.org/en-US/docs/Web/CSS/mask-border)\n* 元素的isolation属性值为`isolate` | Element with a [isolation](https://developer.mozilla.org/en-US/docs/Web/CSS/isolation) value \"isolate\".\n* 元素的-webkit-overflow-scrolling属性值为`touch` | Element with a -webkit-overflow-scrolling value \"touch\".\n* 元素带有[will-change](https://developer.mozilla.org/en-US/docs/Web/CSS/will-change)属性 | Element with a will-change value specifying any property that would create a stacking context on non-initial value (see this post).\n\n### painted order in stacking context\n\n  1. 形成**stacking context**元素的`background`和`borders` | the background and borders of the element forming the stacking context.\n  2. 负数的stack层级的**child stacking context**(负数值越大越前) | the child stacking contexts with negative stack levels (most negative first).\n  3. 文档流中非inline级、非positioned子节点 | the in-flow, non-inline-level, non-positioned descendants.\n  4. 非positioned浮动子节点 | the non-positioned floats.\n  5. 文档流中非positioned的inline级子节点（包括inline tables和inline blocks） | the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.\n  6. stack层级为0的**child stacking context**和positoned子节点 | the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.\n  7. stack层级为正整数的**child stacking context** | the child stacking contexts with positive stack levels (least positive first).\n  ### Example\n  <iframe height='265' scrolling='no' title='stackLevel' src='//codepen.io/zhansingsong/embed/WEMrNK/?height=265&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/zhansingsong/pen/WEMrNK/'>stackLevel</a> by zhansingsong (<a href='https://codepen.io/zhansingsong'>@zhansingsong</a>) on <a href='https://codepen.io'>CodePen</a>.\n  </iframe>\n\n\n## 参考文章：\n- [What No One Told You About Z-Index](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)\n- [The stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)\n- [Specifying the stack level: the 'z-index' property](https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index)\n\n\n</br>\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---","source":"_posts/css-zIndex.md","raw":"---\ntitle: 关于z-index的一些事\ndate: 2017-08-29 14:14:24\nauthor: Singsong\ntags: css\n---\n\n一般**z-index\b**失效基本上都是不了解**z-index**是如何工作导致的（这没有看这篇[blog\b](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)之前，至少我也是这样的）。它不复杂，但如果不花时间去查看z-index文档，可能会不了解一些关键技术点。\n\n不信？\b能否解答如下问题，作为检验你是否真正了解**z-index**：\n\n## 问题：\n\nHTML结构如下：\n\n```HTML\n<div>\n  <span class=\"red\">Red</span>\n</div>\n<div>\n  <span class=\"green\">Green</span>\n</div>\n<div>\n  <span class=\"blue\">Blue</span>\n</div>\n```\nCSS如下：\n\n```css\n.red, .green, .blue {\n  position: absolute;\n}\n.red {\n  background: red;\n  z-index: 1;\n}\n.green {\n  background: green;\n}\n.blue {\n  background: blue;\n}\n```\n\n### 如何将“红色块”放置“绿色块”之后，需要满足如下条件：\n\n- 不能修改html结构\n- 不能修改任何元素的z-index属性\n- 不能修改任何元素的position属性\n\n### codepen\b：\n<iframe height='320' scrolling='no' title='JyNRxj' src='//codepen.io/zhansingsong/embed/JyNRxj/?height=330&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/zhansingsong/pen/JyNRxj/'>JyNRxj</a> by zhansingsong (<a href='https://codepen.io/zhansingsong'>@zhansingsong</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n## 解决方法\n\n给\b第一个`div`（即\b\b\b“\b红色块”的\b父节点）添加如下样式：\n\n```css\n  div:first-child {\n    opacity: .99;\n  }\n```\n\n或许你会\b好奇为什么这个`opacity`会让\b“红色块”置于“绿色块”之后（当时我看这个答案也是一脸懵逼了\b😑\b）。希望下文能解惑你的好奇。\n\n### z-index [specification](https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index)\n**z-index**只对**positioned元素**（即该元素的`position`不等于默认`static`外的值）起作用。对应`positoned box`（positioned元素)，**z-index**主要：\n1. 指定该元素在当前**stacking context**的stack层级\n2. 该元素是否创建新的**stacking context**\n\n**z-index**可以取如下值：\n\n- **(integer)整数**：表示当前元素在当前的**stacking context**的stack层级，并会让当前元素创建一个新的**stacking context**\n\n- **auto**: 表示当前元素在当前的**stacking context**的stack层级为0，如果该元素不是**root**元素，就不会创建新的**stacking context**\n\n\n### stacking order\n**stacking context**可以相互嵌套，每个元素（box）都属于一个**stacking context**（自包含），每个`positoned box`在一个**stacking context**中都有一个整数的stack层级，它表示在同一个**stacking context**中的z轴方向stack层级位置。stack层级越大在**stacking context**中的位置越靠前。如果stack层级相同，按其在DOM文档中出现顺序绘制。\n\n### stacking context\n>**The stacking context** is a three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user who is assumed to be facing the viewport or the webpage. HTML elements occupy this space in priority order based on element attributes.——MDN\n\n\n\n**stacking context**的形成条件：\n\n* 文档根节点（HTML）| Root element of document (HTML).\n* 元素的position属性值为`absolute`或`relative`，并且z-index属性为除`auto`外的值 | Element with a position value \"absolute\" or \"relative\" and z-index value other than \"auto\".\n* 元素的position属性值为`fixed`或`sticky` | Element with a position value \"fixed\" or \"sticky\" (sticky for all mobile browsers, but not older desktop).\n* 元素是flexbox容器的子元素，带有z-index属性，且值为除`auto`外的值 | Element that is a child of a flex (flexbox) container, with z-index value other than \"auto\".\n* 元素的opcity属性值小于1 | Element with a opacity value less than 1 (See the specification for opacity).\n* 元素的[mix-blend-mode](https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode)属性值为除`normal`外的值 | Element with a mix-blend-mode value other than \"normal\".\n* 元素的如下属性值为除`none`外的值 | Element with any of the following properties with value other than \"none\":\n    * [transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)\n    * [filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)\n    * [perspective](https://developer.mozilla.org/en-US/docs/Web/CSS/perspective)\n    * [clip-path](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path)\n    * [mask](https://developer.mozilla.org/en-US/docs/Web/CSS/mask) / [mask-image](https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image) / [mask-border](https://developer.mozilla.org/en-US/docs/Web/CSS/mask-border)\n* 元素的isolation属性值为`isolate` | Element with a [isolation](https://developer.mozilla.org/en-US/docs/Web/CSS/isolation) value \"isolate\".\n* 元素的-webkit-overflow-scrolling属性值为`touch` | Element with a -webkit-overflow-scrolling value \"touch\".\n* 元素带有[will-change](https://developer.mozilla.org/en-US/docs/Web/CSS/will-change)属性 | Element with a will-change value specifying any property that would create a stacking context on non-initial value (see this post).\n\n### painted order in stacking context\n\n  1. 形成**stacking context**元素的`background`和`borders` | the background and borders of the element forming the stacking context.\n  2. 负数的stack层级的**child stacking context**(负数值越大越前) | the child stacking contexts with negative stack levels (most negative first).\n  3. 文档流中非inline级、非positioned子节点 | the in-flow, non-inline-level, non-positioned descendants.\n  4. 非positioned浮动子节点 | the non-positioned floats.\n  5. 文档流中非positioned的inline级子节点（包括inline tables和inline blocks） | the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.\n  6. stack层级为0的**child stacking context**和positoned子节点 | the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.\n  7. stack层级为正整数的**child stacking context** | the child stacking contexts with positive stack levels (least positive first).\n  ### Example\n  <iframe height='265' scrolling='no' title='stackLevel' src='//codepen.io/zhansingsong/embed/WEMrNK/?height=265&theme-id=dark&default-tab=css,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/zhansingsong/pen/WEMrNK/'>stackLevel</a> by zhansingsong (<a href='https://codepen.io/zhansingsong'>@zhansingsong</a>) on <a href='https://codepen.io'>CodePen</a>.\n  </iframe>\n\n\n## 参考文章：\n- [What No One Told You About Z-Index](https://philipwalton.com/articles/what-no-one-told-you-about-z-index/)\n- [The stacking context](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)\n- [Specifying the stack level: the 'z-index' property](https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index)\n\n\n</br>\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---","slug":"css-zIndex","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vata700051hn94qwnhaqt","content":"<p>一般<strong>z-index\b</strong>失效基本上都是不了解<strong>z-index</strong>是如何工作导致的（这没有看这篇<a href=\"https://philipwalton.com/articles/what-no-one-told-you-about-z-index/\" target=\"_blank\" rel=\"external\">blog\b</a>之前，至少我也是这样的）。它不复杂，但如果不花时间去查看z-index文档，可能会不了解一些关键技术点。</p>\n<p>不信？\b能否解答如下问题，作为检验你是否真正了解<strong>z-index</strong>：</p>\n<h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h2><p>HTML结构如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red\"</span>&gt;</span>Red<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"green\"</span>&gt;</span>Green<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blue\"</span>&gt;</span>Blue<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.red</span>, <span class=\"selector-class\">.green</span>, <span class=\"selector-class\">.blue</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.red</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: red;</div><div class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.green</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.blue</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"如何将“红色块”放置“绿色块”之后，需要满足如下条件：\"><a href=\"#如何将“红色块”放置“绿色块”之后，需要满足如下条件：\" class=\"headerlink\" title=\"如何将“红色块”放置“绿色块”之后，需要满足如下条件：\"></a>如何将“红色块”放置“绿色块”之后，需要满足如下条件：</h3><ul>\n<li>不能修改html结构</li>\n<li>不能修改任何元素的z-index属性</li>\n<li>不能修改任何元素的position属性</li>\n</ul>\n<h3 id=\"codepen：\"><a href=\"#codepen：\" class=\"headerlink\" title=\"codepen\b：\"></a>codepen\b：</h3><iframe height=\"320\" scrolling=\"no\" title=\"JyNRxj\" src=\"//codepen.io/zhansingsong/embed/JyNRxj/?height=330&theme-id=dark&default-tab=css,result&embed-version=2\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\"https://codepen.io/zhansingsong/pen/JyNRxj/\" target=\"_blank\" rel=\"external\">JyNRxj</a> by zhansingsong (<a href=\"https://codepen.io/zhansingsong\" target=\"_blank\" rel=\"external\">@zhansingsong</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.<br></iframe>\n\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>给\b第一个<code>div</code>（即\b\b\b“\b红色块”的\b父节点）添加如下样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:first-child</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: .<span class=\"number\">99</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或许你会\b好奇为什么这个<code>opacity</code>会让\b“红色块”置于“绿色块”之后（当时我看这个答案也是一脸懵逼了\b😑\b）。希望下文能解惑你的好奇。</p>\n<h3 id=\"z-index-specification\"><a href=\"#z-index-specification\" class=\"headerlink\" title=\"z-index specification\"></a>z-index <a href=\"https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index\" target=\"_blank\" rel=\"external\">specification</a></h3><p><strong>z-index</strong>只对<strong>positioned元素</strong>（即该元素的<code>position</code>不等于默认<code>static</code>外的值）起作用。对应<code>positoned box</code>（positioned元素)，<strong>z-index</strong>主要：</p>\n<ol>\n<li>指定该元素在当前<strong>stacking context</strong>的stack层级</li>\n<li>该元素是否创建新的<strong>stacking context</strong></li>\n</ol>\n<p><strong>z-index</strong>可以取如下值：</p>\n<ul>\n<li><p><strong>(integer)整数</strong>：表示当前元素在当前的<strong>stacking context</strong>的stack层级，并会让当前元素创建一个新的<strong>stacking context</strong></p>\n</li>\n<li><p><strong>auto</strong>: 表示当前元素在当前的<strong>stacking context</strong>的stack层级为0，如果该元素不是<strong>root</strong>元素，就不会创建新的<strong>stacking context</strong></p>\n</li>\n</ul>\n<h3 id=\"stacking-order\"><a href=\"#stacking-order\" class=\"headerlink\" title=\"stacking order\"></a>stacking order</h3><p><strong>stacking context</strong>可以相互嵌套，每个元素（box）都属于一个<strong>stacking context</strong>（自包含），每个<code>positoned box</code>在一个<strong>stacking context</strong>中都有一个整数的stack层级，它表示在同一个<strong>stacking context</strong>中的z轴方向stack层级位置。stack层级越大在<strong>stacking context</strong>中的位置越靠前。如果stack层级相同，按其在DOM文档中出现顺序绘制。</p>\n<h3 id=\"stacking-context\"><a href=\"#stacking-context\" class=\"headerlink\" title=\"stacking context\"></a>stacking context</h3><blockquote>\n<p><strong>The stacking context</strong> is a three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user who is assumed to be facing the viewport or the webpage. HTML elements occupy this space in priority order based on element attributes.——MDN</p>\n</blockquote>\n<p><strong>stacking context</strong>的形成条件：</p>\n<ul>\n<li>文档根节点（HTML）| Root element of document (HTML).</li>\n<li>元素的position属性值为<code>absolute</code>或<code>relative</code>，并且z-index属性为除<code>auto</code>外的值 | Element with a position value “absolute” or “relative” and z-index value other than “auto”.</li>\n<li>元素的position属性值为<code>fixed</code>或<code>sticky</code> | Element with a position value “fixed” or “sticky” (sticky for all mobile browsers, but not older desktop).</li>\n<li>元素是flexbox容器的子元素，带有z-index属性，且值为除<code>auto</code>外的值 | Element that is a child of a flex (flexbox) container, with z-index value other than “auto”.</li>\n<li>元素的opcity属性值小于1 | Element with a opacity value less than 1 (See the specification for opacity).</li>\n<li>元素的<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode\" target=\"_blank\" rel=\"external\">mix-blend-mode</a>属性值为除<code>normal</code>外的值 | Element with a mix-blend-mode value other than “normal”.</li>\n<li>元素的如下属性值为除<code>none</code>外的值 | Element with any of the following properties with value other than “none”:<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform\" target=\"_blank\" rel=\"external\">transform</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/filter\" target=\"_blank\" rel=\"external\">filter</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\" target=\"_blank\" rel=\"external\">perspective</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path\" target=\"_blank\" rel=\"external\">clip-path</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mask\" target=\"_blank\" rel=\"external\">mask</a> / <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image\" target=\"_blank\" rel=\"external\">mask-image</a> / <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mask-border\" target=\"_blank\" rel=\"external\">mask-border</a></li>\n</ul>\n</li>\n<li>元素的isolation属性值为<code>isolate</code> | Element with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/isolation\" target=\"_blank\" rel=\"external\">isolation</a> value “isolate”.</li>\n<li>元素的-webkit-overflow-scrolling属性值为<code>touch</code> | Element with a -webkit-overflow-scrolling value “touch”.</li>\n<li>元素带有<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\" target=\"_blank\" rel=\"external\">will-change</a>属性 | Element with a will-change value specifying any property that would create a stacking context on non-initial value (see this post).</li>\n</ul>\n<h3 id=\"painted-order-in-stacking-context\"><a href=\"#painted-order-in-stacking-context\" class=\"headerlink\" title=\"painted order in stacking context\"></a>painted order in stacking context</h3><ol>\n<li>形成<strong>stacking context</strong>元素的<code>background</code>和<code>borders</code> | the background and borders of the element forming the stacking context.</li>\n<li>负数的stack层级的<strong>child stacking context</strong>(负数值越大越前) | the child stacking contexts with negative stack levels (most negative first).</li>\n<li>文档流中非inline级、非positioned子节点 | the in-flow, non-inline-level, non-positioned descendants.</li>\n<li>非positioned浮动子节点 | the non-positioned floats.</li>\n<li>文档流中非positioned的inline级子节点（包括inline tables和inline blocks） | the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.</li>\n<li>stack层级为0的<strong>child stacking context</strong>和positoned子节点 | the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.</li>\n<li>stack层级为正整数的<strong>child stacking context</strong> | the child stacking contexts with positive stack levels (least positive first).<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><iframe height=\"265\" scrolling=\"no\" title=\"stackLevel\" src=\"//codepen.io/zhansingsong/embed/WEMrNK/?height=265&theme-id=dark&default-tab=css,result&embed-version=2\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\"https://codepen.io/zhansingsong/pen/WEMrNK/\" target=\"_blank\" rel=\"external\">stackLevel</a> by zhansingsong (<a href=\"https://codepen.io/zhansingsong\" target=\"_blank\" rel=\"external\">@zhansingsong</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.<br></iframe>\n\n\n</li>\n</ol>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"https://philipwalton.com/articles/what-no-one-told-you-about-z-index/\" target=\"_blank\" rel=\"external\">What No One Told You About Z-Index</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\" target=\"_blank\" rel=\"external\">The stacking context</a></li>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index\" target=\"_blank\" rel=\"external\">Specifying the stack level: the ‘z-index’ property</a></li>\n</ul>\n<p><br></p>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>一般<strong>z-index\b</strong>失效基本上都是不了解<strong>z-index</strong>是如何工作导致的（这没有看这篇<a href=\"https://philipwalton.com/articles/what-no-one-told-you-about-z-index/\" target=\"_blank\" rel=\"external\">blog\b</a>之前，至少我也是这样的）。它不复杂，但如果不花时间去查看z-index文档，可能会不了解一些关键技术点。</p>\n<p>不信？\b能否解答如下问题，作为检验你是否真正了解<strong>z-index</strong>：</p>\n<h2 id=\"问题：\"><a href=\"#问题：\" class=\"headerlink\" title=\"问题：\"></a>问题：</h2><p>HTML结构如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"red\"</span>&gt;</span>Red<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"green\"</span>&gt;</span>Green<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"blue\"</span>&gt;</span>Blue<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>CSS如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-class\">.red</span>, <span class=\"selector-class\">.green</span>, <span class=\"selector-class\">.blue</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.red</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: red;</div><div class=\"line\">  <span class=\"attribute\">z-index</span>: <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.green</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: green;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.blue</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">background</span>: blue;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"如何将“红色块”放置“绿色块”之后，需要满足如下条件：\"><a href=\"#如何将“红色块”放置“绿色块”之后，需要满足如下条件：\" class=\"headerlink\" title=\"如何将“红色块”放置“绿色块”之后，需要满足如下条件：\"></a>如何将“红色块”放置“绿色块”之后，需要满足如下条件：</h3><ul>\n<li>不能修改html结构</li>\n<li>不能修改任何元素的z-index属性</li>\n<li>不能修改任何元素的position属性</li>\n</ul>\n<h3 id=\"codepen：\"><a href=\"#codepen：\" class=\"headerlink\" title=\"codepen\b：\"></a>codepen\b：</h3><iframe height=\"320\" scrolling=\"no\" title=\"JyNRxj\" src=\"//codepen.io/zhansingsong/embed/JyNRxj/?height=330&theme-id=dark&default-tab=css,result&embed-version=2\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\"https://codepen.io/zhansingsong/pen/JyNRxj/\" target=\"_blank\" rel=\"external\">JyNRxj</a> by zhansingsong (<a href=\"https://codepen.io/zhansingsong\" target=\"_blank\" rel=\"external\">@zhansingsong</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.<br></iframe>\n\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>给\b第一个<code>div</code>（即\b\b\b“\b红色块”的\b父节点）添加如下样式：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:first-child</span> &#123;</div><div class=\"line\">  <span class=\"attribute\">opacity</span>: .<span class=\"number\">99</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>或许你会\b好奇为什么这个<code>opacity</code>会让\b“红色块”置于“绿色块”之后（当时我看这个答案也是一脸懵逼了\b😑\b）。希望下文能解惑你的好奇。</p>\n<h3 id=\"z-index-specification\"><a href=\"#z-index-specification\" class=\"headerlink\" title=\"z-index specification\"></a>z-index <a href=\"https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index\" target=\"_blank\" rel=\"external\">specification</a></h3><p><strong>z-index</strong>只对<strong>positioned元素</strong>（即该元素的<code>position</code>不等于默认<code>static</code>外的值）起作用。对应<code>positoned box</code>（positioned元素)，<strong>z-index</strong>主要：</p>\n<ol>\n<li>指定该元素在当前<strong>stacking context</strong>的stack层级</li>\n<li>该元素是否创建新的<strong>stacking context</strong></li>\n</ol>\n<p><strong>z-index</strong>可以取如下值：</p>\n<ul>\n<li><p><strong>(integer)整数</strong>：表示当前元素在当前的<strong>stacking context</strong>的stack层级，并会让当前元素创建一个新的<strong>stacking context</strong></p>\n</li>\n<li><p><strong>auto</strong>: 表示当前元素在当前的<strong>stacking context</strong>的stack层级为0，如果该元素不是<strong>root</strong>元素，就不会创建新的<strong>stacking context</strong></p>\n</li>\n</ul>\n<h3 id=\"stacking-order\"><a href=\"#stacking-order\" class=\"headerlink\" title=\"stacking order\"></a>stacking order</h3><p><strong>stacking context</strong>可以相互嵌套，每个元素（box）都属于一个<strong>stacking context</strong>（自包含），每个<code>positoned box</code>在一个<strong>stacking context</strong>中都有一个整数的stack层级，它表示在同一个<strong>stacking context</strong>中的z轴方向stack层级位置。stack层级越大在<strong>stacking context</strong>中的位置越靠前。如果stack层级相同，按其在DOM文档中出现顺序绘制。</p>\n<h3 id=\"stacking-context\"><a href=\"#stacking-context\" class=\"headerlink\" title=\"stacking context\"></a>stacking context</h3><blockquote>\n<p><strong>The stacking context</strong> is a three-dimensional conceptualization of HTML elements along an imaginary z-axis relative to the user who is assumed to be facing the viewport or the webpage. HTML elements occupy this space in priority order based on element attributes.——MDN</p>\n</blockquote>\n<p><strong>stacking context</strong>的形成条件：</p>\n<ul>\n<li>文档根节点（HTML）| Root element of document (HTML).</li>\n<li>元素的position属性值为<code>absolute</code>或<code>relative</code>，并且z-index属性为除<code>auto</code>外的值 | Element with a position value “absolute” or “relative” and z-index value other than “auto”.</li>\n<li>元素的position属性值为<code>fixed</code>或<code>sticky</code> | Element with a position value “fixed” or “sticky” (sticky for all mobile browsers, but not older desktop).</li>\n<li>元素是flexbox容器的子元素，带有z-index属性，且值为除<code>auto</code>外的值 | Element that is a child of a flex (flexbox) container, with z-index value other than “auto”.</li>\n<li>元素的opcity属性值小于1 | Element with a opacity value less than 1 (See the specification for opacity).</li>\n<li>元素的<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode\" target=\"_blank\" rel=\"external\">mix-blend-mode</a>属性值为除<code>normal</code>外的值 | Element with a mix-blend-mode value other than “normal”.</li>\n<li>元素的如下属性值为除<code>none</code>外的值 | Element with any of the following properties with value other than “none”:<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/transform\" target=\"_blank\" rel=\"external\">transform</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/filter\" target=\"_blank\" rel=\"external\">filter</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\" target=\"_blank\" rel=\"external\">perspective</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path\" target=\"_blank\" rel=\"external\">clip-path</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mask\" target=\"_blank\" rel=\"external\">mask</a> / <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mask-image\" target=\"_blank\" rel=\"external\">mask-image</a> / <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/mask-border\" target=\"_blank\" rel=\"external\">mask-border</a></li>\n</ul>\n</li>\n<li>元素的isolation属性值为<code>isolate</code> | Element with a <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/isolation\" target=\"_blank\" rel=\"external\">isolation</a> value “isolate”.</li>\n<li>元素的-webkit-overflow-scrolling属性值为<code>touch</code> | Element with a -webkit-overflow-scrolling value “touch”.</li>\n<li>元素带有<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/will-change\" target=\"_blank\" rel=\"external\">will-change</a>属性 | Element with a will-change value specifying any property that would create a stacking context on non-initial value (see this post).</li>\n</ul>\n<h3 id=\"painted-order-in-stacking-context\"><a href=\"#painted-order-in-stacking-context\" class=\"headerlink\" title=\"painted order in stacking context\"></a>painted order in stacking context</h3><ol>\n<li>形成<strong>stacking context</strong>元素的<code>background</code>和<code>borders</code> | the background and borders of the element forming the stacking context.</li>\n<li>负数的stack层级的<strong>child stacking context</strong>(负数值越大越前) | the child stacking contexts with negative stack levels (most negative first).</li>\n<li>文档流中非inline级、非positioned子节点 | the in-flow, non-inline-level, non-positioned descendants.</li>\n<li>非positioned浮动子节点 | the non-positioned floats.</li>\n<li>文档流中非positioned的inline级子节点（包括inline tables和inline blocks） | the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.</li>\n<li>stack层级为0的<strong>child stacking context</strong>和positoned子节点 | the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.</li>\n<li>stack层级为正整数的<strong>child stacking context</strong> | the child stacking contexts with positive stack levels (least positive first).<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><iframe height=\"265\" scrolling=\"no\" title=\"stackLevel\" src=\"//codepen.io/zhansingsong/embed/WEMrNK/?height=265&theme-id=dark&default-tab=css,result&embed-version=2\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\">See the Pen <a href=\"https://codepen.io/zhansingsong/pen/WEMrNK/\" target=\"_blank\" rel=\"external\">stackLevel</a> by zhansingsong (<a href=\"https://codepen.io/zhansingsong\" target=\"_blank\" rel=\"external\">@zhansingsong</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.<br></iframe>\n\n\n</li>\n</ol>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"https://philipwalton.com/articles/what-no-one-told-you-about-z-index/\" target=\"_blank\" rel=\"external\">What No One Told You About Z-Index</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\" target=\"_blank\" rel=\"external\">The stacking context</a></li>\n<li><a href=\"https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index\" target=\"_blank\" rel=\"external\">Specifying the stack level: the ‘z-index’ property</a></li>\n</ul>\n<p><br></p>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n"},{"title":"✨ Init ✨","date":"2017-08-28T03:13:14.000Z","author":"Kun","_content":"\n\n博客由[Hexo](https://hexo.io/)搭建，hexo是一款基于Node.js的静态博客框架。\n\n配合[GitHub Pages](https://pages.github.com/)，将资源托管在托管在 GitHub 上。\n\n## 快速开始\n``` bash\nnpm install\n```\n\n### 创建一篇新文章\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nmore: [🐳](https://hexo.io/zh-cn/docs/writing.html)\n\n### 启动服务器 (:4000)\n\n``` bash\n$ hexo server\n```\n\nmore: [🐹](https://hexo.io/zh-cn/docs/server.html)\n\n### 生成静态资源\n\n``` bash\n$ hexo generate\n```\n\nmore: [😝](https://hexo.io/zh-cn/docs/generating.html)\n\n### 自动部署到Github\n\n``` bash\n$ sh push.sh\n```\n","source":"_posts/init.md","raw":"---\ntitle: ✨ Init ✨\ndate: 2017-08-28 11:13:14\nauthor: Kun\n---\n\n\n博客由[Hexo](https://hexo.io/)搭建，hexo是一款基于Node.js的静态博客框架。\n\n配合[GitHub Pages](https://pages.github.com/)，将资源托管在托管在 GitHub 上。\n\n## 快速开始\n``` bash\nnpm install\n```\n\n### 创建一篇新文章\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nmore: [🐳](https://hexo.io/zh-cn/docs/writing.html)\n\n### 启动服务器 (:4000)\n\n``` bash\n$ hexo server\n```\n\nmore: [🐹](https://hexo.io/zh-cn/docs/server.html)\n\n### 生成静态资源\n\n``` bash\n$ hexo generate\n```\n\nmore: [😝](https://hexo.io/zh-cn/docs/generating.html)\n\n### 自动部署到Github\n\n``` bash\n$ sh push.sh\n```\n","slug":"init","published":1,"updated":"2018-08-22T08:09:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vataa00061hn9l067wtjh","content":"<p>博客由<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>搭建，hexo是一款基于Node.js的静态博客框架。</p>\n<p>配合<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a>，将资源托管在托管在 GitHub 上。</p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<h3 id=\"创建一篇新文章\"><a href=\"#创建一篇新文章\" class=\"headerlink\" title=\"创建一篇新文章\"></a>创建一篇新文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>more: <a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">🐳</a></p>\n<h3 id=\"启动服务器-4000\"><a href=\"#启动服务器-4000\" class=\"headerlink\" title=\"启动服务器 (:4000)\"></a>启动服务器 (:4000)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>more: <a href=\"https://hexo.io/zh-cn/docs/server.html\" target=\"_blank\" rel=\"external\">🐹</a></p>\n<h3 id=\"生成静态资源\"><a href=\"#生成静态资源\" class=\"headerlink\" title=\"生成静态资源\"></a>生成静态资源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>more: <a href=\"https://hexo.io/zh-cn/docs/generating.html\" target=\"_blank\" rel=\"external\">😝</a></p>\n<h3 id=\"自动部署到Github\"><a href=\"#自动部署到Github\" class=\"headerlink\" title=\"自动部署到Github\"></a>自动部署到Github</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sh push.sh</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>博客由<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>搭建，hexo是一款基于Node.js的静态博客框架。</p>\n<p>配合<a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">GitHub Pages</a>，将资源托管在托管在 GitHub 上。</p>\n<h2 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install</div></pre></td></tr></table></figure>\n<h3 id=\"创建一篇新文章\"><a href=\"#创建一篇新文章\" class=\"headerlink\" title=\"创建一篇新文章\"></a>创建一篇新文章</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>more: <a href=\"https://hexo.io/zh-cn/docs/writing.html\" target=\"_blank\" rel=\"external\">🐳</a></p>\n<h3 id=\"启动服务器-4000\"><a href=\"#启动服务器-4000\" class=\"headerlink\" title=\"启动服务器 (:4000)\"></a>启动服务器 (:4000)</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>more: <a href=\"https://hexo.io/zh-cn/docs/server.html\" target=\"_blank\" rel=\"external\">🐹</a></p>\n<h3 id=\"生成静态资源\"><a href=\"#生成静态资源\" class=\"headerlink\" title=\"生成静态资源\"></a>生成静态资源</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>more: <a href=\"https://hexo.io/zh-cn/docs/generating.html\" target=\"_blank\" rel=\"external\">😝</a></p>\n<h3 id=\"自动部署到Github\"><a href=\"#自动部署到Github\" class=\"headerlink\" title=\"自动部署到Github\"></a>自动部署到Github</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sh push.sh</div></pre></td></tr></table></figure>\n"},{"title":"requestAnimationFrame","date":"2017-11-23T07:38:33.000Z","author":"singsong","_content":"\n![arf](./arf.png)\n\n## setTimeout\n\n**语法**：setTimeout(function,delay)\n\n**定义**：setTimeout()方法用于在delay毫秒数之后调用函数或计算表达式。\n\n<u>setTimeout()指定的时间间隔表示何时将定时器的代码添加到任务队列中，而不是何时执行代码。</u>\n\n\n## setInterval\n\n**语法**：setInterval(function,delay)\n\n**定义**：setInterval()方法可按照指定的delay周期（以毫秒计）来调用函数或计算表达式。　\n\n<u>使用setInerval()创建的定时器确保定时器代码规则地插入任务队列中。不过仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</u>这种重复定时器会存在如下问题：\n\n- 在某些间隔会被跳过\n- 多个定时器的代码执行之间的间隔可能会被预期的小\n\n可以通过如下链式setTimeout()调用模式来避免类似问题：\n\n```js\nsetTimeout(function() {\n  // do something. . . .\n  setTimeout(arguments.callee, interval);\n}, interval);\n```\n\n**不过setInterval()会不停地调用函数，直到窗口关闭或调用clearInterval()。当然如果链式setTimeout()调用模式没有终止逻辑，也会一直运行下去。因此再不需要重复定时器时，确保对定时器进行清除，避免占用系统资源。**\n\n## requestAnimationFrame\n\n>在JavaScript中创建动画的典型方式就是使用setInterval()方法来控制所有动画（或链式setTimeout()调用模式）。编写这种动画循环的关键是要知道延迟时间多长适合。一方面，循环间隔必须足够短，这样才能让不同的动画效果显得更平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。通常电脑显示器的刷新频率是60Hz，大概相当于每秒重绘60次，平均每次约等于17ms(1000ms/60)，以这个循环间隔重绘动画可到达最平滑效果。\n虽然与使用多组setTimeout()的循环方式相比，使用setInterval()的动画循环效率更高，但后者也不是没有问题的。无论是setInterval()还是setTimeout()都不十分精确。<u>传递给它们的第二个参数，实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间点。如果队列前面已经加入了其他的任务，那动画代码就要等待前面的任务完成后再执行。另外，要保证动画平滑的关键是要知道下一帧的绘制时间点，而开发人员没有办法确保浏览器按时绘制下一帧。加上浏览器使用的[计时器并非精确到毫秒级别](http://www.ituring.com.cn/article/1828)。</u>\n\n>CSS的transition和animation效果优于JavaScript实现的动画效果，原因在于CSS知道动画什么时候开始，会计算出正确的循环间隔，在适合的时候刷新UI。基于该问题，浏览器为了JavaScript动画添加了一个新API，即requestAnimationFrame()。\n\n\n\n**语法**：[requestAnimationFrame(callback)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame);\n\n**定义**：告诉浏览器希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。\n\n该方法使用一个回调函数callback作为参数，这个回调函数callback会在浏览器重绘之前调用。回调频率通常是每秒60次。回调函数callback会被传入一个参数[DOMHighResTimeStamp](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp)，指示从触发requestAnimationFrame回调到现在的时间。`requestAnimationFrame(callback)`会返回一个long整数，请求ID，也是回调列表中唯一的标识，一个非零值，可以传此值到 [ancelAnimationFrame(requestID)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame)以取消回调函数。\n\nrequestAnimationFrame基本思想是利用显示器的刷新机制，与刷新频率保持同步，并利用这个刷新频率进行页面重绘更新。不过需要注意：_因为JavaScript单线程工作机制，如果主线程一直处于繁忙状态，那么requestAnimationFrame的动画效果也会受影响的。_\n\n### 使用\n使用requestAnimationFrame的时候，只需反复调用它即可：\n\n```js\nfunction animation() {\n  // do something ....\n  requestAnimationFrame(animation);\n}\n\nrequestAnimationFrame(animation);\n```\n\n### 优势\n与setTimeout和setInterval相比，requestAnimationFrame有如下优势：\n\n- 在后台标签页、不活动标签页、最小化窗口中，requestAnimationFrame会自动暂停，节省系统资源为其他任务。\n- 在一个帧中对DOM的所有操作，只进行一次Layout和Paint更新。\n- 利用显示器的刷新机制，知道动画何时开始，能确定动画最佳循环间隔时间及代码何时执行，并在适合的时候刷新UI。\n\n\n不活动标签页中，setInterval与requestAnimationFrame的活动状态：\n\n|           | setInterval |            requestAnimationFrame            |\n|:---------:|:-----------:|:-------------------------------------------:|\n|    IE9-   |      no     |                 no supported                |\n|   IE10+   |      no     |                    paused                   |\n|  Chrome9- |      no     |                 no supported                |\n|  Chrome10 |      no     |                    paused                   |\n| Chrome10+ |   >=1000ms  |                    paused                   |\n| Firefox3- |      no     |                 no supported                |\n|  Firefox4 |      no     |                      1s                     |\n| Firefox5+ |   >=1000ms  | 2ns (n = number of frames since inactivity) |\n|  Safari5- |      no     |                 no supported                |\n|  Safari6  |      no     |                    paused                   |\n|  Safari7+ |   >=1000ms  |                    paused                   |\n|  Opera12- |      no     |                 no supported                |\n|  Opera15+ |   >=1000ms  |                    paused                   |\n\n注：\n- **-**: <= \n- **+**: >=\n- **no**: 没影响\n- **no supported**: 不支持\n- **paused**: 暂停\n- **>=1000ms**: 时间间隔大于等于1000ms，即如果时间间隔小于1000ms会被调整为1000ms，如果时间间隔大于等于1000ms会用指定时间间隔\n- **1s | 2ns**: 时间间隔（在Firefox不活动标签页中，requestAnimationFrame每帧消耗时间以2的次方依次递增：1s、2s、4s、8s.....）\n\n \n\n### [兼容性：](https://caniuse.com/#feat=requestanimationframe)\n\n<iframe height='540' title='caniuse-requestAnimationFrame' src='https://caniuse.com/#feat=requestanimationframe' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'></iframe>\n\n### [polyfill：](https://gist.github.com/paulirish/1579671)\n\n```js\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function() {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] \n                                   || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n \n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n \n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n```\n\n## 参考文章\n\n- [Animating with javascript: from setInterval to requestAnimationFrame](https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/)\n- [How do browsers behave when tab or window is not active?](http://satheeq.blogspot.com/2015/12/how-do-browsers-pausechange-javascript.html)\n- [Jank Busting for Better Rendering Performance](https://www.html5rocks.com/en/tutorials/speed/rendering/)","source":"_posts/requestAnimationFrame.md","raw":"---\ntitle: requestAnimationFrame\ndate: 2017-11-23 15:38:33\ntags: [requestAnimationFrame, 动画]\nauthor: singsong\n---\n\n![arf](./arf.png)\n\n## setTimeout\n\n**语法**：setTimeout(function,delay)\n\n**定义**：setTimeout()方法用于在delay毫秒数之后调用函数或计算表达式。\n\n<u>setTimeout()指定的时间间隔表示何时将定时器的代码添加到任务队列中，而不是何时执行代码。</u>\n\n\n## setInterval\n\n**语法**：setInterval(function,delay)\n\n**定义**：setInterval()方法可按照指定的delay周期（以毫秒计）来调用函数或计算表达式。　\n\n<u>使用setInerval()创建的定时器确保定时器代码规则地插入任务队列中。不过仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</u>这种重复定时器会存在如下问题：\n\n- 在某些间隔会被跳过\n- 多个定时器的代码执行之间的间隔可能会被预期的小\n\n可以通过如下链式setTimeout()调用模式来避免类似问题：\n\n```js\nsetTimeout(function() {\n  // do something. . . .\n  setTimeout(arguments.callee, interval);\n}, interval);\n```\n\n**不过setInterval()会不停地调用函数，直到窗口关闭或调用clearInterval()。当然如果链式setTimeout()调用模式没有终止逻辑，也会一直运行下去。因此再不需要重复定时器时，确保对定时器进行清除，避免占用系统资源。**\n\n## requestAnimationFrame\n\n>在JavaScript中创建动画的典型方式就是使用setInterval()方法来控制所有动画（或链式setTimeout()调用模式）。编写这种动画循环的关键是要知道延迟时间多长适合。一方面，循环间隔必须足够短，这样才能让不同的动画效果显得更平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。通常电脑显示器的刷新频率是60Hz，大概相当于每秒重绘60次，平均每次约等于17ms(1000ms/60)，以这个循环间隔重绘动画可到达最平滑效果。\n虽然与使用多组setTimeout()的循环方式相比，使用setInterval()的动画循环效率更高，但后者也不是没有问题的。无论是setInterval()还是setTimeout()都不十分精确。<u>传递给它们的第二个参数，实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间点。如果队列前面已经加入了其他的任务，那动画代码就要等待前面的任务完成后再执行。另外，要保证动画平滑的关键是要知道下一帧的绘制时间点，而开发人员没有办法确保浏览器按时绘制下一帧。加上浏览器使用的[计时器并非精确到毫秒级别](http://www.ituring.com.cn/article/1828)。</u>\n\n>CSS的transition和animation效果优于JavaScript实现的动画效果，原因在于CSS知道动画什么时候开始，会计算出正确的循环间隔，在适合的时候刷新UI。基于该问题，浏览器为了JavaScript动画添加了一个新API，即requestAnimationFrame()。\n\n\n\n**语法**：[requestAnimationFrame(callback)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame);\n\n**定义**：告诉浏览器希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。\n\n该方法使用一个回调函数callback作为参数，这个回调函数callback会在浏览器重绘之前调用。回调频率通常是每秒60次。回调函数callback会被传入一个参数[DOMHighResTimeStamp](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp)，指示从触发requestAnimationFrame回调到现在的时间。`requestAnimationFrame(callback)`会返回一个long整数，请求ID，也是回调列表中唯一的标识，一个非零值，可以传此值到 [ancelAnimationFrame(requestID)](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame)以取消回调函数。\n\nrequestAnimationFrame基本思想是利用显示器的刷新机制，与刷新频率保持同步，并利用这个刷新频率进行页面重绘更新。不过需要注意：_因为JavaScript单线程工作机制，如果主线程一直处于繁忙状态，那么requestAnimationFrame的动画效果也会受影响的。_\n\n### 使用\n使用requestAnimationFrame的时候，只需反复调用它即可：\n\n```js\nfunction animation() {\n  // do something ....\n  requestAnimationFrame(animation);\n}\n\nrequestAnimationFrame(animation);\n```\n\n### 优势\n与setTimeout和setInterval相比，requestAnimationFrame有如下优势：\n\n- 在后台标签页、不活动标签页、最小化窗口中，requestAnimationFrame会自动暂停，节省系统资源为其他任务。\n- 在一个帧中对DOM的所有操作，只进行一次Layout和Paint更新。\n- 利用显示器的刷新机制，知道动画何时开始，能确定动画最佳循环间隔时间及代码何时执行，并在适合的时候刷新UI。\n\n\n不活动标签页中，setInterval与requestAnimationFrame的活动状态：\n\n|           | setInterval |            requestAnimationFrame            |\n|:---------:|:-----------:|:-------------------------------------------:|\n|    IE9-   |      no     |                 no supported                |\n|   IE10+   |      no     |                    paused                   |\n|  Chrome9- |      no     |                 no supported                |\n|  Chrome10 |      no     |                    paused                   |\n| Chrome10+ |   >=1000ms  |                    paused                   |\n| Firefox3- |      no     |                 no supported                |\n|  Firefox4 |      no     |                      1s                     |\n| Firefox5+ |   >=1000ms  | 2ns (n = number of frames since inactivity) |\n|  Safari5- |      no     |                 no supported                |\n|  Safari6  |      no     |                    paused                   |\n|  Safari7+ |   >=1000ms  |                    paused                   |\n|  Opera12- |      no     |                 no supported                |\n|  Opera15+ |   >=1000ms  |                    paused                   |\n\n注：\n- **-**: <= \n- **+**: >=\n- **no**: 没影响\n- **no supported**: 不支持\n- **paused**: 暂停\n- **>=1000ms**: 时间间隔大于等于1000ms，即如果时间间隔小于1000ms会被调整为1000ms，如果时间间隔大于等于1000ms会用指定时间间隔\n- **1s | 2ns**: 时间间隔（在Firefox不活动标签页中，requestAnimationFrame每帧消耗时间以2的次方依次递增：1s、2s、4s、8s.....）\n\n \n\n### [兼容性：](https://caniuse.com/#feat=requestanimationframe)\n\n<iframe height='540' title='caniuse-requestAnimationFrame' src='https://caniuse.com/#feat=requestanimationframe' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'></iframe>\n\n### [polyfill：](https://gist.github.com/paulirish/1579671)\n\n```js\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\n\n// MIT license\n\n(function() {\n    var lastTime = 0;\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] \n                                   || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n \n    if (!window.requestAnimationFrame)\n        window.requestAnimationFrame = function(callback, element) {\n            var currTime = new Date().getTime();\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \n              timeToCall);\n            lastTime = currTime + timeToCall;\n            return id;\n        };\n \n    if (!window.cancelAnimationFrame)\n        window.cancelAnimationFrame = function(id) {\n            clearTimeout(id);\n        };\n}());\n```\n\n## 参考文章\n\n- [Animating with javascript: from setInterval to requestAnimationFrame](https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/)\n- [How do browsers behave when tab or window is not active?](http://satheeq.blogspot.com/2015/12/how-do-browsers-pausechange-javascript.html)\n- [Jank Busting for Better Rendering Performance](https://www.html5rocks.com/en/tutorials/speed/rendering/)","slug":"requestAnimationFrame","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vatae00081hn93k24rqhh","content":"<p><img src=\"./arf.png\" alt=\"arf\"></p>\n<h2 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h2><p><strong>语法</strong>：setTimeout(function,delay)</p>\n<p><strong>定义</strong>：setTimeout()方法用于在delay毫秒数之后调用函数或计算表达式。</p>\n<p><u>setTimeout()指定的时间间隔表示何时将定时器的代码添加到任务队列中，而不是何时执行代码。</u></p>\n<h2 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h2><p><strong>语法</strong>：setInterval(function,delay)</p>\n<p><strong>定义</strong>：setInterval()方法可按照指定的delay周期（以毫秒计）来调用函数或计算表达式。　</p>\n<p><u>使用setInerval()创建的定时器确保定时器代码规则地插入任务队列中。不过仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</u>这种重复定时器会存在如下问题：</p>\n<ul>\n<li>在某些间隔会被跳过</li>\n<li>多个定时器的代码执行之间的间隔可能会被预期的小</li>\n</ul>\n<p>可以通过如下链式setTimeout()调用模式来避免类似问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something. . . .</span></div><div class=\"line\">  setTimeout(<span class=\"built_in\">arguments</span>.callee, interval);</div><div class=\"line\">&#125;, interval);</div></pre></td></tr></table></figure>\n<p><strong>不过setInterval()会不停地调用函数，直到窗口关闭或调用clearInterval()。当然如果链式setTimeout()调用模式没有终止逻辑，也会一直运行下去。因此再不需要重复定时器时，确保对定时器进行清除，避免占用系统资源。</strong></p>\n<h2 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h2><blockquote>\n<p>在JavaScript中创建动画的典型方式就是使用setInterval()方法来控制所有动画（或链式setTimeout()调用模式）。编写这种动画循环的关键是要知道延迟时间多长适合。一方面，循环间隔必须足够短，这样才能让不同的动画效果显得更平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。通常电脑显示器的刷新频率是60Hz，大概相当于每秒重绘60次，平均每次约等于17ms(1000ms/60)，以这个循环间隔重绘动画可到达最平滑效果。<br>虽然与使用多组setTimeout()的循环方式相比，使用setInterval()的动画循环效率更高，但后者也不是没有问题的。无论是setInterval()还是setTimeout()都不十分精确。<u>传递给它们的第二个参数，实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间点。如果队列前面已经加入了其他的任务，那动画代码就要等待前面的任务完成后再执行。另外，要保证动画平滑的关键是要知道下一帧的绘制时间点，而开发人员没有办法确保浏览器按时绘制下一帧。加上浏览器使用的<a href=\"http://www.ituring.com.cn/article/1828\" target=\"_blank\" rel=\"external\">计时器并非精确到毫秒级别</a>。</u></p>\n</blockquote>\n<blockquote>\n<p>CSS的transition和animation效果优于JavaScript实现的动画效果，原因在于CSS知道动画什么时候开始，会计算出正确的循环间隔，在适合的时候刷新UI。基于该问题，浏览器为了JavaScript动画添加了一个新API，即requestAnimationFrame()。</p>\n</blockquote>\n<p><strong>语法</strong>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\" target=\"_blank\" rel=\"external\">requestAnimationFrame(callback)</a>;</p>\n<p><strong>定义</strong>：告诉浏览器希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。</p>\n<p>该方法使用一个回调函数callback作为参数，这个回调函数callback会在浏览器重绘之前调用。回调频率通常是每秒60次。回调函数callback会被传入一个参数<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp\" target=\"_blank\" rel=\"external\">DOMHighResTimeStamp</a>，指示从触发requestAnimationFrame回调到现在的时间。<code>requestAnimationFrame(callback)</code>会返回一个long整数，请求ID，也是回调列表中唯一的标识，一个非零值，可以传此值到 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame\" target=\"_blank\" rel=\"external\">ancelAnimationFrame(requestID)</a>以取消回调函数。</p>\n<p>requestAnimationFrame基本思想是利用显示器的刷新机制，与刷新频率保持同步，并利用这个刷新频率进行页面重绘更新。不过需要注意：<em>因为JavaScript单线程工作机制，如果主线程一直处于繁忙状态，那么requestAnimationFrame的动画效果也会受影响的。</em></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用requestAnimationFrame的时候，只需反复调用它即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animation</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something ....</span></div><div class=\"line\">  requestAnimationFrame(animation);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">requestAnimationFrame(animation);</div></pre></td></tr></table></figure>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>与setTimeout和setInterval相比，requestAnimationFrame有如下优势：</p>\n<ul>\n<li>在后台标签页、不活动标签页、最小化窗口中，requestAnimationFrame会自动暂停，节省系统资源为其他任务。</li>\n<li>在一个帧中对DOM的所有操作，只进行一次Layout和Paint更新。</li>\n<li>利用显示器的刷新机制，知道动画何时开始，能确定动画最佳循环间隔时间及代码何时执行，并在适合的时候刷新UI。</li>\n</ul>\n<p>不活动标签页中，setInterval与requestAnimationFrame的活动状态：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">setInterval</th>\n<th style=\"text-align:center\">requestAnimationFrame</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IE9-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IE10+</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Chrome9-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Chrome10</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Chrome10+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Firefox3-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Firefox4</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">1s</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Firefox5+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">2ns (n = number of frames since inactivity)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari5-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari6</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari7+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Opera12-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Opera15+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n</tbody>\n</table>\n<p>注：</p>\n<ul>\n<li><strong>-</strong>: &lt;= </li>\n<li><strong>+</strong>: &gt;=</li>\n<li><strong>no</strong>: 没影响</li>\n<li><strong>no supported</strong>: 不支持</li>\n<li><strong>paused</strong>: 暂停</li>\n<li><strong>&gt;=1000ms</strong>: 时间间隔大于等于1000ms，即如果时间间隔小于1000ms会被调整为1000ms，如果时间间隔大于等于1000ms会用指定时间间隔</li>\n<li><strong>1s | 2ns</strong>: 时间间隔（在Firefox不活动标签页中，requestAnimationFrame每帧消耗时间以2的次方依次递增：1s、2s、4s、8s…..）</li>\n</ul>\n<h3 id=\"兼容性：\"><a href=\"#兼容性：\" class=\"headerlink\" title=\"兼容性：\"></a><a href=\"https://caniuse.com/#feat=requestanimationframe\" target=\"_blank\" rel=\"external\">兼容性：</a></h3><iframe height=\"540\" title=\"caniuse-requestAnimationFrame\" src=\"https://caniuse.com/#feat=requestanimationframe\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\"></iframe>\n\n<h3 id=\"polyfill：\"><a href=\"#polyfill：\" class=\"headerlink\" title=\"polyfill：\"></a><a href=\"https://gist.github.com/paulirish/1579671\" target=\"_blank\" rel=\"external\">polyfill：</a></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// http://paulirish.com/2011/requestanimationframe-for-smart-animating/</span></div><div class=\"line\"><span class=\"comment\">// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// MIT license</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastTime = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> vendors = [<span class=\"string\">'ms'</span>, <span class=\"string\">'moz'</span>, <span class=\"string\">'webkit'</span>, <span class=\"string\">'o'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; vendors.length &amp;&amp; !<span class=\"built_in\">window</span>.requestAnimationFrame; ++x) &#123;</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'RequestAnimationFrame'</span>];</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame = <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelAnimationFrame'</span>] </div><div class=\"line\">                                   || <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelRequestAnimationFrame'</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.requestAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, element</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> currTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</div><div class=\"line\">            <span class=\"keyword\">var</span> timeToCall = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>, <span class=\"number\">16</span> - (currTime - lastTime));</div><div class=\"line\">            <span class=\"keyword\">var</span> id = <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; callback(currTime + timeToCall); &#125;, </div><div class=\"line\">              timeToCall);</div><div class=\"line\">            lastTime = currTime + timeToCall;</div><div class=\"line\">            <span class=\"keyword\">return</span> id;</div><div class=\"line\">        &#125;;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.cancelAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">            clearTimeout(id);</div><div class=\"line\">        &#125;;</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/\" target=\"_blank\" rel=\"external\">Animating with javascript: from setInterval to requestAnimationFrame</a></li>\n<li><a href=\"http://satheeq.blogspot.com/2015/12/how-do-browsers-pausechange-javascript.html\" target=\"_blank\" rel=\"external\">How do browsers behave when tab or window is not active?</a></li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/speed/rendering/\" target=\"_blank\" rel=\"external\">Jank Busting for Better Rendering Performance</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"./arf.png\" alt=\"arf\"></p>\n<h2 id=\"setTimeout\"><a href=\"#setTimeout\" class=\"headerlink\" title=\"setTimeout\"></a>setTimeout</h2><p><strong>语法</strong>：setTimeout(function,delay)</p>\n<p><strong>定义</strong>：setTimeout()方法用于在delay毫秒数之后调用函数或计算表达式。</p>\n<p><u>setTimeout()指定的时间间隔表示何时将定时器的代码添加到任务队列中，而不是何时执行代码。</u></p>\n<h2 id=\"setInterval\"><a href=\"#setInterval\" class=\"headerlink\" title=\"setInterval\"></a>setInterval</h2><p><strong>语法</strong>：setInterval(function,delay)</p>\n<p><strong>定义</strong>：setInterval()方法可按照指定的delay周期（以毫秒计）来调用函数或计算表达式。　</p>\n<p><u>使用setInerval()创建的定时器确保定时器代码规则地插入任务队列中。不过仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。</u>这种重复定时器会存在如下问题：</p>\n<ul>\n<li>在某些间隔会被跳过</li>\n<li>多个定时器的代码执行之间的间隔可能会被预期的小</li>\n</ul>\n<p>可以通过如下链式setTimeout()调用模式来避免类似问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something. . . .</span></div><div class=\"line\">  setTimeout(<span class=\"built_in\">arguments</span>.callee, interval);</div><div class=\"line\">&#125;, interval);</div></pre></td></tr></table></figure>\n<p><strong>不过setInterval()会不停地调用函数，直到窗口关闭或调用clearInterval()。当然如果链式setTimeout()调用模式没有终止逻辑，也会一直运行下去。因此再不需要重复定时器时，确保对定时器进行清除，避免占用系统资源。</strong></p>\n<h2 id=\"requestAnimationFrame\"><a href=\"#requestAnimationFrame\" class=\"headerlink\" title=\"requestAnimationFrame\"></a>requestAnimationFrame</h2><blockquote>\n<p>在JavaScript中创建动画的典型方式就是使用setInterval()方法来控制所有动画（或链式setTimeout()调用模式）。编写这种动画循环的关键是要知道延迟时间多长适合。一方面，循环间隔必须足够短，这样才能让不同的动画效果显得更平滑流畅；另一方面，循环间隔还要足够长，这样才能确保浏览器有能力渲染产生的变化。通常电脑显示器的刷新频率是60Hz，大概相当于每秒重绘60次，平均每次约等于17ms(1000ms/60)，以这个循环间隔重绘动画可到达最平滑效果。<br>虽然与使用多组setTimeout()的循环方式相比，使用setInterval()的动画循环效率更高，但后者也不是没有问题的。无论是setInterval()还是setTimeout()都不十分精确。<u>传递给它们的第二个参数，实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间点。如果队列前面已经加入了其他的任务，那动画代码就要等待前面的任务完成后再执行。另外，要保证动画平滑的关键是要知道下一帧的绘制时间点，而开发人员没有办法确保浏览器按时绘制下一帧。加上浏览器使用的<a href=\"http://www.ituring.com.cn/article/1828\" target=\"_blank\" rel=\"external\">计时器并非精确到毫秒级别</a>。</u></p>\n</blockquote>\n<blockquote>\n<p>CSS的transition和animation效果优于JavaScript实现的动画效果，原因在于CSS知道动画什么时候开始，会计算出正确的循环间隔，在适合的时候刷新UI。基于该问题，浏览器为了JavaScript动画添加了一个新API，即requestAnimationFrame()。</p>\n</blockquote>\n<p><strong>语法</strong>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\" target=\"_blank\" rel=\"external\">requestAnimationFrame(callback)</a>;</p>\n<p><strong>定义</strong>：告诉浏览器希望执行动画，并请求浏览器调用指定的函数在下一次重绘之前更新动画。</p>\n<p>该方法使用一个回调函数callback作为参数，这个回调函数callback会在浏览器重绘之前调用。回调频率通常是每秒60次。回调函数callback会被传入一个参数<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp\" target=\"_blank\" rel=\"external\">DOMHighResTimeStamp</a>，指示从触发requestAnimationFrame回调到现在的时间。<code>requestAnimationFrame(callback)</code>会返回一个long整数，请求ID，也是回调列表中唯一的标识，一个非零值，可以传此值到 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame\" target=\"_blank\" rel=\"external\">ancelAnimationFrame(requestID)</a>以取消回调函数。</p>\n<p>requestAnimationFrame基本思想是利用显示器的刷新机制，与刷新频率保持同步，并利用这个刷新频率进行页面重绘更新。不过需要注意：<em>因为JavaScript单线程工作机制，如果主线程一直处于繁忙状态，那么requestAnimationFrame的动画效果也会受影响的。</em></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>使用requestAnimationFrame的时候，只需反复调用它即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animation</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// do something ....</span></div><div class=\"line\">  requestAnimationFrame(animation);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">requestAnimationFrame(animation);</div></pre></td></tr></table></figure>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>与setTimeout和setInterval相比，requestAnimationFrame有如下优势：</p>\n<ul>\n<li>在后台标签页、不活动标签页、最小化窗口中，requestAnimationFrame会自动暂停，节省系统资源为其他任务。</li>\n<li>在一个帧中对DOM的所有操作，只进行一次Layout和Paint更新。</li>\n<li>利用显示器的刷新机制，知道动画何时开始，能确定动画最佳循环间隔时间及代码何时执行，并在适合的时候刷新UI。</li>\n</ul>\n<p>不活动标签页中，setInterval与requestAnimationFrame的活动状态：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:center\">setInterval</th>\n<th style=\"text-align:center\">requestAnimationFrame</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IE9-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IE10+</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Chrome9-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Chrome10</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Chrome10+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Firefox3-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Firefox4</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">1s</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Firefox5+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">2ns (n = number of frames since inactivity)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari5-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari6</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Safari7+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Opera12-</td>\n<td style=\"text-align:center\">no</td>\n<td style=\"text-align:center\">no supported</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Opera15+</td>\n<td style=\"text-align:center\">&gt;=1000ms</td>\n<td style=\"text-align:center\">paused</td>\n</tr>\n</tbody>\n</table>\n<p>注：</p>\n<ul>\n<li><strong>-</strong>: &lt;= </li>\n<li><strong>+</strong>: &gt;=</li>\n<li><strong>no</strong>: 没影响</li>\n<li><strong>no supported</strong>: 不支持</li>\n<li><strong>paused</strong>: 暂停</li>\n<li><strong>&gt;=1000ms</strong>: 时间间隔大于等于1000ms，即如果时间间隔小于1000ms会被调整为1000ms，如果时间间隔大于等于1000ms会用指定时间间隔</li>\n<li><strong>1s | 2ns</strong>: 时间间隔（在Firefox不活动标签页中，requestAnimationFrame每帧消耗时间以2的次方依次递增：1s、2s、4s、8s…..）</li>\n</ul>\n<h3 id=\"兼容性：\"><a href=\"#兼容性：\" class=\"headerlink\" title=\"兼容性：\"></a><a href=\"https://caniuse.com/#feat=requestanimationframe\" target=\"_blank\" rel=\"external\">兼容性：</a></h3><iframe height=\"540\" title=\"caniuse-requestAnimationFrame\" src=\"https://caniuse.com/#feat=requestanimationframe\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\" style=\"width: 100%;\"></iframe>\n\n<h3 id=\"polyfill：\"><a href=\"#polyfill：\" class=\"headerlink\" title=\"polyfill：\"></a><a href=\"https://gist.github.com/paulirish/1579671\" target=\"_blank\" rel=\"external\">polyfill：</a></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// http://paulirish.com/2011/requestanimationframe-for-smart-animating/</span></div><div class=\"line\"><span class=\"comment\">// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// MIT license</span></div><div class=\"line\"></div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastTime = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> vendors = [<span class=\"string\">'ms'</span>, <span class=\"string\">'moz'</span>, <span class=\"string\">'webkit'</span>, <span class=\"string\">'o'</span>];</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> x = <span class=\"number\">0</span>; x &lt; vendors.length &amp;&amp; !<span class=\"built_in\">window</span>.requestAnimationFrame; ++x) &#123;</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'RequestAnimationFrame'</span>];</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame = <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelAnimationFrame'</span>] </div><div class=\"line\">                                   || <span class=\"built_in\">window</span>[vendors[x]+<span class=\"string\">'CancelRequestAnimationFrame'</span>];</div><div class=\"line\">    &#125;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.requestAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.requestAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, element</span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> currTime = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</div><div class=\"line\">            <span class=\"keyword\">var</span> timeToCall = <span class=\"built_in\">Math</span>.max(<span class=\"number\">0</span>, <span class=\"number\">16</span> - (currTime - lastTime));</div><div class=\"line\">            <span class=\"keyword\">var</span> id = <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; callback(currTime + timeToCall); &#125;, </div><div class=\"line\">              timeToCall);</div><div class=\"line\">            lastTime = currTime + timeToCall;</div><div class=\"line\">            <span class=\"keyword\">return</span> id;</div><div class=\"line\">        &#125;;</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">window</span>.cancelAnimationFrame)</div><div class=\"line\">        <span class=\"built_in\">window</span>.cancelAnimationFrame = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id</span>) </span>&#123;</div><div class=\"line\">            clearTimeout(id);</div><div class=\"line\">        &#125;;</div><div class=\"line\">&#125;());</div></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/\" target=\"_blank\" rel=\"external\">Animating with javascript: from setInterval to requestAnimationFrame</a></li>\n<li><a href=\"http://satheeq.blogspot.com/2015/12/how-do-browsers-pausechange-javascript.html\" target=\"_blank\" rel=\"external\">How do browsers behave when tab or window is not active?</a></li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/speed/rendering/\" target=\"_blank\" rel=\"external\">Jank Busting for Better Rendering Performance</a></li>\n</ul>\n"},{"title":"关于external-style-sheets你不知道的事","date":"2017-09-19T11:02:53.000Z","author":"singsong","_content":"\n在讲解之前，先看一个问题。如下图所示，外部样式表是否阻塞HTML解析（先不要看答案，可以自己思考和实验一下）：\n\n![default](./style-sheet-default.png)\n***\n\n通过**DevTool->network**:\n\n![default](./default-network.png)\n如上图所示，**indexcss.css**并没有阻塞HTML解析，因为DOMContentLoaded时间线在**indexcss.css**之后。但如果在\n**indexcss.css**之后添加**script标签（不能为空）**，结果会一样？\n\n![script](./script.png)\n通过**DevTool->network**:\n\n![script](./script-network.png)\n\n如上图所示，在**indexcss.css**之后添加**script标签**(不能为空)后，此时DOMContentLoaded时间线位于**indexcss.css**之后。说明这里**indexcss.css**是阻塞HTML解析的。\n\n#### 参考相关资料，找到如下描述：\n>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don't change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. WebKit blocks scripts only when they try to access certain style properties that may be affected by unloaded style sheets.----[Tali Garsiel](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets) \n\n大概意思是：<u>style-sheets不会修改DOM树，没有理由为了解析style-sheets而阻塞文档解析（即style-sheets不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox会阻塞所有脚本直到style-sheets下载解析完为止。而WebKit只在脚本访问的样式属性没有被加载解析时，才会阻塞脚本</u>。\n\n![relationship](./style-sheet.png)\n\n也即style-sheet不会直接阻塞文档解析，它只阻塞script的解析执行，才导致style-sheet间接阻塞文档解析。如果将script设置为非阻塞式的呢？可以通过为script标签设置**aysnc**特性来实现。为啥不用**defer**?\n\n>Both async and defer scripts begin to download immediately without pausing the parser and both support an optional onload handler to address the common need to perform initialization which depends on the script. The difference between async and defer centers around when the script is executed. Each async script executes at the first opportunity after it is finished downloading and before the window’s load event. This means it’s possible (and likely) that async scripts are not executed in the order in which they occur in the page. **The defer scripts, on the other hand, are guaranteed to be executed in the order they occur in the page. That execution starts after parsing is completely finished, but before the document’s DOMContentLoaded event.**\n\n大概意思：<u>**async**和**defer**特性在脚本开始下载时，都不会阻塞文档解析。并且都支持onload事件回调处理，用于一些初始化工作。另外，对内联脚本都无效，脚本中不能调用`document.write()`。不同之处：带有**async**特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有**defer**特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。</u>\n\n因此，这里设置**async**特性，而不设置**defer**特性。为了尽早地触发DOMContentLoaded事件，因为**defer**会延迟DOMContentLoaded事件触发。\n\n为script标签添加**async**特性:\n\n![async](./async.png)\n\n通过**DevTool->network**:\n\n![async](./async-network1.png)\n\n***\n当然，这里可以通过[媒体查询media](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)让style-sheet异步加载：\n![media](./media.png)\n\n通过**DevTool->network**:\n\n![media](./media-network.png)\n\n### 总结：\n\n- style-sheet默认情况下是不会阻塞文档解析的。\n- style-sheet只会阻塞script脚本解析执行。因为需要script脚本需要访问style-sheet样式信息，为了确保样式信息的正确性，script脚本需要等待style-sheet下载解析完。从而导致style-sheet间接阻塞文档解析。\n- style-sheet可以通过**媒体查询media**来实现异步加载。\n- 为script设置**aysnc**特性来实现异步加载，来加快文档解析。\n\n\n\n\n\n### 参考文章：\n- [分析关键渲染路径性能](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp)\n- [Deciphering the Critical Rendering Path](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)\n- [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets)\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---\n","source":"_posts/关于external-style-sheets你不知道的事.md","raw":"---\ntitle: 关于external-style-sheets你不知道的事\ndate: 2017-09-19 19:02:53\ntags: [style-sheet, 优化]\nauthor: singsong\n---\n\n在讲解之前，先看一个问题。如下图所示，外部样式表是否阻塞HTML解析（先不要看答案，可以自己思考和实验一下）：\n\n![default](./style-sheet-default.png)\n***\n\n通过**DevTool->network**:\n\n![default](./default-network.png)\n如上图所示，**indexcss.css**并没有阻塞HTML解析，因为DOMContentLoaded时间线在**indexcss.css**之后。但如果在\n**indexcss.css**之后添加**script标签（不能为空）**，结果会一样？\n\n![script](./script.png)\n通过**DevTool->network**:\n\n![script](./script-network.png)\n\n如上图所示，在**indexcss.css**之后添加**script标签**(不能为空)后，此时DOMContentLoaded时间线位于**indexcss.css**之后。说明这里**indexcss.css**是阻塞HTML解析的。\n\n#### 参考相关资料，找到如下描述：\n>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don't change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. WebKit blocks scripts only when they try to access certain style properties that may be affected by unloaded style sheets.----[Tali Garsiel](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets) \n\n大概意思是：<u>style-sheets不会修改DOM树，没有理由为了解析style-sheets而阻塞文档解析（即style-sheets不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox会阻塞所有脚本直到style-sheets下载解析完为止。而WebKit只在脚本访问的样式属性没有被加载解析时，才会阻塞脚本</u>。\n\n![relationship](./style-sheet.png)\n\n也即style-sheet不会直接阻塞文档解析，它只阻塞script的解析执行，才导致style-sheet间接阻塞文档解析。如果将script设置为非阻塞式的呢？可以通过为script标签设置**aysnc**特性来实现。为啥不用**defer**?\n\n>Both async and defer scripts begin to download immediately without pausing the parser and both support an optional onload handler to address the common need to perform initialization which depends on the script. The difference between async and defer centers around when the script is executed. Each async script executes at the first opportunity after it is finished downloading and before the window’s load event. This means it’s possible (and likely) that async scripts are not executed in the order in which they occur in the page. **The defer scripts, on the other hand, are guaranteed to be executed in the order they occur in the page. That execution starts after parsing is completely finished, but before the document’s DOMContentLoaded event.**\n\n大概意思：<u>**async**和**defer**特性在脚本开始下载时，都不会阻塞文档解析。并且都支持onload事件回调处理，用于一些初始化工作。另外，对内联脚本都无效，脚本中不能调用`document.write()`。不同之处：带有**async**特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有**defer**特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。</u>\n\n因此，这里设置**async**特性，而不设置**defer**特性。为了尽早地触发DOMContentLoaded事件，因为**defer**会延迟DOMContentLoaded事件触发。\n\n为script标签添加**async**特性:\n\n![async](./async.png)\n\n通过**DevTool->network**:\n\n![async](./async-network1.png)\n\n***\n当然，这里可以通过[媒体查询media](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)让style-sheet异步加载：\n![media](./media.png)\n\n通过**DevTool->network**:\n\n![media](./media-network.png)\n\n### 总结：\n\n- style-sheet默认情况下是不会阻塞文档解析的。\n- style-sheet只会阻塞script脚本解析执行。因为需要script脚本需要访问style-sheet样式信息，为了确保样式信息的正确性，script脚本需要等待style-sheet下载解析完。从而导致style-sheet间接阻塞文档解析。\n- style-sheet可以通过**媒体查询media**来实现异步加载。\n- 为script设置**aysnc**特性来实现异步加载，来加快文档解析。\n\n\n\n\n\n### 参考文章：\n- [分析关键渲染路径性能](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp)\n- [Deciphering the Critical Rendering Path](https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/)\n- [How Browsers Work: Behind the scenes of modern web browsers](https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets)\n\n---\n\n> 声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。\n\n---\n","slug":"关于external-style-sheets你不知道的事","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vatah00091hn9zz0oy1h3","content":"<p>在讲解之前，先看一个问题。如下图所示，外部样式表是否阻塞HTML解析（先不要看答案，可以自己思考和实验一下）：</p>\n<p><img src=\"./style-sheet-default.png\" alt=\"default\"></p>\n<hr>\n<p>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./default-network.png\" alt=\"default\"><br>如上图所示，<strong>indexcss.css</strong>并没有阻塞HTML解析，因为DOMContentLoaded时间线在<strong>indexcss.css</strong>之后。但如果在<br><strong>indexcss.css</strong>之后添加<strong>script标签（不能为空）</strong>，结果会一样？</p>\n<p><img src=\"./script.png\" alt=\"script\"><br>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./script-network.png\" alt=\"script\"></p>\n<p>如上图所示，在<strong>indexcss.css</strong>之后添加<strong>script标签</strong>(不能为空)后，此时DOMContentLoaded时间线位于<strong>indexcss.css</strong>之后。说明这里<strong>indexcss.css</strong>是阻塞HTML解析的。</p>\n<h4 id=\"参考相关资料，找到如下描述：\"><a href=\"#参考相关资料，找到如下描述：\" class=\"headerlink\" title=\"参考相关资料，找到如下描述：\"></a>参考相关资料，找到如下描述：</h4><blockquote>\n<p>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don’t change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. WebKit blocks scripts only when they try to access certain style properties that may be affected by unloaded style sheets.—-<a href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets\" target=\"_blank\" rel=\"external\">Tali Garsiel</a> </p>\n</blockquote>\n<p>大概意思是：<u>style-sheets不会修改DOM树，没有理由为了解析style-sheets而阻塞文档解析（即style-sheets不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox会阻塞所有脚本直到style-sheets下载解析完为止。而WebKit只在脚本访问的样式属性没有被加载解析时，才会阻塞脚本</u>。</p>\n<p><img src=\"./style-sheet.png\" alt=\"relationship\"></p>\n<p>也即style-sheet不会直接阻塞文档解析，它只阻塞script的解析执行，才导致style-sheet间接阻塞文档解析。如果将script设置为非阻塞式的呢？可以通过为script标签设置<strong>aysnc</strong>特性来实现。为啥不用<strong>defer</strong>?</p>\n<blockquote>\n<p>Both async and defer scripts begin to download immediately without pausing the parser and both support an optional onload handler to address the common need to perform initialization which depends on the script. The difference between async and defer centers around when the script is executed. Each async script executes at the first opportunity after it is finished downloading and before the window’s load event. This means it’s possible (and likely) that async scripts are not executed in the order in which they occur in the page. <strong>The defer scripts, on the other hand, are guaranteed to be executed in the order they occur in the page. That execution starts after parsing is completely finished, but before the document’s DOMContentLoaded event.</strong></p>\n</blockquote>\n<p>大概意思：<u><strong>async</strong>和<strong>defer</strong>特性在脚本开始下载时，都不会阻塞文档解析。并且都支持onload事件回调处理，用于一些初始化工作。另外，对内联脚本都无效，脚本中不能调用<code>document.write()</code>。不同之处：带有<strong>async</strong>特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有<strong>defer</strong>特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。</u></p>\n<p>因此，这里设置<strong>async</strong>特性，而不设置<strong>defer</strong>特性。为了尽早地触发DOMContentLoaded事件，因为<strong>defer</strong>会延迟DOMContentLoaded事件触发。</p>\n<p>为script标签添加<strong>async</strong>特性:</p>\n<p><img src=\"./async.png\" alt=\"async\"></p>\n<p>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./async-network1.png\" alt=\"async\"></p>\n<hr>\n<p>当然，这里可以通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\" target=\"_blank\" rel=\"external\">媒体查询media</a>让style-sheet异步加载：<br><img src=\"./media.png\" alt=\"media\"></p>\n<p>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./media-network.png\" alt=\"media\"></p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><ul>\n<li>style-sheet默认情况下是不会阻塞文档解析的。</li>\n<li>style-sheet只会阻塞script脚本解析执行。因为需要script脚本需要访问style-sheet样式信息，为了确保样式信息的正确性，script脚本需要等待style-sheet下载解析完。从而导致style-sheet间接阻塞文档解析。</li>\n<li>style-sheet可以通过<strong>媒体查询media</strong>来实现异步加载。</li>\n<li>为script设置<strong>aysnc</strong>特性来实现异步加载，来加快文档解析。</li>\n</ul>\n<h3 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h3><ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp\" target=\"_blank\" rel=\"external\">分析关键渲染路径性能</a></li>\n<li><a href=\"https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/\" target=\"_blank\" rel=\"external\">Deciphering the Critical Rendering Path</a></li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets\" target=\"_blank\" rel=\"external\">How Browsers Work: Behind the scenes of modern web browsers</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p>在讲解之前，先看一个问题。如下图所示，外部样式表是否阻塞HTML解析（先不要看答案，可以自己思考和实验一下）：</p>\n<p><img src=\"./style-sheet-default.png\" alt=\"default\"></p>\n<hr>\n<p>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./default-network.png\" alt=\"default\"><br>如上图所示，<strong>indexcss.css</strong>并没有阻塞HTML解析，因为DOMContentLoaded时间线在<strong>indexcss.css</strong>之后。但如果在<br><strong>indexcss.css</strong>之后添加<strong>script标签（不能为空）</strong>，结果会一样？</p>\n<p><img src=\"./script.png\" alt=\"script\"><br>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./script-network.png\" alt=\"script\"></p>\n<p>如上图所示，在<strong>indexcss.css</strong>之后添加<strong>script标签</strong>(不能为空)后，此时DOMContentLoaded时间线位于<strong>indexcss.css</strong>之后。说明这里<strong>indexcss.css</strong>是阻塞HTML解析的。</p>\n<h4 id=\"参考相关资料，找到如下描述：\"><a href=\"#参考相关资料，找到如下描述：\" class=\"headerlink\" title=\"参考相关资料，找到如下描述：\"></a>参考相关资料，找到如下描述：</h4><blockquote>\n<p>Style sheets on the other hand have a different model. Conceptually it seems that since style sheets don’t change the DOM tree, there is no reason to wait for them and stop the document parsing. There is an issue, though, of scripts asking for style information during the document parsing stage. If the style is not loaded and parsed yet, the script will get wrong answers and apparently this caused lots of problems. It seems to be an edge case but is quite common. Firefox blocks all scripts when there is a style sheet that is still being loaded and parsed. WebKit blocks scripts only when they try to access certain style properties that may be affected by unloaded style sheets.—-<a href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets\" target=\"_blank\" rel=\"external\">Tali Garsiel</a> </p>\n</blockquote>\n<p>大概意思是：<u>style-sheets不会修改DOM树，没有理由为了解析style-sheets而阻塞文档解析（即style-sheets不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox会阻塞所有脚本直到style-sheets下载解析完为止。而WebKit只在脚本访问的样式属性没有被加载解析时，才会阻塞脚本</u>。</p>\n<p><img src=\"./style-sheet.png\" alt=\"relationship\"></p>\n<p>也即style-sheet不会直接阻塞文档解析，它只阻塞script的解析执行，才导致style-sheet间接阻塞文档解析。如果将script设置为非阻塞式的呢？可以通过为script标签设置<strong>aysnc</strong>特性来实现。为啥不用<strong>defer</strong>?</p>\n<blockquote>\n<p>Both async and defer scripts begin to download immediately without pausing the parser and both support an optional onload handler to address the common need to perform initialization which depends on the script. The difference between async and defer centers around when the script is executed. Each async script executes at the first opportunity after it is finished downloading and before the window’s load event. This means it’s possible (and likely) that async scripts are not executed in the order in which they occur in the page. <strong>The defer scripts, on the other hand, are guaranteed to be executed in the order they occur in the page. That execution starts after parsing is completely finished, but before the document’s DOMContentLoaded event.</strong></p>\n</blockquote>\n<p>大概意思：<u><strong>async</strong>和<strong>defer</strong>特性在脚本开始下载时，都不会阻塞文档解析。并且都支持onload事件回调处理，用于一些初始化工作。另外，对内联脚本都无效，脚本中不能调用<code>document.write()</code>。不同之处：带有<strong>async</strong>特性的脚本会在脚本下载完后立即执行，且在load事件之前，所以不能确保脚本在文档中出现的顺序来执行。而带有<strong>defer</strong>特性的脚本会在文档解析完后按照在文档出现的顺序依次执行，且在DOMContentLoaded事件之前。</u></p>\n<p>因此，这里设置<strong>async</strong>特性，而不设置<strong>defer</strong>特性。为了尽早地触发DOMContentLoaded事件，因为<strong>defer</strong>会延迟DOMContentLoaded事件触发。</p>\n<p>为script标签添加<strong>async</strong>特性:</p>\n<p><img src=\"./async.png\" alt=\"async\"></p>\n<p>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./async-network1.png\" alt=\"async\"></p>\n<hr>\n<p>当然，这里可以通过<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries\" target=\"_blank\" rel=\"external\">媒体查询media</a>让style-sheet异步加载：<br><img src=\"./media.png\" alt=\"media\"></p>\n<p>通过<strong>DevTool-&gt;network</strong>:</p>\n<p><img src=\"./media-network.png\" alt=\"media\"></p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><ul>\n<li>style-sheet默认情况下是不会阻塞文档解析的。</li>\n<li>style-sheet只会阻塞script脚本解析执行。因为需要script脚本需要访问style-sheet样式信息，为了确保样式信息的正确性，script脚本需要等待style-sheet下载解析完。从而导致style-sheet间接阻塞文档解析。</li>\n<li>style-sheet可以通过<strong>媒体查询media</strong>来实现异步加载。</li>\n<li>为script设置<strong>aysnc</strong>特性来实现异步加载，来加快文档解析。</li>\n</ul>\n<h3 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h3><ul>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp\" target=\"_blank\" rel=\"external\">分析关键渲染路径性能</a></li>\n<li><a href=\"https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/\" target=\"_blank\" rel=\"external\">Deciphering the Critical Rendering Path</a></li>\n<li><a href=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets\" target=\"_blank\" rel=\"external\">How Browsers Work: Behind the scenes of modern web browsers</a></li>\n</ul>\n<hr>\n<blockquote>\n<p>声明:本资料仅供学习交流，严禁使用于任何商业用途! 如需转载，转载请注明出处。</p>\n</blockquote>\n<hr>\n"},{"title":"关于闭包也许你不知道的事","date":"2017-11-23T13:48:36.000Z","author":"singsong","_content":"\n![closure](./closure.png)\n\n当一个函数A返回一个内联函数B，即使函数A执行完，函数B也能访问函数A作用域内的变量。这就是一个闭包——————本质上闭包是将函数内部和外部连接起来的一座桥梁。\n\n```js\nfunction foo(message) {\n    function closure() {\n        console.log(message)\n    };\n    return closure;\n}\n\n// 使用\nvar bar = foo(\"hello closure!\");\nbar()// 返回 'hello closure!'\n```\n在函数foo内创建的函数closure对象是不能被回收掉的，因为它被全局变量bar引用，处于一直可访问状态。通过执行`bar()`可以打印出`hello closure!`。如果想释放掉可以将`bar = null`即可。\n\n<u>**由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。**</u>\n\n### 实例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Closure</title>\n</head>\n\n<body>\n  <p>不断单击【click】按钮</p>\n  <button id=\"click_button\">Click</button>\n  <script>\n    function f() {\n      var str = Array(10000).join('#');\n      var foo = {\n        name: 'foo'\n      }\n      function unused() {\n        var message = 'it is only a test message';\n        str = 'unused: ' + str;\n      }\n      function getData() {\n        return 'data';\n      }\n      return getData;\n    }\n\n    var list = [];\n    \n    document.querySelector('#click_button').addEventListener('click', function () {\n      list.push(f());\n    }, false);\n  </script>\n</body>\n\n</html>\n```\n这里结合Chrome的Devtools->Memory工具进行分析，操作步骤如下：\n\n<u>**注：最好在隐身窗口中进行分析工作，避免浏览器插件影响分析结果**</u>\n\n1. 选中【Record allocation timeline】选项\n2. 执行一次CG\n3. 单击【start】按钮开始记录堆分析\n3. 连续单击【click】按钮十多次\n4. 停止记录堆分析\n\n![closure](./closure1.png)\n\n上图中蓝色柱形条表示随着时间新分配的内存。选中其中某条蓝色柱形条，过滤出对应新分配的对象：\n\n![closure](./closure2.png)\n\n查看对象的详细信息：\n\n![closure](./closure3.png)\n\n从图可知，在返回的闭包作用链(Scopes)中携带有它所在函数的作用域，作用域中还包含一个str字段。而str字段并没有在返回getData()中使用过。为什么会存在在作用域中，按理应该被GC回收掉的？\n\n原因是在相同作用域内创建的多个内部函数对象是共享同一个[变量对象（variable object）](http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/)。如果创建的内部函数没有被其他对象引用，不管内部函数是否引用外部函数的变量和函数，在外部函数执行完，对应变量对象便会被销毁。反之，如果内部函数中存在有对外部函数变量或函数的访问（可以不是被引用的内部函数），并且存在某个或多个内部函数被其他对象引用，那么就会形成闭包，外部函数的变量对象就会存在于闭包函数的作用域链中。这样确保了闭包函数有权访问外部函数的所有变量和函数。了解了问题产生的原因，便可以对症下药了。对代码做如下修改：\n\n```js\n    function f() {\n      var str = Array(10000).join('#');\n      var foo = {\n        name: 'foo'\n      }\n      function unused() {\n        var message = 'it is only a test message';\n        // str = 'unused: ' + str; //删除该条语句\n      }\n      function getData() {\n        return 'data';\n      }\n      return getData;\n    }\n\n    var list = [];\n    \n    document.querySelector('#click_button').addEventListener('click', function () {\n      list.push(f());\n    }, false);\n```\n\ngetData()和unused()内部函数共享f函数对应的变量对象，因为unused()内部函数访问了f作用域内str变量，所以str字段存在于f变量对象中。加上getData()内部函数被返回，被其他对象引用，形成了闭包，因此对应的f变量对象存在于闭包函数的作用域链中。这里只要将函数unused中`str = 'unused: ' + str;`语句删除便可解决问题。\n\n![closure](./closure4.png)\n\n查看一下闭包信息：\n\n![closure](./closure5.png)\n\n## 总结\n闭包是JavaScript中很重要的概念，理解好它对我们掌握JavaScript很关键。也许你个人认为你对它很了解，但当因它产生问题时，才感悟自己对它了解甚少。如本文提到：<u>**在相同作用域内创建的多个内部函数对象是共享同一个变量对象**</u>。不管怎么样希望你能从本文中有所收获~。~\n\n## 参考文章\n- [An interesting kind of JavaScript memory leak](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)\n- [Grokking V8 closures for fun (and profit?)](http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html)\n","source":"_posts/关于闭包也许你不知道的事.md","raw":"---\ntitle: 关于闭包也许你不知道的事\ndate: 2017-11-23 21:48:36\ntags: [闭包, closure]\nauthor: singsong\n---\n\n![closure](./closure.png)\n\n当一个函数A返回一个内联函数B，即使函数A执行完，函数B也能访问函数A作用域内的变量。这就是一个闭包——————本质上闭包是将函数内部和外部连接起来的一座桥梁。\n\n```js\nfunction foo(message) {\n    function closure() {\n        console.log(message)\n    };\n    return closure;\n}\n\n// 使用\nvar bar = foo(\"hello closure!\");\nbar()// 返回 'hello closure!'\n```\n在函数foo内创建的函数closure对象是不能被回收掉的，因为它被全局变量bar引用，处于一直可访问状态。通过执行`bar()`可以打印出`hello closure!`。如果想释放掉可以将`bar = null`即可。\n\n<u>**由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。**</u>\n\n### 实例\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Closure</title>\n</head>\n\n<body>\n  <p>不断单击【click】按钮</p>\n  <button id=\"click_button\">Click</button>\n  <script>\n    function f() {\n      var str = Array(10000).join('#');\n      var foo = {\n        name: 'foo'\n      }\n      function unused() {\n        var message = 'it is only a test message';\n        str = 'unused: ' + str;\n      }\n      function getData() {\n        return 'data';\n      }\n      return getData;\n    }\n\n    var list = [];\n    \n    document.querySelector('#click_button').addEventListener('click', function () {\n      list.push(f());\n    }, false);\n  </script>\n</body>\n\n</html>\n```\n这里结合Chrome的Devtools->Memory工具进行分析，操作步骤如下：\n\n<u>**注：最好在隐身窗口中进行分析工作，避免浏览器插件影响分析结果**</u>\n\n1. 选中【Record allocation timeline】选项\n2. 执行一次CG\n3. 单击【start】按钮开始记录堆分析\n3. 连续单击【click】按钮十多次\n4. 停止记录堆分析\n\n![closure](./closure1.png)\n\n上图中蓝色柱形条表示随着时间新分配的内存。选中其中某条蓝色柱形条，过滤出对应新分配的对象：\n\n![closure](./closure2.png)\n\n查看对象的详细信息：\n\n![closure](./closure3.png)\n\n从图可知，在返回的闭包作用链(Scopes)中携带有它所在函数的作用域，作用域中还包含一个str字段。而str字段并没有在返回getData()中使用过。为什么会存在在作用域中，按理应该被GC回收掉的？\n\n原因是在相同作用域内创建的多个内部函数对象是共享同一个[变量对象（variable object）](http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/)。如果创建的内部函数没有被其他对象引用，不管内部函数是否引用外部函数的变量和函数，在外部函数执行完，对应变量对象便会被销毁。反之，如果内部函数中存在有对外部函数变量或函数的访问（可以不是被引用的内部函数），并且存在某个或多个内部函数被其他对象引用，那么就会形成闭包，外部函数的变量对象就会存在于闭包函数的作用域链中。这样确保了闭包函数有权访问外部函数的所有变量和函数。了解了问题产生的原因，便可以对症下药了。对代码做如下修改：\n\n```js\n    function f() {\n      var str = Array(10000).join('#');\n      var foo = {\n        name: 'foo'\n      }\n      function unused() {\n        var message = 'it is only a test message';\n        // str = 'unused: ' + str; //删除该条语句\n      }\n      function getData() {\n        return 'data';\n      }\n      return getData;\n    }\n\n    var list = [];\n    \n    document.querySelector('#click_button').addEventListener('click', function () {\n      list.push(f());\n    }, false);\n```\n\ngetData()和unused()内部函数共享f函数对应的变量对象，因为unused()内部函数访问了f作用域内str变量，所以str字段存在于f变量对象中。加上getData()内部函数被返回，被其他对象引用，形成了闭包，因此对应的f变量对象存在于闭包函数的作用域链中。这里只要将函数unused中`str = 'unused: ' + str;`语句删除便可解决问题。\n\n![closure](./closure4.png)\n\n查看一下闭包信息：\n\n![closure](./closure5.png)\n\n## 总结\n闭包是JavaScript中很重要的概念，理解好它对我们掌握JavaScript很关键。也许你个人认为你对它很了解，但当因它产生问题时，才感悟自己对它了解甚少。如本文提到：<u>**在相同作用域内创建的多个内部函数对象是共享同一个变量对象**</u>。不管怎么样希望你能从本文中有所收获~。~\n\n## 参考文章\n- [An interesting kind of JavaScript memory leak](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)\n- [Grokking V8 closures for fun (and profit?)](http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html)\n","slug":"关于闭包也许你不知道的事","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vatak000c1hn9x1b4gpqr","content":"<p><img src=\"./closure.png\" alt=\"closure\"></p>\n<p>当一个函数A返回一个内联函数B，即使函数A执行完，函数B也能访问函数A作用域内的变量。这就是一个闭包——————本质上闭包是将函数内部和外部连接起来的一座桥梁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(message)</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">return</span> closure;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用</span></div><div class=\"line\"><span class=\"keyword\">var</span> bar = foo(<span class=\"string\">\"hello closure!\"</span>);</div><div class=\"line\">bar()<span class=\"comment\">// 返回 'hello closure!'</span></div></pre></td></tr></table></figure>\n<p>在函数foo内创建的函数closure对象是不能被回收掉的，因为它被全局变量bar引用，处于一直可访问状态。通过执行<code>bar()</code>可以打印出<code>hello closure!</code>。如果想释放掉可以将<code>bar = null</code>即可。</p>\n<p><u><strong>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。</strong></u></p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Closure<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>不断单击【click】按钮<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"click_button\"</span>&gt;</span>Click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> str = <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">'#'</span>);</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> foo = &#123;</span></div><div class=\"line\"><span class=\"javascript\">        name: <span class=\"string\">'foo'</span></span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unused</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> message = <span class=\"string\">'it is only a test message'</span>;</span></div><div class=\"line\"><span class=\"javascript\">        str = <span class=\"string\">'unused: '</span> + str;</span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> <span class=\"string\">'data'</span>;</span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> getData;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> list = [];</span></div><div class=\"line\"><span class=\"undefined\">    </span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#click_button'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"undefined\">      list.push(f());</span></div><div class=\"line\"><span class=\"javascript\">    &#125;, <span class=\"literal\">false</span>);</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里结合Chrome的Devtools-&gt;Memory工具进行分析，操作步骤如下：</p>\n<p><u><strong>注：最好在隐身窗口中进行分析工作，避免浏览器插件影响分析结果</strong></u></p>\n<ol>\n<li>选中【Record allocation timeline】选项</li>\n<li>执行一次CG</li>\n<li>单击【start】按钮开始记录堆分析</li>\n<li>连续单击【click】按钮十多次</li>\n<li>停止记录堆分析</li>\n</ol>\n<p><img src=\"./closure1.png\" alt=\"closure\"></p>\n<p>上图中蓝色柱形条表示随着时间新分配的内存。选中其中某条蓝色柱形条，过滤出对应新分配的对象：</p>\n<p><img src=\"./closure2.png\" alt=\"closure\"></p>\n<p>查看对象的详细信息：</p>\n<p><img src=\"./closure3.png\" alt=\"closure\"></p>\n<p>从图可知，在返回的闭包作用链(Scopes)中携带有它所在函数的作用域，作用域中还包含一个str字段。而str字段并没有在返回getData()中使用过。为什么会存在在作用域中，按理应该被GC回收掉的？</p>\n<p>原因是在相同作用域内创建的多个内部函数对象是共享同一个<a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/\" target=\"_blank\" rel=\"external\">变量对象（variable object）</a>。如果创建的内部函数没有被其他对象引用，不管内部函数是否引用外部函数的变量和函数，在外部函数执行完，对应变量对象便会被销毁。反之，如果内部函数中存在有对外部函数变量或函数的访问（可以不是被引用的内部函数），并且存在某个或多个内部函数被其他对象引用，那么就会形成闭包，外部函数的变量对象就会存在于闭包函数的作用域链中。这样确保了闭包函数有权访问外部函数的所有变量和函数。了解了问题产生的原因，便可以对症下药了。对代码做如下修改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> str = <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">'#'</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> foo = &#123;</div><div class=\"line\">    name: <span class=\"string\">'foo'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unused</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> message = <span class=\"string\">'it is only a test message'</span>;</div><div class=\"line\">    <span class=\"comment\">// str = 'unused: ' + str; //删除该条语句</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'data'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> getData;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> list = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#click_button'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  list.push(f());</div><div class=\"line\">&#125;, <span class=\"literal\">false</span>);</div></pre></td></tr></table></figure>\n<p>getData()和unused()内部函数共享f函数对应的变量对象，因为unused()内部函数访问了f作用域内str变量，所以str字段存在于f变量对象中。加上getData()内部函数被返回，被其他对象引用，形成了闭包，因此对应的f变量对象存在于闭包函数的作用域链中。这里只要将函数unused中<code>str = &#39;unused: &#39; + str;</code>语句删除便可解决问题。</p>\n<p><img src=\"./closure4.png\" alt=\"closure\"></p>\n<p>查看一下闭包信息：</p>\n<p><img src=\"./closure5.png\" alt=\"closure\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>闭包是JavaScript中很重要的概念，理解好它对我们掌握JavaScript很关键。也许你个人认为你对它很了解，但当因它产生问题时，才感悟自己对它了解甚少。如本文提到：<u><strong>在相同作用域内创建的多个内部函数对象是共享同一个变量对象</strong></u>。不管怎么样希望你能从本文中有所收获~。~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"external\">An interesting kind of JavaScript memory leak</a></li>\n<li><a href=\"http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html\" target=\"_blank\" rel=\"external\">Grokking V8 closures for fun (and profit?)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"./closure.png\" alt=\"closure\"></p>\n<p>当一个函数A返回一个内联函数B，即使函数A执行完，函数B也能访问函数A作用域内的变量。这就是一个闭包——————本质上闭包是将函数内部和外部连接起来的一座桥梁。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">message</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">closure</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(message)</div><div class=\"line\">    &#125;;</div><div class=\"line\">    <span class=\"keyword\">return</span> closure;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用</span></div><div class=\"line\"><span class=\"keyword\">var</span> bar = foo(<span class=\"string\">\"hello closure!\"</span>);</div><div class=\"line\">bar()<span class=\"comment\">// 返回 'hello closure!'</span></div></pre></td></tr></table></figure>\n<p>在函数foo内创建的函数closure对象是不能被回收掉的，因为它被全局变量bar引用，处于一直可访问状态。通过执行<code>bar()</code>可以打印出<code>hello closure!</code>。如果想释放掉可以将<code>bar = null</code>即可。</p>\n<p><u><strong>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。</strong></u></p>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"X-UA-Compatible\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"ie=edge\"</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Closure<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>不断单击【click】按钮<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">id</span>=<span class=\"string\">\"click_button\"</span>&gt;</span>Click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> str = <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">'#'</span>);</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> foo = &#123;</span></div><div class=\"line\"><span class=\"javascript\">        name: <span class=\"string\">'foo'</span></span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unused</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">var</span> message = <span class=\"string\">'it is only a test message'</span>;</span></div><div class=\"line\"><span class=\"javascript\">        str = <span class=\"string\">'unused: '</span> + str;</span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">return</span> <span class=\"string\">'data'</span>;</span></div><div class=\"line\"><span class=\"undefined\">      &#125;</span></div><div class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">return</span> getData;</span></div><div class=\"line\"><span class=\"undefined\">    &#125;</span></div><div class=\"line\"><span class=\"undefined\"></span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">var</span> list = [];</span></div><div class=\"line\"><span class=\"undefined\">    </span></div><div class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#click_button'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span></div><div class=\"line\"><span class=\"undefined\">      list.push(f());</span></div><div class=\"line\"><span class=\"javascript\">    &#125;, <span class=\"literal\">false</span>);</span></div><div class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure>\n<p>这里结合Chrome的Devtools-&gt;Memory工具进行分析，操作步骤如下：</p>\n<p><u><strong>注：最好在隐身窗口中进行分析工作，避免浏览器插件影响分析结果</strong></u></p>\n<ol>\n<li>选中【Record allocation timeline】选项</li>\n<li>执行一次CG</li>\n<li>单击【start】按钮开始记录堆分析</li>\n<li>连续单击【click】按钮十多次</li>\n<li>停止记录堆分析</li>\n</ol>\n<p><img src=\"./closure1.png\" alt=\"closure\"></p>\n<p>上图中蓝色柱形条表示随着时间新分配的内存。选中其中某条蓝色柱形条，过滤出对应新分配的对象：</p>\n<p><img src=\"./closure2.png\" alt=\"closure\"></p>\n<p>查看对象的详细信息：</p>\n<p><img src=\"./closure3.png\" alt=\"closure\"></p>\n<p>从图可知，在返回的闭包作用链(Scopes)中携带有它所在函数的作用域，作用域中还包含一个str字段。而str字段并没有在返回getData()中使用过。为什么会存在在作用域中，按理应该被GC回收掉的？</p>\n<p>原因是在相同作用域内创建的多个内部函数对象是共享同一个<a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/\" target=\"_blank\" rel=\"external\">变量对象（variable object）</a>。如果创建的内部函数没有被其他对象引用，不管内部函数是否引用外部函数的变量和函数，在外部函数执行完，对应变量对象便会被销毁。反之，如果内部函数中存在有对外部函数变量或函数的访问（可以不是被引用的内部函数），并且存在某个或多个内部函数被其他对象引用，那么就会形成闭包，外部函数的变量对象就会存在于闭包函数的作用域链中。这样确保了闭包函数有权访问外部函数的所有变量和函数。了解了问题产生的原因，便可以对症下药了。对代码做如下修改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> str = <span class=\"built_in\">Array</span>(<span class=\"number\">10000</span>).join(<span class=\"string\">'#'</span>);</div><div class=\"line\">  <span class=\"keyword\">var</span> foo = &#123;</div><div class=\"line\">    name: <span class=\"string\">'foo'</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unused</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> message = <span class=\"string\">'it is only a test message'</span>;</div><div class=\"line\">    <span class=\"comment\">// str = 'unused: ' + str; //删除该条语句</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getData</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'data'</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> getData;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> list = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#click_button'</span>).addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  list.push(f());</div><div class=\"line\">&#125;, <span class=\"literal\">false</span>);</div></pre></td></tr></table></figure>\n<p>getData()和unused()内部函数共享f函数对应的变量对象，因为unused()内部函数访问了f作用域内str变量，所以str字段存在于f变量对象中。加上getData()内部函数被返回，被其他对象引用，形成了闭包，因此对应的f变量对象存在于闭包函数的作用域链中。这里只要将函数unused中<code>str = &#39;unused: &#39; + str;</code>语句删除便可解决问题。</p>\n<p><img src=\"./closure4.png\" alt=\"closure\"></p>\n<p>查看一下闭包信息：</p>\n<p><img src=\"./closure5.png\" alt=\"closure\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>闭包是JavaScript中很重要的概念，理解好它对我们掌握JavaScript很关键。也许你个人认为你对它很了解，但当因它产生问题时，才感悟自己对它了解甚少。如本文提到：<u><strong>在相同作用域内创建的多个内部函数对象是共享同一个变量对象</strong></u>。不管怎么样希望你能从本文中有所收获~。~</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><ul>\n<li><a href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"external\">An interesting kind of JavaScript memory leak</a></li>\n<li><a href=\"http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html\" target=\"_blank\" rel=\"external\">Grokking V8 closures for fun (and profit?)</a></li>\n</ul>\n"},{"title":"内存泄露之Listeners","date":"2017-11-01T04:59:04.000Z","author":"singsong","_content":"\n页面中事件绑定数量会直接影响页面的整体运行性能，因为每个事件的回调处理函数都是一个对象，占用一定的内存。如果事件的绑定数量越多，内存也随之增加。另外，回调处理函数需要与DOM节点进行交互，而JS引擎独立于渲染引擎，而DOM是位于渲染引擎，相互访问需要消耗一定的资源。加上操作DOM，会引起浏览器的重排或重绘，而影响页面的整体性能。\n\n> 事件代理 (事件委托) 利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n\n因此如何控制事件绑定数量就很重要了，通常都是通过事件代理（事件委托）来解决类似的问题。不过有时借助了事件代理（事件委托），而页面的事件绑定数量也在不断地增加？这可能是某些“不好”代码导致的，那如何定位增加的原因就显得很关键了。这里可以通过chrome的**DevTools**来辅助诊断。\n\n## DevTools\n\n### 如何判断页面的事件绑定数量在增加：\n 1. 打开DevTools->Performance，单击【记录按钮】开始记录页面相关performance数据。接着单击【垃圾回收按钮】，进行一次垃圾回收，创建基准参考线。\n 2. 进行可能引起事件绑定数量增加的操作。\n 3. 单击【stop】按钮，停止记录。\n\n![performance](listeners_performance.png)\n\n### 如何定位事件绑定数量的增加：\n1. 打开DevTools->Elements，查看页面中绑定事件的元素。\n\n![listeners](listeners_event.png)\n\n\n## 实战\n\b双十一快到了，各种tmall活动就多起来了。在做一个tmall动态皮肤时，需要在window大小变化时将之前构建的结构销毁，然后再重新计算构建。因为在销毁时，未解绑对应的事件。导致在window触发resize时，某个元素的事件绑定数量不断增加。关键代码如下：\n\n```js\n  var tmallskin = {\n    init: function() {\n      //......\n      this.bindEvent();\n    },\n    destroy: function() {\n      if (this.element.length > 0) {\n        this.container.off(\"click.tmallskin\");//该语句可以不用，因为在element.remove时会解除element上绑定的事件\n        this.element.remove();\n      }\n    }\n   // 绑定逻辑\n   bindEvent: function() {\n      var context = this;\n      this.container.on(\"click.tmallskin\", \".tmallskin-close\",function() {\n        //.... \n      });\n\n      var timer = null;\n      $(window).on(\"resize.tmallskin\", function() {\n        if (timer) {\n          clearTimeout(timer);\n        }\n        timer = setTimeout(function() {\n          // 窗口大小变化时，会不断执行destroy，init\n          context.destroy();\n          context.init();\n          timer = null;\n        }, 400);\n      });\n      // 因为未在destroy中解除该绑定，在window触发resize时，会不断地绑定\n      $(\".m-skin\").on(\"click.tmallskin\", \".grey, .reset\", function() {\n        o._JS.SK[\"1\"].init();\n      });\n    }\n  };\n```\n上述code中，因为在destroy方法中未对`$(\".m-skin\")`元素上绑定的事件进行解除，导致在window触发resize时，不断进行绑定。\n\n- DevTools诊断截图如下：\n\n![resize](listeners_resize.png)\n\n- resize之后：\n\n![resize](listeners_resize_after.png)\n\n- 单击右侧定位链接`(index):42`：\n\n![location](listener_location.png)\n\n\n### 知道问题的原因，修复代码如下：\n\n```js\n    //.....\n    destroy: function() {\n      if (this.element.length > 0) {\n        this.container.off(\"click.tmallskin\");\n        $(\".m-skin\").off(\"click.tmallskin\");//销毁时解除绑定\n        $(window).off(\"resize.tmallskin\");\n        this.element.remove();\n      }\n    },\n    //.....\n```\n效果截图：\n\n![fixed](listeners_fixed.png)\n\n\n## 总结\n可能在实践编码中，很少关注主动解除事件绑定。如常用的Jquery库，会在元素删除时，自动解除元素上绑定的事件。不过难免存在某些情况，Jquery也无能无力，这时需要我们主动进行解绑，因为过多的事件绑定会直接影响页面的整体性能。因此了解如何诊断事件绑定的增加是很重要的，也希望本文对你有所帮助。","source":"_posts/内存泄露之Listeners.md","raw":"---\ntitle: 内存泄露之Listeners\ndate: 2017-11-01 12:59:04\ntags: [listeners, 优化, 内存泄露]\nauthor: singsong\n---\n\n页面中事件绑定数量会直接影响页面的整体运行性能，因为每个事件的回调处理函数都是一个对象，占用一定的内存。如果事件的绑定数量越多，内存也随之增加。另外，回调处理函数需要与DOM节点进行交互，而JS引擎独立于渲染引擎，而DOM是位于渲染引擎，相互访问需要消耗一定的资源。加上操作DOM，会引起浏览器的重排或重绘，而影响页面的整体性能。\n\n> 事件代理 (事件委托) 利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。\n\n因此如何控制事件绑定数量就很重要了，通常都是通过事件代理（事件委托）来解决类似的问题。不过有时借助了事件代理（事件委托），而页面的事件绑定数量也在不断地增加？这可能是某些“不好”代码导致的，那如何定位增加的原因就显得很关键了。这里可以通过chrome的**DevTools**来辅助诊断。\n\n## DevTools\n\n### 如何判断页面的事件绑定数量在增加：\n 1. 打开DevTools->Performance，单击【记录按钮】开始记录页面相关performance数据。接着单击【垃圾回收按钮】，进行一次垃圾回收，创建基准参考线。\n 2. 进行可能引起事件绑定数量增加的操作。\n 3. 单击【stop】按钮，停止记录。\n\n![performance](listeners_performance.png)\n\n### 如何定位事件绑定数量的增加：\n1. 打开DevTools->Elements，查看页面中绑定事件的元素。\n\n![listeners](listeners_event.png)\n\n\n## 实战\n\b双十一快到了，各种tmall活动就多起来了。在做一个tmall动态皮肤时，需要在window大小变化时将之前构建的结构销毁，然后再重新计算构建。因为在销毁时，未解绑对应的事件。导致在window触发resize时，某个元素的事件绑定数量不断增加。关键代码如下：\n\n```js\n  var tmallskin = {\n    init: function() {\n      //......\n      this.bindEvent();\n    },\n    destroy: function() {\n      if (this.element.length > 0) {\n        this.container.off(\"click.tmallskin\");//该语句可以不用，因为在element.remove时会解除element上绑定的事件\n        this.element.remove();\n      }\n    }\n   // 绑定逻辑\n   bindEvent: function() {\n      var context = this;\n      this.container.on(\"click.tmallskin\", \".tmallskin-close\",function() {\n        //.... \n      });\n\n      var timer = null;\n      $(window).on(\"resize.tmallskin\", function() {\n        if (timer) {\n          clearTimeout(timer);\n        }\n        timer = setTimeout(function() {\n          // 窗口大小变化时，会不断执行destroy，init\n          context.destroy();\n          context.init();\n          timer = null;\n        }, 400);\n      });\n      // 因为未在destroy中解除该绑定，在window触发resize时，会不断地绑定\n      $(\".m-skin\").on(\"click.tmallskin\", \".grey, .reset\", function() {\n        o._JS.SK[\"1\"].init();\n      });\n    }\n  };\n```\n上述code中，因为在destroy方法中未对`$(\".m-skin\")`元素上绑定的事件进行解除，导致在window触发resize时，不断进行绑定。\n\n- DevTools诊断截图如下：\n\n![resize](listeners_resize.png)\n\n- resize之后：\n\n![resize](listeners_resize_after.png)\n\n- 单击右侧定位链接`(index):42`：\n\n![location](listener_location.png)\n\n\n### 知道问题的原因，修复代码如下：\n\n```js\n    //.....\n    destroy: function() {\n      if (this.element.length > 0) {\n        this.container.off(\"click.tmallskin\");\n        $(\".m-skin\").off(\"click.tmallskin\");//销毁时解除绑定\n        $(window).off(\"resize.tmallskin\");\n        this.element.remove();\n      }\n    },\n    //.....\n```\n效果截图：\n\n![fixed](listeners_fixed.png)\n\n\n## 总结\n可能在实践编码中，很少关注主动解除事件绑定。如常用的Jquery库，会在元素删除时，自动解除元素上绑定的事件。不过难免存在某些情况，Jquery也无能无力，这时需要我们主动进行解绑，因为过多的事件绑定会直接影响页面的整体性能。因此了解如何诊断事件绑定的增加是很重要的，也希望本文对你有所帮助。","slug":"内存泄露之Listeners","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vatal000d1hn9kh575zzi","content":"<p>页面中事件绑定数量会直接影响页面的整体运行性能，因为每个事件的回调处理函数都是一个对象，占用一定的内存。如果事件的绑定数量越多，内存也随之增加。另外，回调处理函数需要与DOM节点进行交互，而JS引擎独立于渲染引擎，而DOM是位于渲染引擎，相互访问需要消耗一定的资源。加上操作DOM，会引起浏览器的重排或重绘，而影响页面的整体性能。</p>\n<blockquote>\n<p>事件代理 (事件委托) 利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>\n</blockquote>\n<p>因此如何控制事件绑定数量就很重要了，通常都是通过事件代理（事件委托）来解决类似的问题。不过有时借助了事件代理（事件委托），而页面的事件绑定数量也在不断地增加？这可能是某些“不好”代码导致的，那如何定位增加的原因就显得很关键了。这里可以通过chrome的<strong>DevTools</strong>来辅助诊断。</p>\n<h2 id=\"DevTools\"><a href=\"#DevTools\" class=\"headerlink\" title=\"DevTools\"></a>DevTools</h2><h3 id=\"如何判断页面的事件绑定数量在增加：\"><a href=\"#如何判断页面的事件绑定数量在增加：\" class=\"headerlink\" title=\"如何判断页面的事件绑定数量在增加：\"></a>如何判断页面的事件绑定数量在增加：</h3><ol>\n<li>打开DevTools-&gt;Performance，单击【记录按钮】开始记录页面相关performance数据。接着单击【垃圾回收按钮】，进行一次垃圾回收，创建基准参考线。</li>\n<li>进行可能引起事件绑定数量增加的操作。</li>\n<li>单击【stop】按钮，停止记录。</li>\n</ol>\n<p><img src=\"listeners_performance.png\" alt=\"performance\"></p>\n<h3 id=\"如何定位事件绑定数量的增加：\"><a href=\"#如何定位事件绑定数量的增加：\" class=\"headerlink\" title=\"如何定位事件绑定数量的增加：\"></a>如何定位事件绑定数量的增加：</h3><ol>\n<li>打开DevTools-&gt;Elements，查看页面中绑定事件的元素。</li>\n</ol>\n<p><img src=\"listeners_event.png\" alt=\"listeners\"></p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>\b双十一快到了，各种tmall活动就多起来了。在做一个tmall动态皮肤时，需要在window大小变化时将之前构建的结构销毁，然后再重新计算构建。因为在销毁时，未解绑对应的事件。导致在window触发resize时，某个元素的事件绑定数量不断增加。关键代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> tmallskin = &#123;</div><div class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//......</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.bindEvent();</div><div class=\"line\">  &#125;,</div><div class=\"line\">  destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.element.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.container.off(<span class=\"string\">\"click.tmallskin\"</span>);<span class=\"comment\">//该语句可以不用，因为在element.remove时会解除element上绑定的事件</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.element.remove();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"> <span class=\"comment\">// 绑定逻辑</span></div><div class=\"line\"> bindEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.container.on(<span class=\"string\">\"click.tmallskin\"</span>, <span class=\"string\">\".tmallskin-close\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//.... </span></div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</div><div class=\"line\">    $(<span class=\"built_in\">window</span>).on(<span class=\"string\">\"resize.tmallskin\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</div><div class=\"line\">        clearTimeout(timer);</div><div class=\"line\">      &#125;</div><div class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 窗口大小变化时，会不断执行destroy，init</span></div><div class=\"line\">        context.destroy();</div><div class=\"line\">        context.init();</div><div class=\"line\">        timer = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;, <span class=\"number\">400</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"comment\">// 因为未在destroy中解除该绑定，在window触发resize时，会不断地绑定</span></div><div class=\"line\">    $(<span class=\"string\">\".m-skin\"</span>).on(<span class=\"string\">\"click.tmallskin\"</span>, <span class=\"string\">\".grey, .reset\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      o._JS.SK[<span class=\"string\">\"1\"</span>].init();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上述code中，因为在destroy方法中未对<code>$(&quot;.m-skin&quot;)</code>元素上绑定的事件进行解除，导致在window触发resize时，不断进行绑定。</p>\n<ul>\n<li>DevTools诊断截图如下：</li>\n</ul>\n<p><img src=\"listeners_resize.png\" alt=\"resize\"></p>\n<ul>\n<li>resize之后：</li>\n</ul>\n<p><img src=\"listeners_resize_after.png\" alt=\"resize\"></p>\n<ul>\n<li>单击右侧定位链接<code>(index):42</code>：</li>\n</ul>\n<p><img src=\"listener_location.png\" alt=\"location\"></p>\n<h3 id=\"知道问题的原因，修复代码如下：\"><a href=\"#知道问题的原因，修复代码如下：\" class=\"headerlink\" title=\"知道问题的原因，修复代码如下：\"></a>知道问题的原因，修复代码如下：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//.....</span></div><div class=\"line\">destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.element.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.container.off(<span class=\"string\">\"click.tmallskin\"</span>);</div><div class=\"line\">    $(<span class=\"string\">\".m-skin\"</span>).off(<span class=\"string\">\"click.tmallskin\"</span>);<span class=\"comment\">//销毁时解除绑定</span></div><div class=\"line\">    $(<span class=\"built_in\">window</span>).off(<span class=\"string\">\"resize.tmallskin\"</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.element.remove();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"comment\">//.....</span></div></pre></td></tr></table></figure>\n<p>效果截图：</p>\n<p><img src=\"listeners_fixed.png\" alt=\"fixed\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可能在实践编码中，很少关注主动解除事件绑定。如常用的Jquery库，会在元素删除时，自动解除元素上绑定的事件。不过难免存在某些情况，Jquery也无能无力，这时需要我们主动进行解绑，因为过多的事件绑定会直接影响页面的整体性能。因此了解如何诊断事件绑定的增加是很重要的，也希望本文对你有所帮助。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>页面中事件绑定数量会直接影响页面的整体运行性能，因为每个事件的回调处理函数都是一个对象，占用一定的内存。如果事件的绑定数量越多，内存也随之增加。另外，回调处理函数需要与DOM节点进行交互，而JS引擎独立于渲染引擎，而DOM是位于渲染引擎，相互访问需要消耗一定的资源。加上操作DOM，会引起浏览器的重排或重绘，而影响页面的整体性能。</p>\n<blockquote>\n<p>事件代理 (事件委托) 利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。</p>\n</blockquote>\n<p>因此如何控制事件绑定数量就很重要了，通常都是通过事件代理（事件委托）来解决类似的问题。不过有时借助了事件代理（事件委托），而页面的事件绑定数量也在不断地增加？这可能是某些“不好”代码导致的，那如何定位增加的原因就显得很关键了。这里可以通过chrome的<strong>DevTools</strong>来辅助诊断。</p>\n<h2 id=\"DevTools\"><a href=\"#DevTools\" class=\"headerlink\" title=\"DevTools\"></a>DevTools</h2><h3 id=\"如何判断页面的事件绑定数量在增加：\"><a href=\"#如何判断页面的事件绑定数量在增加：\" class=\"headerlink\" title=\"如何判断页面的事件绑定数量在增加：\"></a>如何判断页面的事件绑定数量在增加：</h3><ol>\n<li>打开DevTools-&gt;Performance，单击【记录按钮】开始记录页面相关performance数据。接着单击【垃圾回收按钮】，进行一次垃圾回收，创建基准参考线。</li>\n<li>进行可能引起事件绑定数量增加的操作。</li>\n<li>单击【stop】按钮，停止记录。</li>\n</ol>\n<p><img src=\"listeners_performance.png\" alt=\"performance\"></p>\n<h3 id=\"如何定位事件绑定数量的增加：\"><a href=\"#如何定位事件绑定数量的增加：\" class=\"headerlink\" title=\"如何定位事件绑定数量的增加：\"></a>如何定位事件绑定数量的增加：</h3><ol>\n<li>打开DevTools-&gt;Elements，查看页面中绑定事件的元素。</li>\n</ol>\n<p><img src=\"listeners_event.png\" alt=\"listeners\"></p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><p>\b双十一快到了，各种tmall活动就多起来了。在做一个tmall动态皮肤时，需要在window大小变化时将之前构建的结构销毁，然后再重新计算构建。因为在销毁时，未解绑对应的事件。导致在window触发resize时，某个元素的事件绑定数量不断增加。关键代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> tmallskin = &#123;</div><div class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//......</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.bindEvent();</div><div class=\"line\">  &#125;,</div><div class=\"line\">  destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.element.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.container.off(<span class=\"string\">\"click.tmallskin\"</span>);<span class=\"comment\">//该语句可以不用，因为在element.remove时会解除element上绑定的事件</span></div><div class=\"line\">      <span class=\"keyword\">this</span>.element.remove();</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"> <span class=\"comment\">// 绑定逻辑</span></div><div class=\"line\"> bindEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.container.on(<span class=\"string\">\"click.tmallskin\"</span>, <span class=\"string\">\".tmallskin-close\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//.... </span></div><div class=\"line\">    &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</div><div class=\"line\">    $(<span class=\"built_in\">window</span>).on(<span class=\"string\">\"resize.tmallskin\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</div><div class=\"line\">        clearTimeout(timer);</div><div class=\"line\">      &#125;</div><div class=\"line\">      timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 窗口大小变化时，会不断执行destroy，init</span></div><div class=\"line\">        context.destroy();</div><div class=\"line\">        context.init();</div><div class=\"line\">        timer = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;, <span class=\"number\">400</span>);</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"comment\">// 因为未在destroy中解除该绑定，在window触发resize时，会不断地绑定</span></div><div class=\"line\">    $(<span class=\"string\">\".m-skin\"</span>).on(<span class=\"string\">\"click.tmallskin\"</span>, <span class=\"string\">\".grey, .reset\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      o._JS.SK[<span class=\"string\">\"1\"</span>].init();</div><div class=\"line\">    &#125;);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>上述code中，因为在destroy方法中未对<code>$(&quot;.m-skin&quot;)</code>元素上绑定的事件进行解除，导致在window触发resize时，不断进行绑定。</p>\n<ul>\n<li>DevTools诊断截图如下：</li>\n</ul>\n<p><img src=\"listeners_resize.png\" alt=\"resize\"></p>\n<ul>\n<li>resize之后：</li>\n</ul>\n<p><img src=\"listeners_resize_after.png\" alt=\"resize\"></p>\n<ul>\n<li>单击右侧定位链接<code>(index):42</code>：</li>\n</ul>\n<p><img src=\"listener_location.png\" alt=\"location\"></p>\n<h3 id=\"知道问题的原因，修复代码如下：\"><a href=\"#知道问题的原因，修复代码如下：\" class=\"headerlink\" title=\"知道问题的原因，修复代码如下：\"></a>知道问题的原因，修复代码如下：</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//.....</span></div><div class=\"line\">destroy: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.element.length &gt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.container.off(<span class=\"string\">\"click.tmallskin\"</span>);</div><div class=\"line\">    $(<span class=\"string\">\".m-skin\"</span>).off(<span class=\"string\">\"click.tmallskin\"</span>);<span class=\"comment\">//销毁时解除绑定</span></div><div class=\"line\">    $(<span class=\"built_in\">window</span>).off(<span class=\"string\">\"resize.tmallskin\"</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.element.remove();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div><div class=\"line\"><span class=\"comment\">//.....</span></div></pre></td></tr></table></figure>\n<p>效果截图：</p>\n<p><img src=\"listeners_fixed.png\" alt=\"fixed\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可能在实践编码中，很少关注主动解除事件绑定。如常用的Jquery库，会在元素删除时，自动解除元素上绑定的事件。不过难免存在某些情况，Jquery也无能无力，这时需要我们主动进行解绑，因为过多的事件绑定会直接影响页面的整体性能。因此了解如何诊断事件绑定的增加是很重要的，也希望本文对你有所帮助。</p>\n"},{"title":"内存泄露之jQuery.cache","date":"2017-11-13T08:51:49.000Z","author":"singsong","_content":"\n![jquery.jpg](./jquery.jpg)\n\njQuery没有将事件和数据绑定在DOM节点上，而是将这些信息储存在`$.cache`对象上。jQuery对象每次新增事件或数据时，都在`$.cache`新增一条数据。而`$.cache`会持有对应DOM节点的引用，如果没有正确删除DOM节点，会导致DOM节点不能被回收。即DOM节点已从DOM中删除，但依然还存在内存中，没有被CG回收。正确的删除方式是通过jQuery的删除方法来移除：`remove()`,`empty()`,`html()`;\n\n#### 上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\n\n```js\nvar $element = $('<div></div>');\n$element.on('click', function() { ... });\n$element.appendTo(document.body); \nvar nativeElement = $element.get(0);\ndocument.body.removeChild(nativeElement); // ← 通过removeChild方法移除nativeElement\n```\n\n上述代码中使用内置的removeChild方法移除nativeElement，此时仅仅只是将nativeElement与DOM脱离而已，并没有真正地删除nativeElement。原因是$element绑定了事件，`$.cache`中持有对$element引用，导致nativeElement不能被回收掉。\n\n```js\nvar $element = $('<div></div>');\n$element.on('click', function() { ... });// ← 绑定事件\n$element.appendTo(document.body);\ndocument.body.innerHTML = '';// ← 通过innerHTML方法移除body内的节点\n```\ninnerHTML方法也存在同样的问题。\n\n\n#### 上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\n\n```js\n$element = $('<div></div>');\n$element.data('foo', 'bar');\n```\n\n即使代码执行完，$element也不能被回收。这是因为$.cahce阻止CG的回收。需要通过`$element.remove()`,`$element.parent.empty()`或`$elememnt.removeData()`;\n\n\n## 为什么`remove()`,`empty()`,`html()`能正确移除DOM节点\n因为它们都会调用`jQuery.cleanData()`方法来删除`$.cache`缓存的对应数据，然后在调用JavaScript内置删除方法来移除DOM节点。\n\n[empty()方法源码](https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L461)：\n\n```js\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\n\t\t\t// Remove element nodes and prevent memory leaks \n      // 删除元素节点并阻止内存泄露\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n```\n\n[remove()方法源码](https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L265)\n\n```js\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\telems = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = elems[ i ] ) != null; i++ ) {\n\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n```\n\n[html()方法源码](https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L496)\n```js\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n            // 删除元素节点并阻止内存泄露\n\t\t\t\t\t\telem = this[ i ] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t}\n```\n\n## 为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在$.cache中？\n\n因为在IE<8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。即JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用（循环引用），从而导致内存泄露。为了避免在低版本IE和Firefox中内存泄露，jQuery创建了`$.cache`来解决这个问题。更多信息参考[IE<8循环引用导致的内存泄露](http://123fe.cn/2017/11/10/IE-8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/)。\n\n\n>  jQuery 2.0 leaves behind the older Internet Explorer 6, 7, and 8 browsers. In return it is smaller, faster, and can be used in JavaScript environments where the code needed for old-IE compatibility often causes problems of its own. But don’t worry, the jQuery team still supports the 1.x branch which does run on IE 6/7/8. You can (and should) continue to use jQuery 1.9 (and the upcoming 1.10) on web sites that need to accommodate older browsers. The final 2.0.0 file is 12 percent smaller than the 1.9.1 file, thanks to the elimination of patches that were only needed for IE 6, 7, and 8. ----[jQuery 2.0 Released](http://blog.jquery.com/2013/04/18/jquery-2-0-released/)\n\n**大概意思**：<u>jQuery2.0版本之后，jQuery团队同时维护两个分支：2.x版本和1.x版本。jQuery2.0开始放弃IE6/7/8支持(注：也包含3.x版本)。而jQuery1.x版本会继续支持IE6/7/8。因为2.x版本删除了IE6/7/8补丁代码，整体大小比1.x版本小12%，性能更好。</u>\n\n即从jQuery2.0开始不支持IE6/7/8，就不存在循环引用的问题，因此$.cache也从jQuery2.x版本中移除。jQuery2.0开始将事件信息存储存储在元素节点上，这样就不存在上述的内存泄露问题了。\n\n## 对比测试\n分别使用jquery1.x和jquery2.x版本创建一个1000个元素并绑定click事件，创建完后再通过JavaScript删除方法移除，并通过**Devtools**-->**Performance**做分析，操作步骤如下：\n  1. 开启**Performance**项的记录\n  2. 执行一次CG，创建基本参考线\n  3. 单击【run】按钮，创建1000个元素\n  4. 再次单击【run】按钮，创建1000个元素\n  5. 单击【clear】按钮，通过JavaScript删除方法移除刚创建2000个元素\n  6. 执行一次CG\n\n结果图如下：\n\n![](./jquery1_x.png)\n\n----\n\n![](./jquery2_x.png)\n\n\n\n\n\n\n**从对比结果图证实了jquery2.x将事件信息存储在元素对象上。这里也可以分别打印`$.cache`，对比一下输出结果：**\n\n![](./jquery_cache_1_x.png)\n\n----\n\n![](./jquery_cache_2_x.png)\n\n\n这里没有讨论jquery3.x版本，因为它与jquery2.x版本一样不支持低版本IE，也不存在`$.cache`问题，所以不再赘述。\n\n## 总结\n\n本文主要讨论了jquery的`$.cache`引起的内存泄露问题。在使用jquery1.x版本时，需要关注一下这一问题。如jquery.lazyload.js和单页应用都很容易引起这方面的问题。如何避免呢？本文也提到了，通过jquery的删除方法来移除:`remove()`,`empty()`,`html()`。**在使用第三方库时一定要记住：通过任何第三方库创建的对象，最好通过该库提供的删除方法来删除。**\n\n\n## 参考文章：\n\n- [How to create memory leaks in jQuery](https://makandracards.com/makandra/31325-how-to-create-memory-leaks-in-jquery)\n- [What is the purpose of $.cache in jQuery?](https://stackoverflow.com/questions/9304768/what-is-the-purpose-of-cache-in-jquery)\n- [JScript Memory Leaks](http://www.crockford.com/javascript/memory/leak.html)\n- [Memory Leaks in Microsoft Internet Explorer](http://isaacschlueter.com/2006/10/msie-memory-leaks/)\n","source":"_posts/内存泄露之jQuery-cache.md","raw":"---\ntitle: 内存泄露之jQuery.cache\ndate: 2017-11-13 16:51:49\ntags: [$.cache,'jquery', 优化, 内存泄露]\nauthor: singsong\n---\n\n![jquery.jpg](./jquery.jpg)\n\njQuery没有将事件和数据绑定在DOM节点上，而是将这些信息储存在`$.cache`对象上。jQuery对象每次新增事件或数据时，都在`$.cache`新增一条数据。而`$.cache`会持有对应DOM节点的引用，如果没有正确删除DOM节点，会导致DOM节点不能被回收。即DOM节点已从DOM中删除，但依然还存在内存中，没有被CG回收。正确的删除方式是通过jQuery的删除方法来移除：`remove()`,`empty()`,`html()`;\n\n#### 上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\n\n```js\nvar $element = $('<div></div>');\n$element.on('click', function() { ... });\n$element.appendTo(document.body); \nvar nativeElement = $element.get(0);\ndocument.body.removeChild(nativeElement); // ← 通过removeChild方法移除nativeElement\n```\n\n上述代码中使用内置的removeChild方法移除nativeElement，此时仅仅只是将nativeElement与DOM脱离而已，并没有真正地删除nativeElement。原因是$element绑定了事件，`$.cache`中持有对$element引用，导致nativeElement不能被回收掉。\n\n```js\nvar $element = $('<div></div>');\n$element.on('click', function() { ... });// ← 绑定事件\n$element.appendTo(document.body);\ndocument.body.innerHTML = '';// ← 通过innerHTML方法移除body内的节点\n```\ninnerHTML方法也存在同样的问题。\n\n\n#### 上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\n\n```js\n$element = $('<div></div>');\n$element.data('foo', 'bar');\n```\n\n即使代码执行完，$element也不能被回收。这是因为$.cahce阻止CG的回收。需要通过`$element.remove()`,`$element.parent.empty()`或`$elememnt.removeData()`;\n\n\n## 为什么`remove()`,`empty()`,`html()`能正确移除DOM节点\n因为它们都会调用`jQuery.cleanData()`方法来删除`$.cache`缓存的对应数据，然后在调用JavaScript内置删除方法来移除DOM节点。\n\n[empty()方法源码](https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L461)：\n\n```js\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\n\t\t\t// Remove element nodes and prevent memory leaks \n      // 删除元素节点并阻止内存泄露\n\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用\n\t\t\t}\n\n\t\t\t// Remove any remaining nodes\n\t\t\twhile ( elem.firstChild ) {\n\t\t\t\telem.removeChild( elem.firstChild );\n\t\t\t}\n\n\t\t\t// If this is a select, ensure that it displays empty (#12336)\n\t\t\t// Support: IE<9\n\t\t\tif ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n\t\t\t\telem.options.length = 0;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n```\n\n[remove()方法源码](https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L265)\n\n```js\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\telems = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = elems[ i ] ) != null; i++ ) {\n\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n```\n\n[html()方法源码](https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L496)\n```js\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined ) {\n\t\t\t\treturn elem.nodeType === 1 ?\n\t\t\t\t\telem.innerHTML.replace( rinlinejQuery, \"\" ) :\n\t\t\t\t\tundefined;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n\t\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n            // 删除元素节点并阻止内存泄露\n\t\t\t\t\t\telem = this[ i ] || {};\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t}\n```\n\n## 为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在$.cache中？\n\n因为在IE<8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。即JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用（循环引用），从而导致内存泄露。为了避免在低版本IE和Firefox中内存泄露，jQuery创建了`$.cache`来解决这个问题。更多信息参考[IE<8循环引用导致的内存泄露](http://123fe.cn/2017/11/10/IE-8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/)。\n\n\n>  jQuery 2.0 leaves behind the older Internet Explorer 6, 7, and 8 browsers. In return it is smaller, faster, and can be used in JavaScript environments where the code needed for old-IE compatibility often causes problems of its own. But don’t worry, the jQuery team still supports the 1.x branch which does run on IE 6/7/8. You can (and should) continue to use jQuery 1.9 (and the upcoming 1.10) on web sites that need to accommodate older browsers. The final 2.0.0 file is 12 percent smaller than the 1.9.1 file, thanks to the elimination of patches that were only needed for IE 6, 7, and 8. ----[jQuery 2.0 Released](http://blog.jquery.com/2013/04/18/jquery-2-0-released/)\n\n**大概意思**：<u>jQuery2.0版本之后，jQuery团队同时维护两个分支：2.x版本和1.x版本。jQuery2.0开始放弃IE6/7/8支持(注：也包含3.x版本)。而jQuery1.x版本会继续支持IE6/7/8。因为2.x版本删除了IE6/7/8补丁代码，整体大小比1.x版本小12%，性能更好。</u>\n\n即从jQuery2.0开始不支持IE6/7/8，就不存在循环引用的问题，因此$.cache也从jQuery2.x版本中移除。jQuery2.0开始将事件信息存储存储在元素节点上，这样就不存在上述的内存泄露问题了。\n\n## 对比测试\n分别使用jquery1.x和jquery2.x版本创建一个1000个元素并绑定click事件，创建完后再通过JavaScript删除方法移除，并通过**Devtools**-->**Performance**做分析，操作步骤如下：\n  1. 开启**Performance**项的记录\n  2. 执行一次CG，创建基本参考线\n  3. 单击【run】按钮，创建1000个元素\n  4. 再次单击【run】按钮，创建1000个元素\n  5. 单击【clear】按钮，通过JavaScript删除方法移除刚创建2000个元素\n  6. 执行一次CG\n\n结果图如下：\n\n![](./jquery1_x.png)\n\n----\n\n![](./jquery2_x.png)\n\n\n\n\n\n\n**从对比结果图证实了jquery2.x将事件信息存储在元素对象上。这里也可以分别打印`$.cache`，对比一下输出结果：**\n\n![](./jquery_cache_1_x.png)\n\n----\n\n![](./jquery_cache_2_x.png)\n\n\n这里没有讨论jquery3.x版本，因为它与jquery2.x版本一样不支持低版本IE，也不存在`$.cache`问题，所以不再赘述。\n\n## 总结\n\n本文主要讨论了jquery的`$.cache`引起的内存泄露问题。在使用jquery1.x版本时，需要关注一下这一问题。如jquery.lazyload.js和单页应用都很容易引起这方面的问题。如何避免呢？本文也提到了，通过jquery的删除方法来移除:`remove()`,`empty()`,`html()`。**在使用第三方库时一定要记住：通过任何第三方库创建的对象，最好通过该库提供的删除方法来删除。**\n\n\n## 参考文章：\n\n- [How to create memory leaks in jQuery](https://makandracards.com/makandra/31325-how-to-create-memory-leaks-in-jquery)\n- [What is the purpose of $.cache in jQuery?](https://stackoverflow.com/questions/9304768/what-is-the-purpose-of-cache-in-jquery)\n- [JScript Memory Leaks](http://www.crockford.com/javascript/memory/leak.html)\n- [Memory Leaks in Microsoft Internet Explorer](http://isaacschlueter.com/2006/10/msie-memory-leaks/)\n","slug":"内存泄露之jQuery-cache","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vatam000f1hn9rven9ng7","content":"<p><img src=\"./jquery.jpg\" alt=\"jquery.jpg\"></p>\n<p>jQuery没有将事件和数据绑定在DOM节点上，而是将这些信息储存在<code>$.cache</code>对象上。jQuery对象每次新增事件或数据时，都在<code>$.cache</code>新增一条数据。而<code>$.cache</code>会持有对应DOM节点的引用，如果没有正确删除DOM节点，会导致DOM节点不能被回收。即DOM节点已从DOM中删除，但依然还存在内存中，没有被CG回收。正确的删除方式是通过jQuery的删除方法来移除：<code>remove()</code>,<code>empty()</code>,<code>html()</code>;</p>\n<h4 id=\"上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\"><a href=\"#上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\" class=\"headerlink\" title=\"上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\"></a>上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $element = $(<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">$element.on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;);</div><div class=\"line\">$element.appendTo(<span class=\"built_in\">document</span>.body); </div><div class=\"line\"><span class=\"keyword\">var</span> nativeElement = $element.get(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">document</span>.body.removeChild(nativeElement); <span class=\"comment\">// ← 通过removeChild方法移除nativeElement</span></div></pre></td></tr></table></figure>\n<p>上述代码中使用内置的removeChild方法移除nativeElement，此时仅仅只是将nativeElement与DOM脱离而已，并没有真正地删除nativeElement。原因是$element绑定了事件，<code>$.cache</code>中持有对$element引用，导致nativeElement不能被回收掉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $element = $(<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">$element.on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;);<span class=\"comment\">// ← 绑定事件</span></div><div class=\"line\">$element.appendTo(<span class=\"built_in\">document</span>.body);</div><div class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">''</span>;<span class=\"comment\">// ← 通过innerHTML方法移除body内的节点</span></div></pre></td></tr></table></figure>\n<p>innerHTML方法也存在同样的问题。</p>\n<h4 id=\"上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\"><a href=\"#上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\" class=\"headerlink\" title=\"上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\"></a>上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$element = $(<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">$element.data(<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>);</div></pre></td></tr></table></figure>\n<p>即使代码执行完，$element也不能被回收。这是因为$.cahce阻止CG的回收。需要通过<code>$element.remove()</code>,<code>$element.parent.empty()</code>或<code>$elememnt.removeData()</code>;</p>\n<h2 id=\"为什么remove-empty-html-能正确移除DOM节点\"><a href=\"#为什么remove-empty-html-能正确移除DOM节点\" class=\"headerlink\" title=\"为什么remove(),empty(),html()能正确移除DOM节点\"></a>为什么<code>remove()</code>,<code>empty()</code>,<code>html()</code>能正确移除DOM节点</h2><p>因为它们都会调用<code>jQuery.cleanData()</code>方法来删除<code>$.cache</code>缓存的对应数据，然后在调用JavaScript内置删除方法来移除DOM节点。</p>\n<p><a href=\"https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L461\" target=\"_blank\" rel=\"external\">empty()方法源码</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">empty: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> elem,</div><div class=\"line\">\t\ti = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> ( ; ( elem = <span class=\"keyword\">this</span>[ i ] ) != <span class=\"literal\">null</span>; i++ ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Remove element nodes and prevent memory leaks </span></div><div class=\"line\">     <span class=\"comment\">// 删除元素节点并阻止内存泄露</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> ) &#123;</div><div class=\"line\">\t\t\tjQuery.cleanData( getAll( elem, <span class=\"literal\">false</span> ) );<span class=\"comment\">// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Remove any remaining nodes</span></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> ( elem.firstChild ) &#123;</div><div class=\"line\">\t\t\telem.removeChild( elem.firstChild );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// If this is a select, ensure that it displays empty (#12336)</span></div><div class=\"line\">\t\t<span class=\"comment\">// Support: IE&lt;9</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( elem.options &amp;&amp; jQuery.nodeName( elem, <span class=\"string\">\"select\"</span> ) ) &#123;</div><div class=\"line\">\t\t\telem.options.length = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L265\" target=\"_blank\" rel=\"external\">remove()方法源码</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span>(<span class=\"params\"> elem, selector, keepData </span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> node,</div><div class=\"line\">\t\telems = selector ? jQuery.filter( selector, elem ) : elem,</div><div class=\"line\">\t\ti = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> ( ; ( node = elems[ i ] ) != <span class=\"literal\">null</span>; i++ ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( !keepData &amp;&amp; node.nodeType === <span class=\"number\">1</span> ) &#123;</div><div class=\"line\">\t\t\tjQuery.cleanData( getAll( node ) );<span class=\"comment\">// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( node.parentNode ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) &#123;</div><div class=\"line\">\t\t\t\tsetGlobalEval( getAll( node, <span class=\"string\">\"script\"</span> ) );</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tnode.parentNode.removeChild( node );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> elem;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L496\" target=\"_blank\" rel=\"external\">html()方法源码</a><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">html: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> access( <span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> elem = <span class=\"keyword\">this</span>[ <span class=\"number\">0</span> ] || &#123;&#125;,</div><div class=\"line\">\t\t\ti = <span class=\"number\">0</span>,</div><div class=\"line\">\t\t\tl = <span class=\"keyword\">this</span>.length;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( value === <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> elem.nodeType === <span class=\"number\">1</span> ?</div><div class=\"line\">\t\t\t\telem.innerHTML.replace( rinlinejQuery, <span class=\"string\">\"\"</span> ) :</div><div class=\"line\">\t\t\t\t<span class=\"literal\">undefined</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// See if we can take a shortcut and just use innerHTML</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"string\"</span> &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;</div><div class=\"line\">\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &amp;&amp;</div><div class=\"line\">\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp;</div><div class=\"line\">\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span> ] )[ <span class=\"number\">1</span> ].toLowerCase() ] ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tvalue = jQuery.htmlPrefilter( value );</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> ( ; i &lt; l; i++ ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// Remove element nodes and prevent memory leaks</span></div><div class=\"line\">           <span class=\"comment\">// 删除元素节点并阻止内存泄露</span></div><div class=\"line\">\t\t\t\t\telem = <span class=\"keyword\">this</span>[ i ] || &#123;&#125;;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> ) &#123;</div><div class=\"line\">\t\t\t\t\t\tjQuery.cleanData( getAll( elem, <span class=\"literal\">false</span> ) );<span class=\"comment\">// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用</span></div><div class=\"line\">\t\t\t\t\t\telem.innerHTML = value;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\telem = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"comment\">// If using innerHTML throws an exception, use the fallback method</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> ( e ) &#123;&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( elem ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.empty().append( value );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;, <span class=\"literal\">null</span>, value, <span class=\"built_in\">arguments</span>.length );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在-cache中？\"><a href=\"#为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在-cache中？\" class=\"headerlink\" title=\"为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在$.cache中？\"></a>为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在$.cache中？</h2><p>因为在IE&lt;8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。即JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用（循环引用），从而导致内存泄露。为了避免在低版本IE和Firefox中内存泄露，jQuery创建了<code>$.cache</code>来解决这个问题。更多信息参考<a href=\"http://123fe.cn/2017/11/10/IE-8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/\" target=\"_blank\" rel=\"external\">IE&lt;8循环引用导致的内存泄露</a>。</p>\n<blockquote>\n<p> jQuery 2.0 leaves behind the older Internet Explorer 6, 7, and 8 browsers. In return it is smaller, faster, and can be used in JavaScript environments where the code needed for old-IE compatibility often causes problems of its own. But don’t worry, the jQuery team still supports the 1.x branch which does run on IE 6/7/8. You can (and should) continue to use jQuery 1.9 (and the upcoming 1.10) on web sites that need to accommodate older browsers. The final 2.0.0 file is 12 percent smaller than the 1.9.1 file, thanks to the elimination of patches that were only needed for IE 6, 7, and 8. —-<a href=\"http://blog.jquery.com/2013/04/18/jquery-2-0-released/\" target=\"_blank\" rel=\"external\">jQuery 2.0 Released</a></p>\n</blockquote>\n<p><strong>大概意思</strong>：<u>jQuery2.0版本之后，jQuery团队同时维护两个分支：2.x版本和1.x版本。jQuery2.0开始放弃IE6/7/8支持(注：也包含3.x版本)。而jQuery1.x版本会继续支持IE6/7/8。因为2.x版本删除了IE6/7/8补丁代码，整体大小比1.x版本小12%，性能更好。</u></p>\n<p>即从jQuery2.0开始不支持IE6/7/8，就不存在循环引用的问题，因此$.cache也从jQuery2.x版本中移除。jQuery2.0开始将事件信息存储存储在元素节点上，这样就不存在上述的内存泄露问题了。</p>\n<h2 id=\"对比测试\"><a href=\"#对比测试\" class=\"headerlink\" title=\"对比测试\"></a>对比测试</h2><p>分别使用jquery1.x和jquery2.x版本创建一个1000个元素并绑定click事件，创建完后再通过JavaScript删除方法移除，并通过<strong>Devtools</strong>–&gt;<strong>Performance</strong>做分析，操作步骤如下：</p>\n<ol>\n<li>开启<strong>Performance</strong>项的记录</li>\n<li>执行一次CG，创建基本参考线</li>\n<li>单击【run】按钮，创建1000个元素</li>\n<li>再次单击【run】按钮，创建1000个元素</li>\n<li>单击【clear】按钮，通过JavaScript删除方法移除刚创建2000个元素</li>\n<li>执行一次CG</li>\n</ol>\n<p>结果图如下：</p>\n<p><img src=\"./jquery1_x.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"./jquery2_x.png\" alt=\"\"></p>\n<p><strong>从对比结果图证实了jquery2.x将事件信息存储在元素对象上。这里也可以分别打印<code>$.cache</code>，对比一下输出结果：</strong></p>\n<p><img src=\"./jquery_cache_1_x.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"./jquery_cache_2_x.png\" alt=\"\"></p>\n<p>这里没有讨论jquery3.x版本，因为它与jquery2.x版本一样不支持低版本IE，也不存在<code>$.cache</code>问题，所以不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要讨论了jquery的<code>$.cache</code>引起的内存泄露问题。在使用jquery1.x版本时，需要关注一下这一问题。如jquery.lazyload.js和单页应用都很容易引起这方面的问题。如何避免呢？本文也提到了，通过jquery的删除方法来移除:<code>remove()</code>,<code>empty()</code>,<code>html()</code>。<strong>在使用第三方库时一定要记住：通过任何第三方库创建的对象，最好通过该库提供的删除方法来删除。</strong></p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"https://makandracards.com/makandra/31325-how-to-create-memory-leaks-in-jquery\" target=\"_blank\" rel=\"external\">How to create memory leaks in jQuery</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9304768/what-is-the-purpose-of-cache-in-jquery\" target=\"_blank\" rel=\"external\">What is the purpose of $.cache in jQuery?</a></li>\n<li><a href=\"http://www.crockford.com/javascript/memory/leak.html\" target=\"_blank\" rel=\"external\">JScript Memory Leaks</a></li>\n<li><a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/\" target=\"_blank\" rel=\"external\">Memory Leaks in Microsoft Internet Explorer</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"./jquery.jpg\" alt=\"jquery.jpg\"></p>\n<p>jQuery没有将事件和数据绑定在DOM节点上，而是将这些信息储存在<code>$.cache</code>对象上。jQuery对象每次新增事件或数据时，都在<code>$.cache</code>新增一条数据。而<code>$.cache</code>会持有对应DOM节点的引用，如果没有正确删除DOM节点，会导致DOM节点不能被回收。即DOM节点已从DOM中删除，但依然还存在内存中，没有被CG回收。正确的删除方式是通过jQuery的删除方法来移除：<code>remove()</code>,<code>empty()</code>,<code>html()</code>;</p>\n<h4 id=\"上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\"><a href=\"#上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\" class=\"headerlink\" title=\"上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。\"></a>上述提到不正确的删除方式，会导致DOM节点不能被回收，而导致内存泄露问题。如使用JavaScript内置方法（如removeChild，innerHTML）来删除jQuery绑定了事件或数据的节点。</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $element = $(<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">$element.on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;);</div><div class=\"line\">$element.appendTo(<span class=\"built_in\">document</span>.body); </div><div class=\"line\"><span class=\"keyword\">var</span> nativeElement = $element.get(<span class=\"number\">0</span>);</div><div class=\"line\"><span class=\"built_in\">document</span>.body.removeChild(nativeElement); <span class=\"comment\">// ← 通过removeChild方法移除nativeElement</span></div></pre></td></tr></table></figure>\n<p>上述代码中使用内置的removeChild方法移除nativeElement，此时仅仅只是将nativeElement与DOM脱离而已，并没有真正地删除nativeElement。原因是$element绑定了事件，<code>$.cache</code>中持有对$element引用，导致nativeElement不能被回收掉。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> $element = $(<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">$element.on(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; ... &#125;);<span class=\"comment\">// ← 绑定事件</span></div><div class=\"line\">$element.appendTo(<span class=\"built_in\">document</span>.body);</div><div class=\"line\"><span class=\"built_in\">document</span>.body.innerHTML = <span class=\"string\">''</span>;<span class=\"comment\">// ← 通过innerHTML方法移除body内的节点</span></div></pre></td></tr></table></figure>\n<p>innerHTML方法也存在同样的问题。</p>\n<h4 id=\"上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\"><a href=\"#上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\" class=\"headerlink\" title=\"上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：\"></a>上述实例都是绑定事件的，接下来看看绑定数据的例子：假如通过jQuery创建一个DOM元素，并设置一个data，但没有将其添加到DOM中。代码如下：</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$element = $(<span class=\"string\">'&lt;div&gt;&lt;/div&gt;'</span>);</div><div class=\"line\">$element.data(<span class=\"string\">'foo'</span>, <span class=\"string\">'bar'</span>);</div></pre></td></tr></table></figure>\n<p>即使代码执行完，$element也不能被回收。这是因为$.cahce阻止CG的回收。需要通过<code>$element.remove()</code>,<code>$element.parent.empty()</code>或<code>$elememnt.removeData()</code>;</p>\n<h2 id=\"为什么remove-empty-html-能正确移除DOM节点\"><a href=\"#为什么remove-empty-html-能正确移除DOM节点\" class=\"headerlink\" title=\"为什么remove(),empty(),html()能正确移除DOM节点\"></a>为什么<code>remove()</code>,<code>empty()</code>,<code>html()</code>能正确移除DOM节点</h2><p>因为它们都会调用<code>jQuery.cleanData()</code>方法来删除<code>$.cache</code>缓存的对应数据，然后在调用JavaScript内置删除方法来移除DOM节点。</p>\n<p><a href=\"https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L461\" target=\"_blank\" rel=\"external\">empty()方法源码</a>：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">empty: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> elem,</div><div class=\"line\">\t\ti = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> ( ; ( elem = <span class=\"keyword\">this</span>[ i ] ) != <span class=\"literal\">null</span>; i++ ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Remove element nodes and prevent memory leaks </span></div><div class=\"line\">     <span class=\"comment\">// 删除元素节点并阻止内存泄露</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> ) &#123;</div><div class=\"line\">\t\t\tjQuery.cleanData( getAll( elem, <span class=\"literal\">false</span> ) );<span class=\"comment\">// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// Remove any remaining nodes</span></div><div class=\"line\">\t\t<span class=\"keyword\">while</span> ( elem.firstChild ) &#123;</div><div class=\"line\">\t\t\telem.removeChild( elem.firstChild );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// If this is a select, ensure that it displays empty (#12336)</span></div><div class=\"line\">\t\t<span class=\"comment\">// Support: IE&lt;9</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( elem.options &amp;&amp; jQuery.nodeName( elem, <span class=\"string\">\"select\"</span> ) ) &#123;</div><div class=\"line\">\t\t\telem.options.length = <span class=\"number\">0</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L265\" target=\"_blank\" rel=\"external\">remove()方法源码</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span>(<span class=\"params\"> elem, selector, keepData </span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> node,</div><div class=\"line\">\t\telems = selector ? jQuery.filter( selector, elem ) : elem,</div><div class=\"line\">\t\ti = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">for</span> ( ; ( node = elems[ i ] ) != <span class=\"literal\">null</span>; i++ ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( !keepData &amp;&amp; node.nodeType === <span class=\"number\">1</span> ) &#123;</div><div class=\"line\">\t\t\tjQuery.cleanData( getAll( node ) );<span class=\"comment\">// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用</span></div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( node.parentNode ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">if</span> ( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) &#123;</div><div class=\"line\">\t\t\t\tsetGlobalEval( getAll( node, <span class=\"string\">\"script\"</span> ) );</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\tnode.parentNode.removeChild( node );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"keyword\">return</span> elem;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/jquery/jquery/blob/1.12-stable/src/manipulation.js#L496\" target=\"_blank\" rel=\"external\">html()方法源码</a><br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">html: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> access( <span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>) </span>&#123;</div><div class=\"line\">\t\t<span class=\"keyword\">var</span> elem = <span class=\"keyword\">this</span>[ <span class=\"number\">0</span> ] || &#123;&#125;,</div><div class=\"line\">\t\t\ti = <span class=\"number\">0</span>,</div><div class=\"line\">\t\t\tl = <span class=\"keyword\">this</span>.length;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( value === <span class=\"literal\">undefined</span> ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">return</span> elem.nodeType === <span class=\"number\">1</span> ?</div><div class=\"line\">\t\t\t\telem.innerHTML.replace( rinlinejQuery, <span class=\"string\">\"\"</span> ) :</div><div class=\"line\">\t\t\t\t<span class=\"literal\">undefined</span>;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"comment\">// See if we can take a shortcut and just use innerHTML</span></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( <span class=\"keyword\">typeof</span> value === <span class=\"string\">\"string\"</span> &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;</div><div class=\"line\">\t\t\t( support.htmlSerialize || !rnoshimcache.test( value )  ) &amp;&amp;</div><div class=\"line\">\t\t\t( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp;</div><div class=\"line\">\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ <span class=\"string\">\"\"</span>, <span class=\"string\">\"\"</span> ] )[ <span class=\"number\">1</span> ].toLowerCase() ] ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tvalue = jQuery.htmlPrefilter( value );</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"keyword\">try</span> &#123;</div><div class=\"line\">\t\t\t\t<span class=\"keyword\">for</span> ( ; i &lt; l; i++ ) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\t<span class=\"comment\">// Remove element nodes and prevent memory leaks</span></div><div class=\"line\">           <span class=\"comment\">// 删除元素节点并阻止内存泄露</span></div><div class=\"line\">\t\t\t\t\telem = <span class=\"keyword\">this</span>[ i ] || &#123;&#125;;</div><div class=\"line\">\t\t\t\t\t<span class=\"keyword\">if</span> ( elem.nodeType === <span class=\"number\">1</span> ) &#123;</div><div class=\"line\">\t\t\t\t\t\tjQuery.cleanData( getAll( elem, <span class=\"literal\">false</span> ) );<span class=\"comment\">// ← 清除elem在$.cache中的数据，释放掉$.cache对elem的引用</span></div><div class=\"line\">\t\t\t\t\t\telem.innerHTML = value;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\telem = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">\t\t\t<span class=\"comment\">// If using innerHTML throws an exception, use the fallback method</span></div><div class=\"line\">\t\t\t&#125; <span class=\"keyword\">catch</span> ( e ) &#123;&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t<span class=\"keyword\">if</span> ( elem ) &#123;</div><div class=\"line\">\t\t\t<span class=\"keyword\">this</span>.empty().append( value );</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;, <span class=\"literal\">null</span>, value, <span class=\"built_in\">arguments</span>.length );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在-cache中？\"><a href=\"#为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在-cache中？\" class=\"headerlink\" title=\"为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在$.cache中？\"></a>为什么jQuery没有将事件信息存储在DOM元素上，而是将其保存在$.cache中？</h2><p>因为在IE&lt;8版本中，JScript垃圾回收器仅管理JScript对象生命周期而不会管理DOM对象的(即DOM对象有自己的垃圾回收器)。即JScript回收器不会解除掉DOM对象与Jscript对象之间的相互引用（循环引用），从而导致内存泄露。为了避免在低版本IE和Firefox中内存泄露，jQuery创建了<code>$.cache</code>来解决这个问题。更多信息参考<a href=\"http://123fe.cn/2017/11/10/IE-8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/\" target=\"_blank\" rel=\"external\">IE&lt;8循环引用导致的内存泄露</a>。</p>\n<blockquote>\n<p> jQuery 2.0 leaves behind the older Internet Explorer 6, 7, and 8 browsers. In return it is smaller, faster, and can be used in JavaScript environments where the code needed for old-IE compatibility often causes problems of its own. But don’t worry, the jQuery team still supports the 1.x branch which does run on IE 6/7/8. You can (and should) continue to use jQuery 1.9 (and the upcoming 1.10) on web sites that need to accommodate older browsers. The final 2.0.0 file is 12 percent smaller than the 1.9.1 file, thanks to the elimination of patches that were only needed for IE 6, 7, and 8. —-<a href=\"http://blog.jquery.com/2013/04/18/jquery-2-0-released/\" target=\"_blank\" rel=\"external\">jQuery 2.0 Released</a></p>\n</blockquote>\n<p><strong>大概意思</strong>：<u>jQuery2.0版本之后，jQuery团队同时维护两个分支：2.x版本和1.x版本。jQuery2.0开始放弃IE6/7/8支持(注：也包含3.x版本)。而jQuery1.x版本会继续支持IE6/7/8。因为2.x版本删除了IE6/7/8补丁代码，整体大小比1.x版本小12%，性能更好。</u></p>\n<p>即从jQuery2.0开始不支持IE6/7/8，就不存在循环引用的问题，因此$.cache也从jQuery2.x版本中移除。jQuery2.0开始将事件信息存储存储在元素节点上，这样就不存在上述的内存泄露问题了。</p>\n<h2 id=\"对比测试\"><a href=\"#对比测试\" class=\"headerlink\" title=\"对比测试\"></a>对比测试</h2><p>分别使用jquery1.x和jquery2.x版本创建一个1000个元素并绑定click事件，创建完后再通过JavaScript删除方法移除，并通过<strong>Devtools</strong>–&gt;<strong>Performance</strong>做分析，操作步骤如下：</p>\n<ol>\n<li>开启<strong>Performance</strong>项的记录</li>\n<li>执行一次CG，创建基本参考线</li>\n<li>单击【run】按钮，创建1000个元素</li>\n<li>再次单击【run】按钮，创建1000个元素</li>\n<li>单击【clear】按钮，通过JavaScript删除方法移除刚创建2000个元素</li>\n<li>执行一次CG</li>\n</ol>\n<p>结果图如下：</p>\n<p><img src=\"./jquery1_x.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"./jquery2_x.png\" alt=\"\"></p>\n<p><strong>从对比结果图证实了jquery2.x将事件信息存储在元素对象上。这里也可以分别打印<code>$.cache</code>，对比一下输出结果：</strong></p>\n<p><img src=\"./jquery_cache_1_x.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"./jquery_cache_2_x.png\" alt=\"\"></p>\n<p>这里没有讨论jquery3.x版本，因为它与jquery2.x版本一样不支持低版本IE，也不存在<code>$.cache</code>问题，所以不再赘述。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要讨论了jquery的<code>$.cache</code>引起的内存泄露问题。在使用jquery1.x版本时，需要关注一下这一问题。如jquery.lazyload.js和单页应用都很容易引起这方面的问题。如何避免呢？本文也提到了，通过jquery的删除方法来移除:<code>remove()</code>,<code>empty()</code>,<code>html()</code>。<strong>在使用第三方库时一定要记住：通过任何第三方库创建的对象，最好通过该库提供的删除方法来删除。</strong></p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"https://makandracards.com/makandra/31325-how-to-create-memory-leaks-in-jquery\" target=\"_blank\" rel=\"external\">How to create memory leaks in jQuery</a></li>\n<li><a href=\"https://stackoverflow.com/questions/9304768/what-is-the-purpose-of-cache-in-jquery\" target=\"_blank\" rel=\"external\">What is the purpose of $.cache in jQuery?</a></li>\n<li><a href=\"http://www.crockford.com/javascript/memory/leak.html\" target=\"_blank\" rel=\"external\">JScript Memory Leaks</a></li>\n<li><a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/\" target=\"_blank\" rel=\"external\">Memory Leaks in Microsoft Internet Explorer</a></li>\n</ul>\n"},{"title":"浏览器渲染简述","date":"2017-11-21T08:05:04.000Z","author":"singsong","_content":"\n要编写高性能的网站和应用，除了确保编写的代码能高效地运行外，还需要了解浏览器是如何进行渲染工作的。\n\n## 浏览器主要组成结构\n\n![](https://skmukhiya.files.wordpress.com/2013/06/fb76d-layers-pagespeed-ce-mfe5f8ctav.png)\n\n1. 用户界面(User Interface)：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n2. 浏览器引擎(Browser engine)：在用户界面(User Interface)和渲染引擎(Rendering engine)之间传送指令。\n3. 渲染引擎(Rendering engine)：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。\n4. 网络(Networking)：用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。\n5. JavaScript解释器(JavaScript Interperter)：用于解析和执行JavaScript代码。\n6. 用户界面后端(UI Backend)：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n7. 数据存储(Data storage)：这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookies。浏览器还支持诸如localStorage，IndexedDB，WebSQL和FileSystem之类的存储机制。\n\n\n ## 文档对象模型(DOM：Document Object Model）\n本文主要介绍浏览器的渲染，即渲染引擎(Rendering engine)负责的工作: 将请求的HTML内容解析并渲染在屏幕上。\n如下HTML结构，一个包含一些文本和一张图片：\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <link href=\"style.css\" rel=\"stylesheet\">\n    <title>Critical Path</title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"awesome-photo.jpg\"></div>\n  </body>\n</html>\n```\n浏览器是如何处理这个HTML页面：\n\n\b![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)\n\n1. 转换(Conversion)：浏览器从磁盘或网络读取HTML的原始字节码，并根据文件的指定编码（例如 UTF-8）将它们转换成对应的字符。\n2. 令牌化(Tokenizing)：浏览器将字符串转换成[W3C HTML5标准](http://www.w3.org/TR/html5/)规定的各种令牌，例如`<html>`、`<body>`，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。\n3. 词法分析(Lexing)：发出的令牌转换成定义其属性和规则的“对象”。\n4. DOM构建(DOM construction)：HTML标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML对象是body对象的父项，body是paragraph对象的父项，依此类推。\n\n整个过程的最终输出是HTML页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。浏览器每次处理HTML标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建DOM树。DOM树捕获文档标记的属性和关系，但并未处理元素在渲染后呈现的外观。那是CSSOM的责任。\n\n\n## CSS对象模型(CSSOM：CSS Object Model)\n\n在浏览器构建DOM遇到link标记时，该标记引用一个外部CSS样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：\n\n```CSS\nbody { font-size: 16px }\np { font-weight: bold }\nspan { color: red }\np span { display: none }\nimg { float: right }\n```\n\n与处理HTML时类似，需要将收到的CSS规则转换成某种浏览器能够理解和处理的东西。因此会重复HTML过程，不过是为CSS而不是HTML：\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png?hl=zh-cn)\n\nCSS字节转换成字符，接着转换成令牌和节点，最后链接到CSSOM树结构内：\n\n\n![https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)\n\nCSSOM为何具有树结构？用于确定节点对象的计算样式。如span标记包含了`color:red`样式和继承于body标记的`font-size:16px`样式;\n\n<u>注意：以上树并非完整的CSSOM树，它只是替代默认样式的自定义样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即不提供任何自定义样式时所看到的样式，自定义样式只是替换这些默认样式</u>\n\n\nCSSOM是在DOM中的一些接口中，加入获取和操作CSS属性或接口的JavaScript接口，因而JavaScript可以动态操作CSS样式。DOM提供了接口让JavaScript修改HTML文档，CSSOM提供了接口让JavaScript获得和修改CSS代码设置的样式信息。\n\n\n\n## 渲染树(RenderObject tree，也称为Render tree)\n在DOM树中，存在不可见与可见节点之分。顾名思义，不可见节点是不需要绘制最终页面中的节点，如`meta`、`head`、`script`等，以及通过CSS样式`display:none`隐藏的节点。相反可见节点是用户可见的，如`body`、`div`、`span`、`canvas`、`img`等。\n对于这些可见节点，浏览器需要将它们的内容绘制到最终的页面中，所以浏览器会为它们建立对应的RenderObject对象。一个RenderObject对象保存了为绘制DOM节点的各种信息。这些RenderObject对象与DOM对象类似，也构成一棵树，称为**RenderObject tree**。RenderObject树是基于DOM树建立起来的一棵新树，是为了布局计算和渲染等机制而构建的一种新的内部表示。RenderObject树节点与DOM树节点不是一一对应关系。因为创建一个RenderObject对象需要满足如下规则：\n- DOM树的document节点\n- DOM树中的可见节点，如`html`、`body`、`div`等。而浏览器不会为不可见节点创建RenderObject节点。\n- 某些情况下浏览器需要创建匿名的RenderObject节点，该节点不对应DOM树中的任何节点。\n\nRenderObject对象构成了RenderObject树，每个RenderObject对象保存了为绘制DOM节点的计算样式。RenderObject树也可以理解成由CSSOM树和DOM树合并成：\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=zh-cn)\n\n## 布局(loayout)\n\n当浏览器创建RenderObject对象之后，每个对象并不知道自己在设备视口内的位置、大小等信息。浏览器根据[盒模型(Box-model)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model)来计算它们的位置、大小等信息的过程称为布局计算（重排）。\n布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的孩子节点的位置、大小等信息。为了计算节点在页面中的确切大小和位置，浏览器会从RenderObject树的根节点开始进行遍历。\n\n实例：\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>Critial Path: Hello world!</title>\n  </head>\n  <body>\n    <div style=\"width: 50%\">\n      <div style=\"width: 50%\">Hello world!</div>\n    </div>\n  </body>\n</html>\n```\n页面包含了两个嵌套div：父div将其的显示尺寸设置为视口宽度的50%，子div将其宽度设置为其父项的50%，即视口宽度的25%。\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-viewport.png?hl=zh-cn)\n\n## RenderLayer树(RenderLayer tree)\n\n浏览器渲染引擎并不是直接使用RenderObject树进行绘制，为了方便处理Positioning(定位)，Clipping(裁剪)，Overflow-scroll(页內滚动)，CSS Transform/Opacity/Animation/Filter，Mask or Reflection，Z-indexing(Z排序)等，浏览器需要会为一些特定的RenderObject生成对应的RenderLayer，并生成一棵对应的RenderLayer树。而这些特定的RenderObject跟对应的RenderLayer就是直属的关系，如果它们的子节点如果没有对应的RenderLayer，就从属于父节点的RenderLayer。最终，每一个RenderObject都会直接或者间接地从属于一个RenderLayer。因此RenderObject节点与RenderLayer节点不是一一对应关系，而是一对多的关系。那需要满足什么条件，渲染引擎才为RenderObject建立对应的RenderLayer：\n\n* It's the root object for the page\n* It has explicit CSS position properties (relative, absolute or a transform)\n* It is transparent\n* Has overflow, an alpha mask or reflection\n* Has a CSS filter\n* Corresponds to `<canvas>` element that has a 3D (WebGL) context or an accelerated 2D context\n* Corresponds to a `<video>` element\n\n翻译：\n* DOM树的Document节点对应的RenderObject节点和HTML节点对应的RenderObject节点\n* 显式指定CSS position属性的RenderObject节点\n* 有透明度的RenderObject节点\n* 有overflow，alpha和reflection的样式RenderObject节点\n* 有filter样式的RenderObject节点\n* 使用Canvas 2D和3D(WebGL)技术的RenderObject节点\n* video元素对应的RenderObject节点\n\n每个RenderLayer对象可以想象成图像中一个图层，各个图层叠加构成了一个图像。浏览器会遍历RenderLayer树，再遍历从属这个RenderLayer的RenderObject，RenderObject对象存储有绘制信息，并进行绘制。RenderLayer和RenderObject共同决定了最终呈现的网页内容，RenderLayer树决定了网页的绘制的层次顺序，而从属于RenderLayer的RenderObject决定了该RenderLayer的内容。\n\n## 渲染方式\n在完成构建RenderLayer树之后，浏览器会使用图形库将其构建的渲染模型绘制出来，该过程分为两个阶段：\n- 绘制：将从属每个RenderLayer图层上的RenderObject绘制在其RenderLayer上。即绘制（Paint）或者光栅化（Rasterization），将一些绘图指令转换成真正的像素颜色值。\n  - 软件绘图：CPU来完成绘图操作\n  - 硬件加速绘图：GPU来完成绘图操作\n- 合成(compositing)：将各个RenderLayer图层合并成到一个位图(Bitmap)中。同时还可能包括位移（Translation），缩放（Scale），旋转（Rotation），Alpha 合成等操作。\n\n\n渲染引擎的渲染，目前有三种网页的渲染方式：\n\n> - 硬件加速合成(Accelerated Compositing)：使用GPU来完成合成工作。\n> - 合成化渲染：使用合成(compositing)技术的渲染称。\n\n- 软件渲染方式：使用CPU来绘制每个RenderLayer图层的内容(RenderObject)到一个位图，即一块CPU使用的内存空间。绘制每一层的时候都会使用该位图，区别在于绘制的位置可能不一样，绘制顺序按照从后到前。因此软件渲染机制是没有合成阶段的。\n- 硬件加速渲染的合成化渲染方式：使用GPU来绘制所有合成层，并使用GPU硬件来加速合成。\n- 软件绘图的合成化渲染方式： 某些合成层使用CPU来绘图，另外一些使用GPU来绘制。对于使用CPU来绘制的图层，该层的绘制结果会先保存在CPU内存中，之后会被传输到GPU内存中，然后再使用GPU来完成合成工作。\n\n\n![](./render.png)\n\n第二种和第三种渲染方式，都是使用了合成化渲染技术，合成工作也都是由GPU来做。对于常见的2D绘图操作，使用GPU来绘图不一定比使用CPU绘图在性能上有优势，例如绘制文字、点、线等，原因是CPU的使用缓冲机制有效减少了重复绘制的开销而且不需要考虑与GPU并行。另外，GPU的内存资源相对CPU的内存资源来说比较紧张，而且网页的分层使得GPU的内存使用相对比较多。鉴于此，就目前的情况来看，三者都存在是有其合理性的，下面分析一下它们的特点：\n\n\n- 软件渲染是目前很常见的技术，也是浏览器最早使用的渲染方式。这一技术比较节省内存，特别是宝贵的GPU内存，但是软件渲染只能处理2D方面的操作。简单的网页没有复杂绘图或者多媒体方面的需求，软件渲染方式就比较合适来渲染该类型的网页。问题是，一旦遇上了HTML5的很多新技术，软件渲染显得无能为力，一是因为能力不足；二是因为性能不好，例如视频、Canvas 2D等。所以，软件渲染技术被用的越来越少，特别是在移动领域。软件渲染同硬件加速渲染另外一个很不同的地方就是对更新区域的处理。当网页中有一个更新小型区域的请求（如动画）时，软件渲染可能只需要计算一个极小的区域，而硬件渲染可能需要重新绘制其中的一层或者多层，然后再合成这些层。硬件渲染的代价可能会大得多。\n- 对于硬件加速的合成化渲染方式来说，每个层的绘制和所有层的合成均使用GPU硬件来完成，这对需要使用3D绘图的操作来说特别合适。这种方式下，在RenderLayer树之后，浏览器还需要建立更多的内部表示，目的是支持硬件加速机制，这显然会消耗更多的内存资源。但是，一方面，硬件加速机制能够支持现在所有的HTML5定义的2D或者3D绘图标准；另一方面，关于更新区域的讨论，如果需要更新某个层的一个区域，因为软件渲染没有为每一层提供后端存储，因而它需要将和这个区域有重叠部分的所有层次的相关区域一次从后往前重新绘制一遍，而硬件加速渲染只需要重新绘制更新发生的层次，因而在某些情况下，软件渲染的代价又变得更大。当然，这取决于网页的结构和渲染策略。\n- 软件绘图的合成化渲染方式结合了前面两种方式的优点，这时因为很多网页可能既包含基本的HTML元素，也包含一些HTML5新功能，使用CPU绘图方式来绘制某些层，使用GPU来绘制其他一些层。原因当然是前面所述的基于性能和内存方面综合考虑的结果。\n\n\n> 浏览器还可以使用多线程的渲染架构，将网页内容绘制到后端存储的操作放到另外一个独立的线程（绘制线程），而原来线程转为合成线程，绘制线程跟合成线程之间可以使用同步，部分同步，完全异步等作业模式，让浏览器可以在性能与效果之间根据需要进行选择。\n\n## GrphicsLayer tree(GrphicsLayer树)\n\n对于软件渲染而言，到RenderLayer树就结束了，后面不会建立其它额外的树来对应于RenderLayer树。但是，对于硬件渲染来说，在RenderLayer树之后，浏览器渲染引擎为硬件渲染提供了更多的内部结构来支持这个机制。\n\n在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，一个RenderLayer对象如果需要后端存储，它会创建一个RenderLayerBacking对象，该对象负责Renderlayer对象所需要的各种存储，理想情况下，每个RenderLayer都可以创建自己的后端存储，事实上不是所有RenderLayer都有自己的RenderLayerBacking对象。如果一个RenderLayer对象被像样的创建后端存储，那么将该RenderLayer称为合成层（Compositing Layer）。\n\n哪些RenderLayer对象可以是合成层？如果一个RenderLayer对象具有以下的特征之一，那么它就是合成层：\n\n* Layer has 3D or perspective transform CSS properties\n* Layer is used by < video> element using accelerated video decoding\n* Layer is used by a < canvas> element with a 3D context or accelerated 2D context\n* Layer is used for a composited plugin\n* Layer uses a CSS animation for its opacity or uses an animated webkit transform\n* Layer uses accelerated CSS filters\n* Layer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection\n* Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)\n\n翻译:\n\n* RenderLayer具有3D或透视转换的CSS属性\n* RenderLayer包含使用硬件加速的视频解码技术的`<video>`元素\n* RenderLayer包含使用硬件加速的2D或WebGL-3D技术的`<canvas>`元素\n* RenderLayer使用了合成插件。\n* RenderLayer使用了`opacity`或`transform`动画\n* RenderLayer使用了硬件加速的CSS Filters技术\n* RenderLayer后代中包含了一个合成层（如有clip或reflection属性）\n* RenderLayer有个一个z-index比自己小的合成层（即在一个合成层之上）\n\n每个合成层都有一个RenderLayerBacking，RenderLayerBacking负责管理RenderLayer所需要的所有后端存储，因为后端存储可能需要多个存储空间。在浏览器(WebKit)中，存储空间使用类GraphicsLayer来表示。浏览器会为这些RenderLayer创建对应的GraphicsLayer，不同的浏览器需要提供自己的GrphicsLayer实现用于管理存储空间的分配，释放，更新等等。拥有GrphicsLayer的RenderLayer会被绘制到自己的后端存储，而没有GrphicsLayer的RenderLayer它们会向上追溯有GrphicsLayer的父/祖先RenderLayer，直到Root RenderLayer为止，然后绘制在有GrphicsLayer的父/祖先RenderLayer的存储空间，而Root RenderLayer总是会创建一个GrphicsLayer并拥有自己独立的存储空间。在将每个合成图层包含的RenderLayer内容绘制在合成层的后端存储中，这里绘制可以是软件绘制或硬件绘制。接着由合成器(Compositor)将多个合成层合成起来，形成最终用户可见的网页，实际上就是一张图片。\n\nGraphicsLayer又构成了一棵与RenderLayer并行的树，而RenderLayer与GraphicsLayer的关系有些类似于RenderObject与RenderLayer之间的关系。如下是DOM树、RenderObject树、RenderLayer树、GraphicsLayer树关系图：\n\n![](http://www.chromium.org/_/rsrc/1479245083354/developers/design-documents/gpu-accelerated-compositing-in-chrome/the_compositing_forest.png)\n\n\n这样可以合并一些RenderLayer层，从而减少内存的消耗。其次，合并之后，减少了合并带来的重绘性能和处理上的困难。\n在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，RenderLayer的内容变化，只需要更新所属的GraphicsLayer的缓存即可，而缓存的更新，也只需要绘制直接或者间接属于这个GraphicsLayer的RenderLayer，而不是所有的RenderLayer。特别是一些特定的CSS样式属性的变化，实际上并不引起内容的变化，只需要改变一些GraphicsLayer的混合参数，然后重新混合即可，而混合相对绘制而言是很快的，这些特定的CSS样式属性我们一般称之为是被加速的，不同的浏览器支持的状况不太一样，但基本上CSS Transform & Opacity在所有支持混合加速的浏览器上都是被加速的。被加速的CSS样式属性的动画，就比较容易达到60帧/每秒的流畅效果了。\n\n![](http://img.blog.csdn.net/20140416142656281)\n\n不过并不是拥有独立缓存的RenderLayer越多越好，太多拥有独立缓存的RenderLayer会带来一些严重的副作用:\n - 它大大增加了内存的开销，这点在移动设备上的影响更大，甚至导致浏览器在一些内存较少的移动设备上无法很好地支持图层合成加速；\n - 它加大了合成的时间开销，导致合成性能的下降，而合成性能跟网页滚动/缩放操作的流畅度又息息相关，最终导致网页滚动/缩放的流畅度下降，让用户觉得操作不够流畅。\n\n## Tile Rendering(瓦片渲染)\n\n通常一个合成层的后端存储被分割成多个大小相同的瓦片状的小存储空间，每个瓦片可以理解为OpenGL中的一个纹理，合成层的结果被分开存储在这些瓦片中。为什么使用瓦片化的后端存储？\n - DOM树种的html元素所在的层可能会比较大，因为网页的高度很大，如果只是使用一个后端存储的话，那么需要一个很大的纹理对象，但是实际的GPU硬件可能只支持非常有限的纹理大小。\n - 在一个比较大的合成层中，可能只是其中一部分发生变化，根据之前的介绍，需要重新绘制整个层，这样必然产生额外的开销，使用瓦片话的后端存储，就只需要重绘一些存在更新的瓦片。\n - 当层发生滚动的时候，一些瓦片可能不再需要，然后渲染引擎需要一些新的瓦片来绘制新的区域，这些大小相同的后端存储很容易重复利用。\n\n![](./tiles.png)\n\n\n## 流畅动画\n\n网页加载后，绘制新的每一帧，一般都需要经过计算布局(layout)、绘图(paint)、合成（composite）三阶段。因此要想提高页面性能（或FPS），需要减少每一帧的时间。而在这三个阶段中，layout和paint比较耗时间，而合成需要的时间相对较少一些。\n\n#### layout\n如果修改一个DOM元素的”layout”属性，也就是改变了元素的样式（比如宽度、高度或者位置等），那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个reflow过程完成重新布局。被reflow的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面。\n![](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg)\n#### paint\n如果修改了“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。\n![](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg)\n#### composite\n如果更改了一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。\n\n![](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg)\n\n**如果想知道更改任何指定CSS属性将触发layout、paint、composite中的哪一个，请查看[CSS触发器](https://csstriggers.com/)。**\n\n#### 优化\n可以通过什么途径进行优化，减少每一帧的时间（避免过多layout或paint）：\n\n - 使用适合的网页分层技术减少layout和paint。一旦有请求更新，如果没有分层，渲染引擎可能需要重新绘制所有区域，因为计算更新部分对GPU来说可能消耗更多的时间。而网页分层之后，部分区域的更新可能只在网页的一层或几层，而不需要将整个网页重新绘制。通过重新绘制网页的一层或几层，并将它们和其他之前绘制完的层合并起来，既能使用GPU的能力，又能够减少重绘的开销。\n - 使用合成属性样式（opcity、tansform）来完成tansition或animation。当合成器合成时候，每个合成层都可以设置变形属性：位移（Translate）、缩放（Scale）、旋转（Rotation）、opacity，这些属性仅仅改变合成层的变换参数，而不需要layout和paint操作，极大地减少每一帧的渲染时间。\n\n 即使用GPU硬件加速，为某些RenderLayer创建对应GraphicsLayer。通过为每一个合成层设置变形属性来完成tansition或animation，有效地避免relayout和repaint的开销。\n\n ![](https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/cheap-operations.jpg)\n\n\n\n\n\n\n\n## 总结\n本文是由几篇关于浏览器渲染的文章组合而成，可能有些概念比较抽象，不好理解，可以查看**参考文章**小节，获取更多信息。本文重点介绍了浏览器渲染引擎的渲染过程，涉及了DOM树、CSSOM树、RenderObject树、RenderLayer树、GraphicsLayer树。并对各种渲染模式进行了简单介绍，其中引入了硬件加速机制，还给出一些优化建议。了解这些知识点对我们开发高性能的web应用会有很大的帮助。\n\n## 参考文章：\n- [GPU Accelerated Compositing in Chrome](http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome)\n- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n- [构建对象模型](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn)\n- [How Rendering Work (in WebKit and Blink)](https://rogeryi.wordpress.com/2014/04/16/how-rendering-work-in-webkit-and-blink/)\n- [WebKit技术内幕](http://blog.csdn.net/milado_nju)\n- [渲染性能](https://developers.google.com/web/fundamentals/performance/rendering/)\n- [High Performance Animations](https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/)","source":"_posts/浏览器渲染简述.md","raw":"---\ntitle: 浏览器渲染简述\ndate: 2017-11-21 16:05:04\ntags: [渲染, 优化, render, 硬件加速]\nauthor: singsong\n---\n\n要编写高性能的网站和应用，除了确保编写的代码能高效地运行外，还需要了解浏览器是如何进行渲染工作的。\n\n## 浏览器主要组成结构\n\n![](https://skmukhiya.files.wordpress.com/2013/06/fb76d-layers-pagespeed-ce-mfe5f8ctav.png)\n\n1. 用户界面(User Interface)：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。\n2. 浏览器引擎(Browser engine)：在用户界面(User Interface)和渲染引擎(Rendering engine)之间传送指令。\n3. 渲染引擎(Rendering engine)：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。\n4. 网络(Networking)：用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。\n5. JavaScript解释器(JavaScript Interperter)：用于解析和执行JavaScript代码。\n6. 用户界面后端(UI Backend)：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。\n7. 数据存储(Data storage)：这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookies。浏览器还支持诸如localStorage，IndexedDB，WebSQL和FileSystem之类的存储机制。\n\n\n ## 文档对象模型(DOM：Document Object Model）\n本文主要介绍浏览器的渲染，即渲染引擎(Rendering engine)负责的工作: 将请求的HTML内容解析并渲染在屏幕上。\n如下HTML结构，一个包含一些文本和一张图片：\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <link href=\"style.css\" rel=\"stylesheet\">\n    <title>Critical Path</title>\n  </head>\n  <body>\n    <p>Hello <span>web performance</span> students!</p>\n    <div><img src=\"awesome-photo.jpg\"></div>\n  </body>\n</html>\n```\n浏览器是如何处理这个HTML页面：\n\n\b![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)\n\n1. 转换(Conversion)：浏览器从磁盘或网络读取HTML的原始字节码，并根据文件的指定编码（例如 UTF-8）将它们转换成对应的字符。\n2. 令牌化(Tokenizing)：浏览器将字符串转换成[W3C HTML5标准](http://www.w3.org/TR/html5/)规定的各种令牌，例如`<html>`、`<body>`，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。\n3. 词法分析(Lexing)：发出的令牌转换成定义其属性和规则的“对象”。\n4. DOM构建(DOM construction)：HTML标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML对象是body对象的父项，body是paragraph对象的父项，依此类推。\n\n整个过程的最终输出是HTML页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。浏览器每次处理HTML标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建DOM树。DOM树捕获文档标记的属性和关系，但并未处理元素在渲染后呈现的外观。那是CSSOM的责任。\n\n\n## CSS对象模型(CSSOM：CSS Object Model)\n\n在浏览器构建DOM遇到link标记时，该标记引用一个外部CSS样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：\n\n```CSS\nbody { font-size: 16px }\np { font-weight: bold }\nspan { color: red }\np span { display: none }\nimg { float: right }\n```\n\n与处理HTML时类似，需要将收到的CSS规则转换成某种浏览器能够理解和处理的东西。因此会重复HTML过程，不过是为CSS而不是HTML：\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png?hl=zh-cn)\n\nCSS字节转换成字符，接着转换成令牌和节点，最后链接到CSSOM树结构内：\n\n\n![https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)\n\nCSSOM为何具有树结构？用于确定节点对象的计算样式。如span标记包含了`color:red`样式和继承于body标记的`font-size:16px`样式;\n\n<u>注意：以上树并非完整的CSSOM树，它只是替代默认样式的自定义样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即不提供任何自定义样式时所看到的样式，自定义样式只是替换这些默认样式</u>\n\n\nCSSOM是在DOM中的一些接口中，加入获取和操作CSS属性或接口的JavaScript接口，因而JavaScript可以动态操作CSS样式。DOM提供了接口让JavaScript修改HTML文档，CSSOM提供了接口让JavaScript获得和修改CSS代码设置的样式信息。\n\n\n\n## 渲染树(RenderObject tree，也称为Render tree)\n在DOM树中，存在不可见与可见节点之分。顾名思义，不可见节点是不需要绘制最终页面中的节点，如`meta`、`head`、`script`等，以及通过CSS样式`display:none`隐藏的节点。相反可见节点是用户可见的，如`body`、`div`、`span`、`canvas`、`img`等。\n对于这些可见节点，浏览器需要将它们的内容绘制到最终的页面中，所以浏览器会为它们建立对应的RenderObject对象。一个RenderObject对象保存了为绘制DOM节点的各种信息。这些RenderObject对象与DOM对象类似，也构成一棵树，称为**RenderObject tree**。RenderObject树是基于DOM树建立起来的一棵新树，是为了布局计算和渲染等机制而构建的一种新的内部表示。RenderObject树节点与DOM树节点不是一一对应关系。因为创建一个RenderObject对象需要满足如下规则：\n- DOM树的document节点\n- DOM树中的可见节点，如`html`、`body`、`div`等。而浏览器不会为不可见节点创建RenderObject节点。\n- 某些情况下浏览器需要创建匿名的RenderObject节点，该节点不对应DOM树中的任何节点。\n\nRenderObject对象构成了RenderObject树，每个RenderObject对象保存了为绘制DOM节点的计算样式。RenderObject树也可以理解成由CSSOM树和DOM树合并成：\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=zh-cn)\n\n## 布局(loayout)\n\n当浏览器创建RenderObject对象之后，每个对象并不知道自己在设备视口内的位置、大小等信息。浏览器根据[盒模型(Box-model)](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model)来计算它们的位置、大小等信息的过程称为布局计算（重排）。\n布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的孩子节点的位置、大小等信息。为了计算节点在页面中的确切大小和位置，浏览器会从RenderObject树的根节点开始进行遍历。\n\n实例：\n```html\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>Critial Path: Hello world!</title>\n  </head>\n  <body>\n    <div style=\"width: 50%\">\n      <div style=\"width: 50%\">Hello world!</div>\n    </div>\n  </body>\n</html>\n```\n页面包含了两个嵌套div：父div将其的显示尺寸设置为视口宽度的50%，子div将其宽度设置为其父项的50%，即视口宽度的25%。\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-viewport.png?hl=zh-cn)\n\n## RenderLayer树(RenderLayer tree)\n\n浏览器渲染引擎并不是直接使用RenderObject树进行绘制，为了方便处理Positioning(定位)，Clipping(裁剪)，Overflow-scroll(页內滚动)，CSS Transform/Opacity/Animation/Filter，Mask or Reflection，Z-indexing(Z排序)等，浏览器需要会为一些特定的RenderObject生成对应的RenderLayer，并生成一棵对应的RenderLayer树。而这些特定的RenderObject跟对应的RenderLayer就是直属的关系，如果它们的子节点如果没有对应的RenderLayer，就从属于父节点的RenderLayer。最终，每一个RenderObject都会直接或者间接地从属于一个RenderLayer。因此RenderObject节点与RenderLayer节点不是一一对应关系，而是一对多的关系。那需要满足什么条件，渲染引擎才为RenderObject建立对应的RenderLayer：\n\n* It's the root object for the page\n* It has explicit CSS position properties (relative, absolute or a transform)\n* It is transparent\n* Has overflow, an alpha mask or reflection\n* Has a CSS filter\n* Corresponds to `<canvas>` element that has a 3D (WebGL) context or an accelerated 2D context\n* Corresponds to a `<video>` element\n\n翻译：\n* DOM树的Document节点对应的RenderObject节点和HTML节点对应的RenderObject节点\n* 显式指定CSS position属性的RenderObject节点\n* 有透明度的RenderObject节点\n* 有overflow，alpha和reflection的样式RenderObject节点\n* 有filter样式的RenderObject节点\n* 使用Canvas 2D和3D(WebGL)技术的RenderObject节点\n* video元素对应的RenderObject节点\n\n每个RenderLayer对象可以想象成图像中一个图层，各个图层叠加构成了一个图像。浏览器会遍历RenderLayer树，再遍历从属这个RenderLayer的RenderObject，RenderObject对象存储有绘制信息，并进行绘制。RenderLayer和RenderObject共同决定了最终呈现的网页内容，RenderLayer树决定了网页的绘制的层次顺序，而从属于RenderLayer的RenderObject决定了该RenderLayer的内容。\n\n## 渲染方式\n在完成构建RenderLayer树之后，浏览器会使用图形库将其构建的渲染模型绘制出来，该过程分为两个阶段：\n- 绘制：将从属每个RenderLayer图层上的RenderObject绘制在其RenderLayer上。即绘制（Paint）或者光栅化（Rasterization），将一些绘图指令转换成真正的像素颜色值。\n  - 软件绘图：CPU来完成绘图操作\n  - 硬件加速绘图：GPU来完成绘图操作\n- 合成(compositing)：将各个RenderLayer图层合并成到一个位图(Bitmap)中。同时还可能包括位移（Translation），缩放（Scale），旋转（Rotation），Alpha 合成等操作。\n\n\n渲染引擎的渲染，目前有三种网页的渲染方式：\n\n> - 硬件加速合成(Accelerated Compositing)：使用GPU来完成合成工作。\n> - 合成化渲染：使用合成(compositing)技术的渲染称。\n\n- 软件渲染方式：使用CPU来绘制每个RenderLayer图层的内容(RenderObject)到一个位图，即一块CPU使用的内存空间。绘制每一层的时候都会使用该位图，区别在于绘制的位置可能不一样，绘制顺序按照从后到前。因此软件渲染机制是没有合成阶段的。\n- 硬件加速渲染的合成化渲染方式：使用GPU来绘制所有合成层，并使用GPU硬件来加速合成。\n- 软件绘图的合成化渲染方式： 某些合成层使用CPU来绘图，另外一些使用GPU来绘制。对于使用CPU来绘制的图层，该层的绘制结果会先保存在CPU内存中，之后会被传输到GPU内存中，然后再使用GPU来完成合成工作。\n\n\n![](./render.png)\n\n第二种和第三种渲染方式，都是使用了合成化渲染技术，合成工作也都是由GPU来做。对于常见的2D绘图操作，使用GPU来绘图不一定比使用CPU绘图在性能上有优势，例如绘制文字、点、线等，原因是CPU的使用缓冲机制有效减少了重复绘制的开销而且不需要考虑与GPU并行。另外，GPU的内存资源相对CPU的内存资源来说比较紧张，而且网页的分层使得GPU的内存使用相对比较多。鉴于此，就目前的情况来看，三者都存在是有其合理性的，下面分析一下它们的特点：\n\n\n- 软件渲染是目前很常见的技术，也是浏览器最早使用的渲染方式。这一技术比较节省内存，特别是宝贵的GPU内存，但是软件渲染只能处理2D方面的操作。简单的网页没有复杂绘图或者多媒体方面的需求，软件渲染方式就比较合适来渲染该类型的网页。问题是，一旦遇上了HTML5的很多新技术，软件渲染显得无能为力，一是因为能力不足；二是因为性能不好，例如视频、Canvas 2D等。所以，软件渲染技术被用的越来越少，特别是在移动领域。软件渲染同硬件加速渲染另外一个很不同的地方就是对更新区域的处理。当网页中有一个更新小型区域的请求（如动画）时，软件渲染可能只需要计算一个极小的区域，而硬件渲染可能需要重新绘制其中的一层或者多层，然后再合成这些层。硬件渲染的代价可能会大得多。\n- 对于硬件加速的合成化渲染方式来说，每个层的绘制和所有层的合成均使用GPU硬件来完成，这对需要使用3D绘图的操作来说特别合适。这种方式下，在RenderLayer树之后，浏览器还需要建立更多的内部表示，目的是支持硬件加速机制，这显然会消耗更多的内存资源。但是，一方面，硬件加速机制能够支持现在所有的HTML5定义的2D或者3D绘图标准；另一方面，关于更新区域的讨论，如果需要更新某个层的一个区域，因为软件渲染没有为每一层提供后端存储，因而它需要将和这个区域有重叠部分的所有层次的相关区域一次从后往前重新绘制一遍，而硬件加速渲染只需要重新绘制更新发生的层次，因而在某些情况下，软件渲染的代价又变得更大。当然，这取决于网页的结构和渲染策略。\n- 软件绘图的合成化渲染方式结合了前面两种方式的优点，这时因为很多网页可能既包含基本的HTML元素，也包含一些HTML5新功能，使用CPU绘图方式来绘制某些层，使用GPU来绘制其他一些层。原因当然是前面所述的基于性能和内存方面综合考虑的结果。\n\n\n> 浏览器还可以使用多线程的渲染架构，将网页内容绘制到后端存储的操作放到另外一个独立的线程（绘制线程），而原来线程转为合成线程，绘制线程跟合成线程之间可以使用同步，部分同步，完全异步等作业模式，让浏览器可以在性能与效果之间根据需要进行选择。\n\n## GrphicsLayer tree(GrphicsLayer树)\n\n对于软件渲染而言，到RenderLayer树就结束了，后面不会建立其它额外的树来对应于RenderLayer树。但是，对于硬件渲染来说，在RenderLayer树之后，浏览器渲染引擎为硬件渲染提供了更多的内部结构来支持这个机制。\n\n在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，一个RenderLayer对象如果需要后端存储，它会创建一个RenderLayerBacking对象，该对象负责Renderlayer对象所需要的各种存储，理想情况下，每个RenderLayer都可以创建自己的后端存储，事实上不是所有RenderLayer都有自己的RenderLayerBacking对象。如果一个RenderLayer对象被像样的创建后端存储，那么将该RenderLayer称为合成层（Compositing Layer）。\n\n哪些RenderLayer对象可以是合成层？如果一个RenderLayer对象具有以下的特征之一，那么它就是合成层：\n\n* Layer has 3D or perspective transform CSS properties\n* Layer is used by < video> element using accelerated video decoding\n* Layer is used by a < canvas> element with a 3D context or accelerated 2D context\n* Layer is used for a composited plugin\n* Layer uses a CSS animation for its opacity or uses an animated webkit transform\n* Layer uses accelerated CSS filters\n* Layer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection\n* Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)\n\n翻译:\n\n* RenderLayer具有3D或透视转换的CSS属性\n* RenderLayer包含使用硬件加速的视频解码技术的`<video>`元素\n* RenderLayer包含使用硬件加速的2D或WebGL-3D技术的`<canvas>`元素\n* RenderLayer使用了合成插件。\n* RenderLayer使用了`opacity`或`transform`动画\n* RenderLayer使用了硬件加速的CSS Filters技术\n* RenderLayer后代中包含了一个合成层（如有clip或reflection属性）\n* RenderLayer有个一个z-index比自己小的合成层（即在一个合成层之上）\n\n每个合成层都有一个RenderLayerBacking，RenderLayerBacking负责管理RenderLayer所需要的所有后端存储，因为后端存储可能需要多个存储空间。在浏览器(WebKit)中，存储空间使用类GraphicsLayer来表示。浏览器会为这些RenderLayer创建对应的GraphicsLayer，不同的浏览器需要提供自己的GrphicsLayer实现用于管理存储空间的分配，释放，更新等等。拥有GrphicsLayer的RenderLayer会被绘制到自己的后端存储，而没有GrphicsLayer的RenderLayer它们会向上追溯有GrphicsLayer的父/祖先RenderLayer，直到Root RenderLayer为止，然后绘制在有GrphicsLayer的父/祖先RenderLayer的存储空间，而Root RenderLayer总是会创建一个GrphicsLayer并拥有自己独立的存储空间。在将每个合成图层包含的RenderLayer内容绘制在合成层的后端存储中，这里绘制可以是软件绘制或硬件绘制。接着由合成器(Compositor)将多个合成层合成起来，形成最终用户可见的网页，实际上就是一张图片。\n\nGraphicsLayer又构成了一棵与RenderLayer并行的树，而RenderLayer与GraphicsLayer的关系有些类似于RenderObject与RenderLayer之间的关系。如下是DOM树、RenderObject树、RenderLayer树、GraphicsLayer树关系图：\n\n![](http://www.chromium.org/_/rsrc/1479245083354/developers/design-documents/gpu-accelerated-compositing-in-chrome/the_compositing_forest.png)\n\n\n这样可以合并一些RenderLayer层，从而减少内存的消耗。其次，合并之后，减少了合并带来的重绘性能和处理上的困难。\n在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，RenderLayer的内容变化，只需要更新所属的GraphicsLayer的缓存即可，而缓存的更新，也只需要绘制直接或者间接属于这个GraphicsLayer的RenderLayer，而不是所有的RenderLayer。特别是一些特定的CSS样式属性的变化，实际上并不引起内容的变化，只需要改变一些GraphicsLayer的混合参数，然后重新混合即可，而混合相对绘制而言是很快的，这些特定的CSS样式属性我们一般称之为是被加速的，不同的浏览器支持的状况不太一样，但基本上CSS Transform & Opacity在所有支持混合加速的浏览器上都是被加速的。被加速的CSS样式属性的动画，就比较容易达到60帧/每秒的流畅效果了。\n\n![](http://img.blog.csdn.net/20140416142656281)\n\n不过并不是拥有独立缓存的RenderLayer越多越好，太多拥有独立缓存的RenderLayer会带来一些严重的副作用:\n - 它大大增加了内存的开销，这点在移动设备上的影响更大，甚至导致浏览器在一些内存较少的移动设备上无法很好地支持图层合成加速；\n - 它加大了合成的时间开销，导致合成性能的下降，而合成性能跟网页滚动/缩放操作的流畅度又息息相关，最终导致网页滚动/缩放的流畅度下降，让用户觉得操作不够流畅。\n\n## Tile Rendering(瓦片渲染)\n\n通常一个合成层的后端存储被分割成多个大小相同的瓦片状的小存储空间，每个瓦片可以理解为OpenGL中的一个纹理，合成层的结果被分开存储在这些瓦片中。为什么使用瓦片化的后端存储？\n - DOM树种的html元素所在的层可能会比较大，因为网页的高度很大，如果只是使用一个后端存储的话，那么需要一个很大的纹理对象，但是实际的GPU硬件可能只支持非常有限的纹理大小。\n - 在一个比较大的合成层中，可能只是其中一部分发生变化，根据之前的介绍，需要重新绘制整个层，这样必然产生额外的开销，使用瓦片话的后端存储，就只需要重绘一些存在更新的瓦片。\n - 当层发生滚动的时候，一些瓦片可能不再需要，然后渲染引擎需要一些新的瓦片来绘制新的区域，这些大小相同的后端存储很容易重复利用。\n\n![](./tiles.png)\n\n\n## 流畅动画\n\n网页加载后，绘制新的每一帧，一般都需要经过计算布局(layout)、绘图(paint)、合成（composite）三阶段。因此要想提高页面性能（或FPS），需要减少每一帧的时间。而在这三个阶段中，layout和paint比较耗时间，而合成需要的时间相对较少一些。\n\n#### layout\n如果修改一个DOM元素的”layout”属性，也就是改变了元素的样式（比如宽度、高度或者位置等），那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个reflow过程完成重新布局。被reflow的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面。\n![](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg)\n#### paint\n如果修改了“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。\n![](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg)\n#### composite\n如果更改了一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。\n\n![](https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg)\n\n**如果想知道更改任何指定CSS属性将触发layout、paint、composite中的哪一个，请查看[CSS触发器](https://csstriggers.com/)。**\n\n#### 优化\n可以通过什么途径进行优化，减少每一帧的时间（避免过多layout或paint）：\n\n - 使用适合的网页分层技术减少layout和paint。一旦有请求更新，如果没有分层，渲染引擎可能需要重新绘制所有区域，因为计算更新部分对GPU来说可能消耗更多的时间。而网页分层之后，部分区域的更新可能只在网页的一层或几层，而不需要将整个网页重新绘制。通过重新绘制网页的一层或几层，并将它们和其他之前绘制完的层合并起来，既能使用GPU的能力，又能够减少重绘的开销。\n - 使用合成属性样式（opcity、tansform）来完成tansition或animation。当合成器合成时候，每个合成层都可以设置变形属性：位移（Translate）、缩放（Scale）、旋转（Rotation）、opacity，这些属性仅仅改变合成层的变换参数，而不需要layout和paint操作，极大地减少每一帧的渲染时间。\n\n 即使用GPU硬件加速，为某些RenderLayer创建对应GraphicsLayer。通过为每一个合成层设置变形属性来完成tansition或animation，有效地避免relayout和repaint的开销。\n\n ![](https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/cheap-operations.jpg)\n\n\n\n\n\n\n\n## 总结\n本文是由几篇关于浏览器渲染的文章组合而成，可能有些概念比较抽象，不好理解，可以查看**参考文章**小节，获取更多信息。本文重点介绍了浏览器渲染引擎的渲染过程，涉及了DOM树、CSSOM树、RenderObject树、RenderLayer树、GraphicsLayer树。并对各种渲染模式进行了简单介绍，其中引入了硬件加速机制，还给出一些优化建议。了解这些知识点对我们开发高性能的web应用会有很大的帮助。\n\n## 参考文章：\n- [GPU Accelerated Compositing in Chrome](http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome)\n- [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n- [构建对象模型](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn)\n- [How Rendering Work (in WebKit and Blink)](https://rogeryi.wordpress.com/2014/04/16/how-rendering-work-in-webkit-and-blink/)\n- [WebKit技术内幕](http://blog.csdn.net/milado_nju)\n- [渲染性能](https://developers.google.com/web/fundamentals/performance/rendering/)\n- [High Performance Animations](https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/)","slug":"浏览器渲染简述","published":1,"updated":"2018-08-22T08:06:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl4vatan000h1hn9y2ms2g1k","content":"<p>要编写高性能的网站和应用，除了确保编写的代码能高效地运行外，还需要了解浏览器是如何进行渲染工作的。</p>\n<h2 id=\"浏览器主要组成结构\"><a href=\"#浏览器主要组成结构\" class=\"headerlink\" title=\"浏览器主要组成结构\"></a>浏览器主要组成结构</h2><p><img src=\"https://skmukhiya.files.wordpress.com/2013/06/fb76d-layers-pagespeed-ce-mfe5f8ctav.png\" alt=\"\"></p>\n<ol>\n<li>用户界面(User Interface)：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li>浏览器引擎(Browser engine)：在用户界面(User Interface)和渲染引擎(Rendering engine)之间传送指令。</li>\n<li>渲染引擎(Rendering engine)：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。</li>\n<li>网络(Networking)：用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li>JavaScript解释器(JavaScript Interperter)：用于解析和执行JavaScript代码。</li>\n<li>用户界面后端(UI Backend)：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li>数据存储(Data storage)：这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookies。浏览器还支持诸如localStorage，IndexedDB，WebSQL和FileSystem之类的存储机制。</li>\n</ol>\n<h2 id=\"文档对象模型-DOM：Document-Object-Model）\"><a href=\"#文档对象模型-DOM：Document-Object-Model）\" class=\"headerlink\" title=\"文档对象模型(DOM：Document Object Model）\"></a>文档对象模型(DOM：Document Object Model）</h2><p>本文主要介绍浏览器的渲染，即渲染引擎(Rendering engine)负责的工作: 将请求的HTML内容解析并渲染在屏幕上。<br>如下HTML结构，一个包含一些文本和一张图片：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Critical Path<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>web performance<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> students!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"awesome-photo.jpg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>浏览器是如何处理这个HTML页面：</p>\n<p>\b<img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"\"></p>\n<ol>\n<li>转换(Conversion)：浏览器从磁盘或网络读取HTML的原始字节码，并根据文件的指定编码（例如 UTF-8）将它们转换成对应的字符。</li>\n<li>令牌化(Tokenizing)：浏览器将字符串转换成<a href=\"http://www.w3.org/TR/html5/\" target=\"_blank\" rel=\"external\">W3C HTML5标准</a>规定的各种令牌，例如<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li>\n<li>词法分析(Lexing)：发出的令牌转换成定义其属性和规则的“对象”。</li>\n<li>DOM构建(DOM construction)：HTML标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML对象是body对象的父项，body是paragraph对象的父项，依此类推。</li>\n</ol>\n<p>整个过程的最终输出是HTML页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。浏览器每次处理HTML标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建DOM树。DOM树捕获文档标记的属性和关系，但并未处理元素在渲染后呈现的外观。那是CSSOM的责任。</p>\n<h2 id=\"CSS对象模型-CSSOM：CSS-Object-Model\"><a href=\"#CSS对象模型-CSSOM：CSS-Object-Model\" class=\"headerlink\" title=\"CSS对象模型(CSSOM：CSS Object Model)\"></a>CSS对象模型(CSSOM：CSS Object Model)</h2><p>在浏览器构建DOM遇到link标记时，该标记引用一个外部CSS样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span> &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">font-weight</span>: bold &#125;</div><div class=\"line\"><span class=\"selector-tag\">span</span> &#123; <span class=\"attribute\">color</span>: red &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span> <span class=\"selector-tag\">span</span> &#123; <span class=\"attribute\">display</span>: none &#125;</div><div class=\"line\"><span class=\"selector-tag\">img</span> &#123; <span class=\"attribute\">float</span>: right &#125;</div></pre></td></tr></table></figure>\n<p>与处理HTML时类似，需要将收到的CSS规则转换成某种浏览器能够理解和处理的东西。因此会重复HTML过程，不过是为CSS而不是HTML：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png?hl=zh-cn\" alt=\"\"></p>\n<p>CSS字节转换成字符，接着转换成令牌和节点，最后链接到CSSOM树结构内：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\"></p>\n<p>CSSOM为何具有树结构？用于确定节点对象的计算样式。如span标记包含了<code>color:red</code>样式和继承于body标记的<code>font-size:16px</code>样式;</p>\n<p><u>注意：以上树并非完整的CSSOM树，它只是替代默认样式的自定义样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即不提供任何自定义样式时所看到的样式，自定义样式只是替换这些默认样式</u></p>\n<p>CSSOM是在DOM中的一些接口中，加入获取和操作CSS属性或接口的JavaScript接口，因而JavaScript可以动态操作CSS样式。DOM提供了接口让JavaScript修改HTML文档，CSSOM提供了接口让JavaScript获得和修改CSS代码设置的样式信息。</p>\n<h2 id=\"渲染树-RenderObject-tree，也称为Render-tree\"><a href=\"#渲染树-RenderObject-tree，也称为Render-tree\" class=\"headerlink\" title=\"渲染树(RenderObject tree，也称为Render tree)\"></a>渲染树(RenderObject tree，也称为Render tree)</h2><p>在DOM树中，存在不可见与可见节点之分。顾名思义，不可见节点是不需要绘制最终页面中的节点，如<code>meta</code>、<code>head</code>、<code>script</code>等，以及通过CSS样式<code>display:none</code>隐藏的节点。相反可见节点是用户可见的，如<code>body</code>、<code>div</code>、<code>span</code>、<code>canvas</code>、<code>img</code>等。<br>对于这些可见节点，浏览器需要将它们的内容绘制到最终的页面中，所以浏览器会为它们建立对应的RenderObject对象。一个RenderObject对象保存了为绘制DOM节点的各种信息。这些RenderObject对象与DOM对象类似，也构成一棵树，称为<strong>RenderObject tree</strong>。RenderObject树是基于DOM树建立起来的一棵新树，是为了布局计算和渲染等机制而构建的一种新的内部表示。RenderObject树节点与DOM树节点不是一一对应关系。因为创建一个RenderObject对象需要满足如下规则：</p>\n<ul>\n<li>DOM树的document节点</li>\n<li>DOM树中的可见节点，如<code>html</code>、<code>body</code>、<code>div</code>等。而浏览器不会为不可见节点创建RenderObject节点。</li>\n<li>某些情况下浏览器需要创建匿名的RenderObject节点，该节点不对应DOM树中的任何节点。</li>\n</ul>\n<p>RenderObject对象构成了RenderObject树，每个RenderObject对象保存了为绘制DOM节点的计算样式。RenderObject树也可以理解成由CSSOM树和DOM树合并成：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=zh-cn\" alt=\"\"></p>\n<h2 id=\"布局-loayout\"><a href=\"#布局-loayout\" class=\"headerlink\" title=\"布局(loayout)\"></a>布局(loayout)</h2><p>当浏览器创建RenderObject对象之后，每个对象并不知道自己在设备视口内的位置、大小等信息。浏览器根据<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model\" target=\"_blank\" rel=\"external\">盒模型(Box-model)</a>来计算它们的位置、大小等信息的过程称为布局计算（重排）。<br>布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的孩子节点的位置、大小等信息。为了计算节点在页面中的确切大小和位置，浏览器会从RenderObject树的根节点开始进行遍历。</p>\n<p>实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Critial Path: Hello world!<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 50%\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 50%\"</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>页面包含了两个嵌套div：父div将其的显示尺寸设置为视口宽度的50%，子div将其宽度设置为其父项的50%，即视口宽度的25%。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-viewport.png?hl=zh-cn\" alt=\"\"></p>\n<h2 id=\"RenderLayer树-RenderLayer-tree\"><a href=\"#RenderLayer树-RenderLayer-tree\" class=\"headerlink\" title=\"RenderLayer树(RenderLayer tree)\"></a>RenderLayer树(RenderLayer tree)</h2><p>浏览器渲染引擎并不是直接使用RenderObject树进行绘制，为了方便处理Positioning(定位)，Clipping(裁剪)，Overflow-scroll(页內滚动)，CSS Transform/Opacity/Animation/Filter，Mask or Reflection，Z-indexing(Z排序)等，浏览器需要会为一些特定的RenderObject生成对应的RenderLayer，并生成一棵对应的RenderLayer树。而这些特定的RenderObject跟对应的RenderLayer就是直属的关系，如果它们的子节点如果没有对应的RenderLayer，就从属于父节点的RenderLayer。最终，每一个RenderObject都会直接或者间接地从属于一个RenderLayer。因此RenderObject节点与RenderLayer节点不是一一对应关系，而是一对多的关系。那需要满足什么条件，渲染引擎才为RenderObject建立对应的RenderLayer：</p>\n<ul>\n<li>It’s the root object for the page</li>\n<li>It has explicit CSS position properties (relative, absolute or a transform)</li>\n<li>It is transparent</li>\n<li>Has overflow, an alpha mask or reflection</li>\n<li>Has a CSS filter</li>\n<li>Corresponds to <code>&lt;canvas&gt;</code> element that has a 3D (WebGL) context or an accelerated 2D context</li>\n<li>Corresponds to a <code>&lt;video&gt;</code> element</li>\n</ul>\n<p>翻译：</p>\n<ul>\n<li>DOM树的Document节点对应的RenderObject节点和HTML节点对应的RenderObject节点</li>\n<li>显式指定CSS position属性的RenderObject节点</li>\n<li>有透明度的RenderObject节点</li>\n<li>有overflow，alpha和reflection的样式RenderObject节点</li>\n<li>有filter样式的RenderObject节点</li>\n<li>使用Canvas 2D和3D(WebGL)技术的RenderObject节点</li>\n<li>video元素对应的RenderObject节点</li>\n</ul>\n<p>每个RenderLayer对象可以想象成图像中一个图层，各个图层叠加构成了一个图像。浏览器会遍历RenderLayer树，再遍历从属这个RenderLayer的RenderObject，RenderObject对象存储有绘制信息，并进行绘制。RenderLayer和RenderObject共同决定了最终呈现的网页内容，RenderLayer树决定了网页的绘制的层次顺序，而从属于RenderLayer的RenderObject决定了该RenderLayer的内容。</p>\n<h2 id=\"渲染方式\"><a href=\"#渲染方式\" class=\"headerlink\" title=\"渲染方式\"></a>渲染方式</h2><p>在完成构建RenderLayer树之后，浏览器会使用图形库将其构建的渲染模型绘制出来，该过程分为两个阶段：</p>\n<ul>\n<li>绘制：将从属每个RenderLayer图层上的RenderObject绘制在其RenderLayer上。即绘制（Paint）或者光栅化（Rasterization），将一些绘图指令转换成真正的像素颜色值。<ul>\n<li>软件绘图：CPU来完成绘图操作</li>\n<li>硬件加速绘图：GPU来完成绘图操作</li>\n</ul>\n</li>\n<li>合成(compositing)：将各个RenderLayer图层合并成到一个位图(Bitmap)中。同时还可能包括位移（Translation），缩放（Scale），旋转（Rotation），Alpha 合成等操作。</li>\n</ul>\n<p>渲染引擎的渲染，目前有三种网页的渲染方式：</p>\n<blockquote>\n<ul>\n<li>硬件加速合成(Accelerated Compositing)：使用GPU来完成合成工作。</li>\n<li>合成化渲染：使用合成(compositing)技术的渲染称。</li>\n</ul>\n</blockquote>\n<ul>\n<li>软件渲染方式：使用CPU来绘制每个RenderLayer图层的内容(RenderObject)到一个位图，即一块CPU使用的内存空间。绘制每一层的时候都会使用该位图，区别在于绘制的位置可能不一样，绘制顺序按照从后到前。因此软件渲染机制是没有合成阶段的。</li>\n<li>硬件加速渲染的合成化渲染方式：使用GPU来绘制所有合成层，并使用GPU硬件来加速合成。</li>\n<li>软件绘图的合成化渲染方式： 某些合成层使用CPU来绘图，另外一些使用GPU来绘制。对于使用CPU来绘制的图层，该层的绘制结果会先保存在CPU内存中，之后会被传输到GPU内存中，然后再使用GPU来完成合成工作。</li>\n</ul>\n<p><img src=\"./render.png\" alt=\"\"></p>\n<p>第二种和第三种渲染方式，都是使用了合成化渲染技术，合成工作也都是由GPU来做。对于常见的2D绘图操作，使用GPU来绘图不一定比使用CPU绘图在性能上有优势，例如绘制文字、点、线等，原因是CPU的使用缓冲机制有效减少了重复绘制的开销而且不需要考虑与GPU并行。另外，GPU的内存资源相对CPU的内存资源来说比较紧张，而且网页的分层使得GPU的内存使用相对比较多。鉴于此，就目前的情况来看，三者都存在是有其合理性的，下面分析一下它们的特点：</p>\n<ul>\n<li>软件渲染是目前很常见的技术，也是浏览器最早使用的渲染方式。这一技术比较节省内存，特别是宝贵的GPU内存，但是软件渲染只能处理2D方面的操作。简单的网页没有复杂绘图或者多媒体方面的需求，软件渲染方式就比较合适来渲染该类型的网页。问题是，一旦遇上了HTML5的很多新技术，软件渲染显得无能为力，一是因为能力不足；二是因为性能不好，例如视频、Canvas 2D等。所以，软件渲染技术被用的越来越少，特别是在移动领域。软件渲染同硬件加速渲染另外一个很不同的地方就是对更新区域的处理。当网页中有一个更新小型区域的请求（如动画）时，软件渲染可能只需要计算一个极小的区域，而硬件渲染可能需要重新绘制其中的一层或者多层，然后再合成这些层。硬件渲染的代价可能会大得多。</li>\n<li>对于硬件加速的合成化渲染方式来说，每个层的绘制和所有层的合成均使用GPU硬件来完成，这对需要使用3D绘图的操作来说特别合适。这种方式下，在RenderLayer树之后，浏览器还需要建立更多的内部表示，目的是支持硬件加速机制，这显然会消耗更多的内存资源。但是，一方面，硬件加速机制能够支持现在所有的HTML5定义的2D或者3D绘图标准；另一方面，关于更新区域的讨论，如果需要更新某个层的一个区域，因为软件渲染没有为每一层提供后端存储，因而它需要将和这个区域有重叠部分的所有层次的相关区域一次从后往前重新绘制一遍，而硬件加速渲染只需要重新绘制更新发生的层次，因而在某些情况下，软件渲染的代价又变得更大。当然，这取决于网页的结构和渲染策略。</li>\n<li>软件绘图的合成化渲染方式结合了前面两种方式的优点，这时因为很多网页可能既包含基本的HTML元素，也包含一些HTML5新功能，使用CPU绘图方式来绘制某些层，使用GPU来绘制其他一些层。原因当然是前面所述的基于性能和内存方面综合考虑的结果。</li>\n</ul>\n<blockquote>\n<p>浏览器还可以使用多线程的渲染架构，将网页内容绘制到后端存储的操作放到另外一个独立的线程（绘制线程），而原来线程转为合成线程，绘制线程跟合成线程之间可以使用同步，部分同步，完全异步等作业模式，让浏览器可以在性能与效果之间根据需要进行选择。</p>\n</blockquote>\n<h2 id=\"GrphicsLayer-tree-GrphicsLayer树\"><a href=\"#GrphicsLayer-tree-GrphicsLayer树\" class=\"headerlink\" title=\"GrphicsLayer tree(GrphicsLayer树)\"></a>GrphicsLayer tree(GrphicsLayer树)</h2><p>对于软件渲染而言，到RenderLayer树就结束了，后面不会建立其它额外的树来对应于RenderLayer树。但是，对于硬件渲染来说，在RenderLayer树之后，浏览器渲染引擎为硬件渲染提供了更多的内部结构来支持这个机制。</p>\n<p>在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，一个RenderLayer对象如果需要后端存储，它会创建一个RenderLayerBacking对象，该对象负责Renderlayer对象所需要的各种存储，理想情况下，每个RenderLayer都可以创建自己的后端存储，事实上不是所有RenderLayer都有自己的RenderLayerBacking对象。如果一个RenderLayer对象被像样的创建后端存储，那么将该RenderLayer称为合成层（Compositing Layer）。</p>\n<p>哪些RenderLayer对象可以是合成层？如果一个RenderLayer对象具有以下的特征之一，那么它就是合成层：</p>\n<ul>\n<li>Layer has 3D or perspective transform CSS properties</li>\n<li>Layer is used by &lt; video&gt; element using accelerated video decoding</li>\n<li>Layer is used by a &lt; canvas&gt; element with a 3D context or accelerated 2D context</li>\n<li>Layer is used for a composited plugin</li>\n<li>Layer uses a CSS animation for its opacity or uses an animated webkit transform</li>\n<li>Layer uses accelerated CSS filters</li>\n<li>Layer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection</li>\n<li>Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)</li>\n</ul>\n<p>翻译:</p>\n<ul>\n<li>RenderLayer具有3D或透视转换的CSS属性</li>\n<li>RenderLayer包含使用硬件加速的视频解码技术的<code>&lt;video&gt;</code>元素</li>\n<li>RenderLayer包含使用硬件加速的2D或WebGL-3D技术的<code>&lt;canvas&gt;</code>元素</li>\n<li>RenderLayer使用了合成插件。</li>\n<li>RenderLayer使用了<code>opacity</code>或<code>transform</code>动画</li>\n<li>RenderLayer使用了硬件加速的CSS Filters技术</li>\n<li>RenderLayer后代中包含了一个合成层（如有clip或reflection属性）</li>\n<li>RenderLayer有个一个z-index比自己小的合成层（即在一个合成层之上）</li>\n</ul>\n<p>每个合成层都有一个RenderLayerBacking，RenderLayerBacking负责管理RenderLayer所需要的所有后端存储，因为后端存储可能需要多个存储空间。在浏览器(WebKit)中，存储空间使用类GraphicsLayer来表示。浏览器会为这些RenderLayer创建对应的GraphicsLayer，不同的浏览器需要提供自己的GrphicsLayer实现用于管理存储空间的分配，释放，更新等等。拥有GrphicsLayer的RenderLayer会被绘制到自己的后端存储，而没有GrphicsLayer的RenderLayer它们会向上追溯有GrphicsLayer的父/祖先RenderLayer，直到Root RenderLayer为止，然后绘制在有GrphicsLayer的父/祖先RenderLayer的存储空间，而Root RenderLayer总是会创建一个GrphicsLayer并拥有自己独立的存储空间。在将每个合成图层包含的RenderLayer内容绘制在合成层的后端存储中，这里绘制可以是软件绘制或硬件绘制。接着由合成器(Compositor)将多个合成层合成起来，形成最终用户可见的网页，实际上就是一张图片。</p>\n<p>GraphicsLayer又构成了一棵与RenderLayer并行的树，而RenderLayer与GraphicsLayer的关系有些类似于RenderObject与RenderLayer之间的关系。如下是DOM树、RenderObject树、RenderLayer树、GraphicsLayer树关系图：</p>\n<p><img src=\"http://www.chromium.org/_/rsrc/1479245083354/developers/design-documents/gpu-accelerated-compositing-in-chrome/the_compositing_forest.png\" alt=\"\"></p>\n<p>这样可以合并一些RenderLayer层，从而减少内存的消耗。其次，合并之后，减少了合并带来的重绘性能和处理上的困难。<br>在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，RenderLayer的内容变化，只需要更新所属的GraphicsLayer的缓存即可，而缓存的更新，也只需要绘制直接或者间接属于这个GraphicsLayer的RenderLayer，而不是所有的RenderLayer。特别是一些特定的CSS样式属性的变化，实际上并不引起内容的变化，只需要改变一些GraphicsLayer的混合参数，然后重新混合即可，而混合相对绘制而言是很快的，这些特定的CSS样式属性我们一般称之为是被加速的，不同的浏览器支持的状况不太一样，但基本上CSS Transform &amp; Opacity在所有支持混合加速的浏览器上都是被加速的。被加速的CSS样式属性的动画，就比较容易达到60帧/每秒的流畅效果了。</p>\n<p><img src=\"http://img.blog.csdn.net/20140416142656281\" alt=\"\"></p>\n<p>不过并不是拥有独立缓存的RenderLayer越多越好，太多拥有独立缓存的RenderLayer会带来一些严重的副作用:</p>\n<ul>\n<li>它大大增加了内存的开销，这点在移动设备上的影响更大，甚至导致浏览器在一些内存较少的移动设备上无法很好地支持图层合成加速；</li>\n<li>它加大了合成的时间开销，导致合成性能的下降，而合成性能跟网页滚动/缩放操作的流畅度又息息相关，最终导致网页滚动/缩放的流畅度下降，让用户觉得操作不够流畅。</li>\n</ul>\n<h2 id=\"Tile-Rendering-瓦片渲染\"><a href=\"#Tile-Rendering-瓦片渲染\" class=\"headerlink\" title=\"Tile Rendering(瓦片渲染)\"></a>Tile Rendering(瓦片渲染)</h2><p>通常一个合成层的后端存储被分割成多个大小相同的瓦片状的小存储空间，每个瓦片可以理解为OpenGL中的一个纹理，合成层的结果被分开存储在这些瓦片中。为什么使用瓦片化的后端存储？</p>\n<ul>\n<li>DOM树种的html元素所在的层可能会比较大，因为网页的高度很大，如果只是使用一个后端存储的话，那么需要一个很大的纹理对象，但是实际的GPU硬件可能只支持非常有限的纹理大小。</li>\n<li>在一个比较大的合成层中，可能只是其中一部分发生变化，根据之前的介绍，需要重新绘制整个层，这样必然产生额外的开销，使用瓦片话的后端存储，就只需要重绘一些存在更新的瓦片。</li>\n<li>当层发生滚动的时候，一些瓦片可能不再需要，然后渲染引擎需要一些新的瓦片来绘制新的区域，这些大小相同的后端存储很容易重复利用。</li>\n</ul>\n<p><img src=\"./tiles.png\" alt=\"\"></p>\n<h2 id=\"流畅动画\"><a href=\"#流畅动画\" class=\"headerlink\" title=\"流畅动画\"></a>流畅动画</h2><p>网页加载后，绘制新的每一帧，一般都需要经过计算布局(layout)、绘图(paint)、合成（composite）三阶段。因此要想提高页面性能（或FPS），需要减少每一帧的时间。而在这三个阶段中，layout和paint比较耗时间，而合成需要的时间相对较少一些。</p>\n<h4 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h4><p>如果修改一个DOM元素的”layout”属性，也就是改变了元素的样式（比如宽度、高度或者位置等），那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个reflow过程完成重新布局。被reflow的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面。<br><img src=\"https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg\" alt=\"\"></p>\n<h4 id=\"paint\"><a href=\"#paint\" class=\"headerlink\" title=\"paint\"></a>paint</h4><p>如果修改了“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。<br><img src=\"https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg\" alt=\"\"></p>\n<h4 id=\"composite\"><a href=\"#composite\" class=\"headerlink\" title=\"composite\"></a>composite</h4><p>如果更改了一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg\" alt=\"\"></p>\n<p><strong>如果想知道更改任何指定CSS属性将触发layout、paint、composite中的哪一个，请查看<a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"external\">CSS触发器</a>。</strong></p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>可以通过什么途径进行优化，减少每一帧的时间（避免过多layout或paint）：</p>\n<ul>\n<li>使用适合的网页分层技术减少layout和paint。一旦有请求更新，如果没有分层，渲染引擎可能需要重新绘制所有区域，因为计算更新部分对GPU来说可能消耗更多的时间。而网页分层之后，部分区域的更新可能只在网页的一层或几层，而不需要将整个网页重新绘制。通过重新绘制网页的一层或几层，并将它们和其他之前绘制完的层合并起来，既能使用GPU的能力，又能够减少重绘的开销。</li>\n<li><p>使用合成属性样式（opcity、tansform）来完成tansition或animation。当合成器合成时候，每个合成层都可以设置变形属性：位移（Translate）、缩放（Scale）、旋转（Rotation）、opacity，这些属性仅仅改变合成层的变换参数，而不需要layout和paint操作，极大地减少每一帧的渲染时间。</p>\n<p>即使用GPU硬件加速，为某些RenderLayer创建对应GraphicsLayer。通过为每一个合成层设置变形属性来完成tansition或animation，有效地避免relayout和repaint的开销。</p>\n<p><img src=\"https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/cheap-operations.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文是由几篇关于浏览器渲染的文章组合而成，可能有些概念比较抽象，不好理解，可以查看<strong>参考文章</strong>小节，获取更多信息。本文重点介绍了浏览器渲染引擎的渲染过程，涉及了DOM树、CSSOM树、RenderObject树、RenderLayer树、GraphicsLayer树。并对各种渲染模式进行了简单介绍，其中引入了硬件加速机制，还给出一些优化建议。了解这些知识点对我们开发高性能的web应用会有很大的帮助。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome\" target=\"_blank\" rel=\"external\">GPU Accelerated Compositing in Chrome</a></li>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"external\">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn\" target=\"_blank\" rel=\"external\">构建对象模型</a></li>\n<li><a href=\"https://rogeryi.wordpress.com/2014/04/16/how-rendering-work-in-webkit-and-blink/\" target=\"_blank\" rel=\"external\">How Rendering Work (in WebKit and Blink)</a></li>\n<li><a href=\"http://blog.csdn.net/milado_nju\" target=\"_blank\" rel=\"external\">WebKit技术内幕</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/rendering/\" target=\"_blank\" rel=\"external\">渲染性能</a></li>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/\" target=\"_blank\" rel=\"external\">High Performance Animations</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>要编写高性能的网站和应用，除了确保编写的代码能高效地运行外，还需要了解浏览器是如何进行渲染工作的。</p>\n<h2 id=\"浏览器主要组成结构\"><a href=\"#浏览器主要组成结构\" class=\"headerlink\" title=\"浏览器主要组成结构\"></a>浏览器主要组成结构</h2><p><img src=\"https://skmukhiya.files.wordpress.com/2013/06/fb76d-layers-pagespeed-ce-mfe5f8ctav.png\" alt=\"\"></p>\n<ol>\n<li>用户界面(User Interface)：包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li>\n<li>浏览器引擎(Browser engine)：在用户界面(User Interface)和渲染引擎(Rendering engine)之间传送指令。</li>\n<li>渲染引擎(Rendering engine)：负责显示请求的内容。如果请求的内容是HTML，它就负责解析HTML和CSS内容，并将解析后的内容显示在屏幕上。</li>\n<li>网络(Networking)：用于网络调用，比如HTTP请求。其接口与平台无关，并为所有平台提供底层实现。</li>\n<li>JavaScript解释器(JavaScript Interperter)：用于解析和执行JavaScript代码。</li>\n<li>用户界面后端(UI Backend)：用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li>\n<li>数据存储(Data storage)：这是持久层。浏览器需要在硬盘上保存各种数据，例如Cookies。浏览器还支持诸如localStorage，IndexedDB，WebSQL和FileSystem之类的存储机制。</li>\n</ol>\n<h2 id=\"文档对象模型-DOM：Document-Object-Model）\"><a href=\"#文档对象模型-DOM：Document-Object-Model）\" class=\"headerlink\" title=\"文档对象模型(DOM：Document Object Model）\"></a>文档对象模型(DOM：Document Object Model）</h2><p>本文主要介绍浏览器的渲染，即渲染引擎(Rendering engine)负责的工作: 将请求的HTML内容解析并渲染在屏幕上。<br>如下HTML结构，一个包含一些文本和一张图片：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">href</span>=<span class=\"string\">\"style.css\"</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Critical Path<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Hello <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>web performance<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span> students!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"awesome-photo.jpg\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>浏览器是如何处理这个HTML页面：</p>\n<p>\b<img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"\"></p>\n<ol>\n<li>转换(Conversion)：浏览器从磁盘或网络读取HTML的原始字节码，并根据文件的指定编码（例如 UTF-8）将它们转换成对应的字符。</li>\n<li>令牌化(Tokenizing)：浏览器将字符串转换成<a href=\"http://www.w3.org/TR/html5/\" target=\"_blank\" rel=\"external\">W3C HTML5标准</a>规定的各种令牌，例如<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li>\n<li>词法分析(Lexing)：发出的令牌转换成定义其属性和规则的“对象”。</li>\n<li>DOM构建(DOM construction)：HTML标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：HTML对象是body对象的父项，body是paragraph对象的父项，依此类推。</li>\n</ol>\n<p>整个过程的最终输出是HTML页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。浏览器每次处理HTML标记时，都会完成以上所有步骤：将字节转换成字符，确定令牌，将令牌转换成节点，然后构建DOM树。DOM树捕获文档标记的属性和关系，但并未处理元素在渲染后呈现的外观。那是CSSOM的责任。</p>\n<h2 id=\"CSS对象模型-CSSOM：CSS-Object-Model\"><a href=\"#CSS对象模型-CSSOM：CSS-Object-Model\" class=\"headerlink\" title=\"CSS对象模型(CSSOM：CSS Object Model)\"></a>CSS对象模型(CSSOM：CSS Object Model)</h2><p>在浏览器构建DOM遇到link标记时，该标记引用一个外部CSS样式表：style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-tag\">body</span> &#123; <span class=\"attribute\">font-size</span>: <span class=\"number\">16px</span> &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span> &#123; <span class=\"attribute\">font-weight</span>: bold &#125;</div><div class=\"line\"><span class=\"selector-tag\">span</span> &#123; <span class=\"attribute\">color</span>: red &#125;</div><div class=\"line\"><span class=\"selector-tag\">p</span> <span class=\"selector-tag\">span</span> &#123; <span class=\"attribute\">display</span>: none &#125;</div><div class=\"line\"><span class=\"selector-tag\">img</span> &#123; <span class=\"attribute\">float</span>: right &#125;</div></pre></td></tr></table></figure>\n<p>与处理HTML时类似，需要将收到的CSS规则转换成某种浏览器能够理解和处理的东西。因此会重复HTML过程，不过是为CSS而不是HTML：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png?hl=zh-cn\" alt=\"\"></p>\n<p>CSS字节转换成字符，接着转换成令牌和节点，最后链接到CSSOM树结构内：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\"></p>\n<p>CSSOM为何具有树结构？用于确定节点对象的计算样式。如span标记包含了<code>color:red</code>样式和继承于body标记的<code>font-size:16px</code>样式;</p>\n<p><u>注意：以上树并非完整的CSSOM树，它只是替代默认样式的自定义样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即不提供任何自定义样式时所看到的样式，自定义样式只是替换这些默认样式</u></p>\n<p>CSSOM是在DOM中的一些接口中，加入获取和操作CSS属性或接口的JavaScript接口，因而JavaScript可以动态操作CSS样式。DOM提供了接口让JavaScript修改HTML文档，CSSOM提供了接口让JavaScript获得和修改CSS代码设置的样式信息。</p>\n<h2 id=\"渲染树-RenderObject-tree，也称为Render-tree\"><a href=\"#渲染树-RenderObject-tree，也称为Render-tree\" class=\"headerlink\" title=\"渲染树(RenderObject tree，也称为Render tree)\"></a>渲染树(RenderObject tree，也称为Render tree)</h2><p>在DOM树中，存在不可见与可见节点之分。顾名思义，不可见节点是不需要绘制最终页面中的节点，如<code>meta</code>、<code>head</code>、<code>script</code>等，以及通过CSS样式<code>display:none</code>隐藏的节点。相反可见节点是用户可见的，如<code>body</code>、<code>div</code>、<code>span</code>、<code>canvas</code>、<code>img</code>等。<br>对于这些可见节点，浏览器需要将它们的内容绘制到最终的页面中，所以浏览器会为它们建立对应的RenderObject对象。一个RenderObject对象保存了为绘制DOM节点的各种信息。这些RenderObject对象与DOM对象类似，也构成一棵树，称为<strong>RenderObject tree</strong>。RenderObject树是基于DOM树建立起来的一棵新树，是为了布局计算和渲染等机制而构建的一种新的内部表示。RenderObject树节点与DOM树节点不是一一对应关系。因为创建一个RenderObject对象需要满足如下规则：</p>\n<ul>\n<li>DOM树的document节点</li>\n<li>DOM树中的可见节点，如<code>html</code>、<code>body</code>、<code>div</code>等。而浏览器不会为不可见节点创建RenderObject节点。</li>\n<li>某些情况下浏览器需要创建匿名的RenderObject节点，该节点不对应DOM树中的任何节点。</li>\n</ul>\n<p>RenderObject对象构成了RenderObject树，每个RenderObject对象保存了为绘制DOM节点的计算样式。RenderObject树也可以理解成由CSSOM树和DOM树合并成：</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=zh-cn\" alt=\"\"></p>\n<h2 id=\"布局-loayout\"><a href=\"#布局-loayout\" class=\"headerlink\" title=\"布局(loayout)\"></a>布局(loayout)</h2><p>当浏览器创建RenderObject对象之后，每个对象并不知道自己在设备视口内的位置、大小等信息。浏览器根据<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Box_Model\" target=\"_blank\" rel=\"external\">盒模型(Box-model)</a>来计算它们的位置、大小等信息的过程称为布局计算（重排）。<br>布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的孩子节点的位置、大小等信息。为了计算节点在页面中的确切大小和位置，浏览器会从RenderObject树的根节点开始进行遍历。</p>\n<p>实例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"viewport\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"width=device-width,initial-scale=1\"</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Critial Path: Hello world!<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 50%\"</span>&gt;</span></div><div class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">\"width: 50%\"</span>&gt;</span>Hello world!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div><div class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></div></pre></td></tr></table></figure></p>\n<p>页面包含了两个嵌套div：父div将其的显示尺寸设置为视口宽度的50%，子div将其宽度设置为其父项的50%，即视口宽度的25%。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/layout-viewport.png?hl=zh-cn\" alt=\"\"></p>\n<h2 id=\"RenderLayer树-RenderLayer-tree\"><a href=\"#RenderLayer树-RenderLayer-tree\" class=\"headerlink\" title=\"RenderLayer树(RenderLayer tree)\"></a>RenderLayer树(RenderLayer tree)</h2><p>浏览器渲染引擎并不是直接使用RenderObject树进行绘制，为了方便处理Positioning(定位)，Clipping(裁剪)，Overflow-scroll(页內滚动)，CSS Transform/Opacity/Animation/Filter，Mask or Reflection，Z-indexing(Z排序)等，浏览器需要会为一些特定的RenderObject生成对应的RenderLayer，并生成一棵对应的RenderLayer树。而这些特定的RenderObject跟对应的RenderLayer就是直属的关系，如果它们的子节点如果没有对应的RenderLayer，就从属于父节点的RenderLayer。最终，每一个RenderObject都会直接或者间接地从属于一个RenderLayer。因此RenderObject节点与RenderLayer节点不是一一对应关系，而是一对多的关系。那需要满足什么条件，渲染引擎才为RenderObject建立对应的RenderLayer：</p>\n<ul>\n<li>It’s the root object for the page</li>\n<li>It has explicit CSS position properties (relative, absolute or a transform)</li>\n<li>It is transparent</li>\n<li>Has overflow, an alpha mask or reflection</li>\n<li>Has a CSS filter</li>\n<li>Corresponds to <code>&lt;canvas&gt;</code> element that has a 3D (WebGL) context or an accelerated 2D context</li>\n<li>Corresponds to a <code>&lt;video&gt;</code> element</li>\n</ul>\n<p>翻译：</p>\n<ul>\n<li>DOM树的Document节点对应的RenderObject节点和HTML节点对应的RenderObject节点</li>\n<li>显式指定CSS position属性的RenderObject节点</li>\n<li>有透明度的RenderObject节点</li>\n<li>有overflow，alpha和reflection的样式RenderObject节点</li>\n<li>有filter样式的RenderObject节点</li>\n<li>使用Canvas 2D和3D(WebGL)技术的RenderObject节点</li>\n<li>video元素对应的RenderObject节点</li>\n</ul>\n<p>每个RenderLayer对象可以想象成图像中一个图层，各个图层叠加构成了一个图像。浏览器会遍历RenderLayer树，再遍历从属这个RenderLayer的RenderObject，RenderObject对象存储有绘制信息，并进行绘制。RenderLayer和RenderObject共同决定了最终呈现的网页内容，RenderLayer树决定了网页的绘制的层次顺序，而从属于RenderLayer的RenderObject决定了该RenderLayer的内容。</p>\n<h2 id=\"渲染方式\"><a href=\"#渲染方式\" class=\"headerlink\" title=\"渲染方式\"></a>渲染方式</h2><p>在完成构建RenderLayer树之后，浏览器会使用图形库将其构建的渲染模型绘制出来，该过程分为两个阶段：</p>\n<ul>\n<li>绘制：将从属每个RenderLayer图层上的RenderObject绘制在其RenderLayer上。即绘制（Paint）或者光栅化（Rasterization），将一些绘图指令转换成真正的像素颜色值。<ul>\n<li>软件绘图：CPU来完成绘图操作</li>\n<li>硬件加速绘图：GPU来完成绘图操作</li>\n</ul>\n</li>\n<li>合成(compositing)：将各个RenderLayer图层合并成到一个位图(Bitmap)中。同时还可能包括位移（Translation），缩放（Scale），旋转（Rotation），Alpha 合成等操作。</li>\n</ul>\n<p>渲染引擎的渲染，目前有三种网页的渲染方式：</p>\n<blockquote>\n<ul>\n<li>硬件加速合成(Accelerated Compositing)：使用GPU来完成合成工作。</li>\n<li>合成化渲染：使用合成(compositing)技术的渲染称。</li>\n</ul>\n</blockquote>\n<ul>\n<li>软件渲染方式：使用CPU来绘制每个RenderLayer图层的内容(RenderObject)到一个位图，即一块CPU使用的内存空间。绘制每一层的时候都会使用该位图，区别在于绘制的位置可能不一样，绘制顺序按照从后到前。因此软件渲染机制是没有合成阶段的。</li>\n<li>硬件加速渲染的合成化渲染方式：使用GPU来绘制所有合成层，并使用GPU硬件来加速合成。</li>\n<li>软件绘图的合成化渲染方式： 某些合成层使用CPU来绘图，另外一些使用GPU来绘制。对于使用CPU来绘制的图层，该层的绘制结果会先保存在CPU内存中，之后会被传输到GPU内存中，然后再使用GPU来完成合成工作。</li>\n</ul>\n<p><img src=\"./render.png\" alt=\"\"></p>\n<p>第二种和第三种渲染方式，都是使用了合成化渲染技术，合成工作也都是由GPU来做。对于常见的2D绘图操作，使用GPU来绘图不一定比使用CPU绘图在性能上有优势，例如绘制文字、点、线等，原因是CPU的使用缓冲机制有效减少了重复绘制的开销而且不需要考虑与GPU并行。另外，GPU的内存资源相对CPU的内存资源来说比较紧张，而且网页的分层使得GPU的内存使用相对比较多。鉴于此，就目前的情况来看，三者都存在是有其合理性的，下面分析一下它们的特点：</p>\n<ul>\n<li>软件渲染是目前很常见的技术，也是浏览器最早使用的渲染方式。这一技术比较节省内存，特别是宝贵的GPU内存，但是软件渲染只能处理2D方面的操作。简单的网页没有复杂绘图或者多媒体方面的需求，软件渲染方式就比较合适来渲染该类型的网页。问题是，一旦遇上了HTML5的很多新技术，软件渲染显得无能为力，一是因为能力不足；二是因为性能不好，例如视频、Canvas 2D等。所以，软件渲染技术被用的越来越少，特别是在移动领域。软件渲染同硬件加速渲染另外一个很不同的地方就是对更新区域的处理。当网页中有一个更新小型区域的请求（如动画）时，软件渲染可能只需要计算一个极小的区域，而硬件渲染可能需要重新绘制其中的一层或者多层，然后再合成这些层。硬件渲染的代价可能会大得多。</li>\n<li>对于硬件加速的合成化渲染方式来说，每个层的绘制和所有层的合成均使用GPU硬件来完成，这对需要使用3D绘图的操作来说特别合适。这种方式下，在RenderLayer树之后，浏览器还需要建立更多的内部表示，目的是支持硬件加速机制，这显然会消耗更多的内存资源。但是，一方面，硬件加速机制能够支持现在所有的HTML5定义的2D或者3D绘图标准；另一方面，关于更新区域的讨论，如果需要更新某个层的一个区域，因为软件渲染没有为每一层提供后端存储，因而它需要将和这个区域有重叠部分的所有层次的相关区域一次从后往前重新绘制一遍，而硬件加速渲染只需要重新绘制更新发生的层次，因而在某些情况下，软件渲染的代价又变得更大。当然，这取决于网页的结构和渲染策略。</li>\n<li>软件绘图的合成化渲染方式结合了前面两种方式的优点，这时因为很多网页可能既包含基本的HTML元素，也包含一些HTML5新功能，使用CPU绘图方式来绘制某些层，使用GPU来绘制其他一些层。原因当然是前面所述的基于性能和内存方面综合考虑的结果。</li>\n</ul>\n<blockquote>\n<p>浏览器还可以使用多线程的渲染架构，将网页内容绘制到后端存储的操作放到另外一个独立的线程（绘制线程），而原来线程转为合成线程，绘制线程跟合成线程之间可以使用同步，部分同步，完全异步等作业模式，让浏览器可以在性能与效果之间根据需要进行选择。</p>\n</blockquote>\n<h2 id=\"GrphicsLayer-tree-GrphicsLayer树\"><a href=\"#GrphicsLayer-tree-GrphicsLayer树\" class=\"headerlink\" title=\"GrphicsLayer tree(GrphicsLayer树)\"></a>GrphicsLayer tree(GrphicsLayer树)</h2><p>对于软件渲染而言，到RenderLayer树就结束了，后面不会建立其它额外的树来对应于RenderLayer树。但是，对于硬件渲染来说，在RenderLayer树之后，浏览器渲染引擎为硬件渲染提供了更多的内部结构来支持这个机制。</p>\n<p>在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，一个RenderLayer对象如果需要后端存储，它会创建一个RenderLayerBacking对象，该对象负责Renderlayer对象所需要的各种存储，理想情况下，每个RenderLayer都可以创建自己的后端存储，事实上不是所有RenderLayer都有自己的RenderLayerBacking对象。如果一个RenderLayer对象被像样的创建后端存储，那么将该RenderLayer称为合成层（Compositing Layer）。</p>\n<p>哪些RenderLayer对象可以是合成层？如果一个RenderLayer对象具有以下的特征之一，那么它就是合成层：</p>\n<ul>\n<li>Layer has 3D or perspective transform CSS properties</li>\n<li>Layer is used by &lt; video&gt; element using accelerated video decoding</li>\n<li>Layer is used by a &lt; canvas&gt; element with a 3D context or accelerated 2D context</li>\n<li>Layer is used for a composited plugin</li>\n<li>Layer uses a CSS animation for its opacity or uses an animated webkit transform</li>\n<li>Layer uses accelerated CSS filters</li>\n<li>Layer with a composited descendant has information that needs to be in the composited layer tree, such as a clip or reflection</li>\n<li>Layer has a sibling with a lower z-index which has a compositing layer (in other words the layer is rendered on top of a composited layer)</li>\n</ul>\n<p>翻译:</p>\n<ul>\n<li>RenderLayer具有3D或透视转换的CSS属性</li>\n<li>RenderLayer包含使用硬件加速的视频解码技术的<code>&lt;video&gt;</code>元素</li>\n<li>RenderLayer包含使用硬件加速的2D或WebGL-3D技术的<code>&lt;canvas&gt;</code>元素</li>\n<li>RenderLayer使用了合成插件。</li>\n<li>RenderLayer使用了<code>opacity</code>或<code>transform</code>动画</li>\n<li>RenderLayer使用了硬件加速的CSS Filters技术</li>\n<li>RenderLayer后代中包含了一个合成层（如有clip或reflection属性）</li>\n<li>RenderLayer有个一个z-index比自己小的合成层（即在一个合成层之上）</li>\n</ul>\n<p>每个合成层都有一个RenderLayerBacking，RenderLayerBacking负责管理RenderLayer所需要的所有后端存储，因为后端存储可能需要多个存储空间。在浏览器(WebKit)中，存储空间使用类GraphicsLayer来表示。浏览器会为这些RenderLayer创建对应的GraphicsLayer，不同的浏览器需要提供自己的GrphicsLayer实现用于管理存储空间的分配，释放，更新等等。拥有GrphicsLayer的RenderLayer会被绘制到自己的后端存储，而没有GrphicsLayer的RenderLayer它们会向上追溯有GrphicsLayer的父/祖先RenderLayer，直到Root RenderLayer为止，然后绘制在有GrphicsLayer的父/祖先RenderLayer的存储空间，而Root RenderLayer总是会创建一个GrphicsLayer并拥有自己独立的存储空间。在将每个合成图层包含的RenderLayer内容绘制在合成层的后端存储中，这里绘制可以是软件绘制或硬件绘制。接着由合成器(Compositor)将多个合成层合成起来，形成最终用户可见的网页，实际上就是一张图片。</p>\n<p>GraphicsLayer又构成了一棵与RenderLayer并行的树，而RenderLayer与GraphicsLayer的关系有些类似于RenderObject与RenderLayer之间的关系。如下是DOM树、RenderObject树、RenderLayer树、GraphicsLayer树关系图：</p>\n<p><img src=\"http://www.chromium.org/_/rsrc/1479245083354/developers/design-documents/gpu-accelerated-compositing-in-chrome/the_compositing_forest.png\" alt=\"\"></p>\n<p>这样可以合并一些RenderLayer层，从而减少内存的消耗。其次，合并之后，减少了合并带来的重绘性能和处理上的困难。<br>在硬件加速渲染的合成化渲染和软件绘图的合成化渲染架构下，RenderLayer的内容变化，只需要更新所属的GraphicsLayer的缓存即可，而缓存的更新，也只需要绘制直接或者间接属于这个GraphicsLayer的RenderLayer，而不是所有的RenderLayer。特别是一些特定的CSS样式属性的变化，实际上并不引起内容的变化，只需要改变一些GraphicsLayer的混合参数，然后重新混合即可，而混合相对绘制而言是很快的，这些特定的CSS样式属性我们一般称之为是被加速的，不同的浏览器支持的状况不太一样，但基本上CSS Transform &amp; Opacity在所有支持混合加速的浏览器上都是被加速的。被加速的CSS样式属性的动画，就比较容易达到60帧/每秒的流畅效果了。</p>\n<p><img src=\"http://img.blog.csdn.net/20140416142656281\" alt=\"\"></p>\n<p>不过并不是拥有独立缓存的RenderLayer越多越好，太多拥有独立缓存的RenderLayer会带来一些严重的副作用:</p>\n<ul>\n<li>它大大增加了内存的开销，这点在移动设备上的影响更大，甚至导致浏览器在一些内存较少的移动设备上无法很好地支持图层合成加速；</li>\n<li>它加大了合成的时间开销，导致合成性能的下降，而合成性能跟网页滚动/缩放操作的流畅度又息息相关，最终导致网页滚动/缩放的流畅度下降，让用户觉得操作不够流畅。</li>\n</ul>\n<h2 id=\"Tile-Rendering-瓦片渲染\"><a href=\"#Tile-Rendering-瓦片渲染\" class=\"headerlink\" title=\"Tile Rendering(瓦片渲染)\"></a>Tile Rendering(瓦片渲染)</h2><p>通常一个合成层的后端存储被分割成多个大小相同的瓦片状的小存储空间，每个瓦片可以理解为OpenGL中的一个纹理，合成层的结果被分开存储在这些瓦片中。为什么使用瓦片化的后端存储？</p>\n<ul>\n<li>DOM树种的html元素所在的层可能会比较大，因为网页的高度很大，如果只是使用一个后端存储的话，那么需要一个很大的纹理对象，但是实际的GPU硬件可能只支持非常有限的纹理大小。</li>\n<li>在一个比较大的合成层中，可能只是其中一部分发生变化，根据之前的介绍，需要重新绘制整个层，这样必然产生额外的开销，使用瓦片话的后端存储，就只需要重绘一些存在更新的瓦片。</li>\n<li>当层发生滚动的时候，一些瓦片可能不再需要，然后渲染引擎需要一些新的瓦片来绘制新的区域，这些大小相同的后端存储很容易重复利用。</li>\n</ul>\n<p><img src=\"./tiles.png\" alt=\"\"></p>\n<h2 id=\"流畅动画\"><a href=\"#流畅动画\" class=\"headerlink\" title=\"流畅动画\"></a>流畅动画</h2><p>网页加载后，绘制新的每一帧，一般都需要经过计算布局(layout)、绘图(paint)、合成（composite）三阶段。因此要想提高页面性能（或FPS），需要减少每一帧的时间。而在这三个阶段中，layout和paint比较耗时间，而合成需要的时间相对较少一些。</p>\n<h4 id=\"layout\"><a href=\"#layout\" class=\"headerlink\" title=\"layout\"></a>layout</h4><p>如果修改一个DOM元素的”layout”属性，也就是改变了元素的样式（比如宽度、高度或者位置等），那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个reflow过程完成重新布局。被reflow的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面。<br><img src=\"https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-full.jpg\" alt=\"\"></p>\n<h4 id=\"paint\"><a href=\"#paint\" class=\"headerlink\" title=\"paint\"></a>paint</h4><p>如果修改了“paint only”属性（例如背景图片、文字颜色或阴影等），即不会影响页面布局的属性，则浏览器会跳过布局，但仍将执行绘制。<br><img src=\"https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout.jpg\" alt=\"\"></p>\n<h4 id=\"composite\"><a href=\"#composite\" class=\"headerlink\" title=\"composite\"></a>composite</h4><p>如果更改了一个既不要布局也不要绘制的属性，则浏览器将跳到只执行合成。这个最后的版本开销最小，最适合于应用生命周期中的高压力点，例如动画或滚动。</p>\n<p><img src=\"https://developers.google.com/web/fundamentals/performance/rendering/images/intro/frame-no-layout-paint.jpg\" alt=\"\"></p>\n<p><strong>如果想知道更改任何指定CSS属性将触发layout、paint、composite中的哪一个，请查看<a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"external\">CSS触发器</a>。</strong></p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>可以通过什么途径进行优化，减少每一帧的时间（避免过多layout或paint）：</p>\n<ul>\n<li>使用适合的网页分层技术减少layout和paint。一旦有请求更新，如果没有分层，渲染引擎可能需要重新绘制所有区域，因为计算更新部分对GPU来说可能消耗更多的时间。而网页分层之后，部分区域的更新可能只在网页的一层或几层，而不需要将整个网页重新绘制。通过重新绘制网页的一层或几层，并将它们和其他之前绘制完的层合并起来，既能使用GPU的能力，又能够减少重绘的开销。</li>\n<li><p>使用合成属性样式（opcity、tansform）来完成tansition或animation。当合成器合成时候，每个合成层都可以设置变形属性：位移（Translate）、缩放（Scale）、旋转（Rotation）、opacity，这些属性仅仅改变合成层的变换参数，而不需要layout和paint操作，极大地减少每一帧的渲染时间。</p>\n<p>即使用GPU硬件加速，为某些RenderLayer创建对应GraphicsLayer。通过为每一个合成层设置变形属性来完成tansition或animation，有效地避免relayout和repaint的开销。</p>\n<p><img src=\"https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/cheap-operations.jpg\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文是由几篇关于浏览器渲染的文章组合而成，可能有些概念比较抽象，不好理解，可以查看<strong>参考文章</strong>小节，获取更多信息。本文重点介绍了浏览器渲染引擎的渲染过程，涉及了DOM树、CSSOM树、RenderObject树、RenderLayer树、GraphicsLayer树。并对各种渲染模式进行了简单介绍，其中引入了硬件加速机制，还给出一些优化建议。了解这些知识点对我们开发高性能的web应用会有很大的帮助。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ul>\n<li><a href=\"http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome\" target=\"_blank\" rel=\"external\">GPU Accelerated Compositing in Chrome</a></li>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"external\">浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=zh-cn\" target=\"_blank\" rel=\"external\">构建对象模型</a></li>\n<li><a href=\"https://rogeryi.wordpress.com/2014/04/16/how-rendering-work-in-webkit-and-blink/\" target=\"_blank\" rel=\"external\">How Rendering Work (in WebKit and Blink)</a></li>\n<li><a href=\"http://blog.csdn.net/milado_nju\" target=\"_blank\" rel=\"external\">WebKit技术内幕</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/rendering/\" target=\"_blank\" rel=\"external\">渲染性能</a></li>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/speed/high-performance-animations/\" target=\"_blank\" rel=\"external\">High Performance Animations</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/JavaScript内存那点事/mark-sweep.gif","slug":"mark-sweep.gif","post":"cjl4vata000011hn9mizjdgi0","modified":1,"renderable":0},{"_id":"source/_posts/关于闭包也许你不知道的事/closure4.png","slug":"closure4.png","post":"cjl4vatak000c1hn9x1b4gpqr","modified":1,"renderable":0},{"_id":"source/_posts/关于闭包也许你不知道的事/closure5.png","slug":"closure5.png","post":"cjl4vatak000c1hn9x1b4gpqr","modified":1,"renderable":0},{"_id":"source/_posts/内存泄露之Listeners/listeners_fixed.png","slug":"listeners_fixed.png","post":"cjl4vatal000d1hn9kh575zzi","modified":1,"renderable":0},{"_id":"source/_posts/内存泄露之Listeners/listeners_resize.png","slug":"listeners_resize.png","post":"cjl4vatal000d1hn9kh575zzi","modified":1,"renderable":0},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery1_x.png","slug":"jquery1_x.png","post":"cjl4vatam000f1hn9rven9ng7","modified":1,"renderable":0},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery2_x.png","slug":"jquery2_x.png","post":"cjl4vatam000f1hn9rven9ng7","modified":1,"renderable":0},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/style.mindnodestyle/contents.xml","slug":"style-sheet.mindnode/style.mindnodestyle/contents.xml","post":"cjl4vatah00091hn9zz0oy1h3","modified":1,"renderable":0},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/style.mindnodestyle/metadata.plist","slug":"style-sheet.mindnode/style.mindnodestyle/metadata.plist","post":"cjl4vatah00091hn9zz0oy1h3","modified":1,"renderable":0},{"_id":"source/_posts/关于闭包也许你不知道的事/closure1.png","slug":"closure1.png","post":"cjl4vatak000c1hn9x1b4gpqr","modified":1,"renderable":0},{"_id":"source/_posts/内存泄露之Listeners/listeners_resize_after.png","slug":"listeners_resize_after.png","post":"cjl4vatal000d1hn9kh575zzi","modified":1,"renderable":0},{"_id":"source/_posts/IE-8循环引用导致的内存泄露/leakage.png","slug":"leakage.png","post":"cjl4vat9x00001hn9nsy7m8yf","modified":1,"renderable":0},{"_id":"source/_posts/requestAnimationFrame/arf.png","post":"cjl4vatae00081hn93k24rqhh","slug":"arf.png","modified":1,"renderable":1},{"_id":"source/_posts/浏览器渲染简述/render.png","post":"cjl4vatan000h1hn9y2ms2g1k","slug":"render.png","modified":1,"renderable":1},{"_id":"source/_posts/浏览器渲染简述/tiles.png","slug":"tiles.png","post":"cjl4vatan000h1hn9y2ms2g1k","modified":1,"renderable":0},{"_id":"source/_posts/JavaScript内存那点事/cycle.png","post":"cjl4vata000011hn9mizjdgi0","slug":"cycle.png","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript内存那点事/life-cycle.png","post":"cjl4vata000011hn9mizjdgi0","slug":"life-cycle.png","modified":1,"renderable":1},{"_id":"source/_posts/JavaScript内存那点事/no-cycle.png","post":"cjl4vata000011hn9mizjdgi0","slug":"no-cycle.png","modified":1,"renderable":1},{"_id":"source/_posts/async-vs-defer/legend.svg","post":"cjl4vata400031hn9uzcj3lzi","slug":"legend.svg","modified":1,"renderable":1},{"_id":"source/_posts/async-vs-defer/script-async.svg","post":"cjl4vata400031hn9uzcj3lzi","slug":"script-async.svg","modified":1,"renderable":1},{"_id":"source/_posts/async-vs-defer/script-defer.svg","post":"cjl4vata400031hn9uzcj3lzi","slug":"script-defer.svg","modified":1,"renderable":1},{"_id":"source/_posts/async-vs-defer/script.svg","post":"cjl4vata400031hn9uzcj3lzi","slug":"script.svg","modified":1,"renderable":1},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery.jpg","post":"cjl4vatam000f1hn9rven9ng7","slug":"jquery.jpg","modified":1,"renderable":1},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery_cache_1_x.png","post":"cjl4vatam000f1hn9rven9ng7","slug":"jquery_cache_1_x.png","modified":1,"renderable":1},{"_id":"source/_posts/内存泄露之jQuery-cache/jquery_cache_2_x.png","post":"cjl4vatam000f1hn9rven9ng7","slug":"jquery_cache_2_x.png","modified":1,"renderable":1},{"_id":"source/_posts/关于闭包也许你不知道的事/closure.png","post":"cjl4vatak000c1hn9x1b4gpqr","slug":"closure.png","modified":1,"renderable":1},{"_id":"source/_posts/关于闭包也许你不知道的事/closure2.png","post":"cjl4vatak000c1hn9x1b4gpqr","slug":"closure2.png","modified":1,"renderable":1},{"_id":"source/_posts/关于闭包也许你不知道的事/closure3.png","post":"cjl4vatak000c1hn9x1b4gpqr","slug":"closure3.png","modified":1,"renderable":1},{"_id":"source/_posts/内存泄露之Listeners/listener_location.png","post":"cjl4vatal000d1hn9kh575zzi","slug":"listener_location.png","modified":1,"renderable":1},{"_id":"source/_posts/内存泄露之Listeners/listeners_event.png","post":"cjl4vatal000d1hn9kh575zzi","slug":"listeners_event.png","modified":1,"renderable":1},{"_id":"source/_posts/内存泄露之Listeners/listeners_performance.png","slug":"listeners_performance.png","post":"cjl4vatal000d1hn9kh575zzi","modified":1,"renderable":0},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/QuickLook/Preview.jpg","slug":"style-sheet.mindnode/QuickLook/Preview.jpg","post":"cjl4vatah00091hn9zz0oy1h3","modified":1,"renderable":0},{"_id":"source/_posts/关于external-style-sheets你不知道的事/async-network.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"async-network.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/async-network1.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"async-network1.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/async.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"async.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/default-network.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"default-network.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/media-network.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"media-network.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/media.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"media.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/script-network.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"script-network.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/script.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"script.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet-default.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"style-sheet-default.png","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/contents.xml","post":"cjl4vatah00091hn9zz0oy1h3","slug":"style-sheet.mindnode/contents.xml","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.mindnode/viewState.plist","post":"cjl4vatah00091hn9zz0oy1h3","slug":"style-sheet.mindnode/viewState.plist","modified":1,"renderable":1},{"_id":"source/_posts/关于external-style-sheets你不知道的事/style-sheet.png","post":"cjl4vatah00091hn9zz0oy1h3","slug":"style-sheet.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjl4vata000011hn9mizjdgi0","category_id":"cjl4vata600041hn96fz5igqm","_id":"cjl4vatak000b1hn99029ke35"}],"PostTag":[{"post_id":"cjl4vat9x00001hn9nsy7m8yf","tag_id":"cjl4vata200021hn92xm7j9gj","_id":"cjl4vatan000g1hn9fn8ypprn"},{"post_id":"cjl4vat9x00001hn9nsy7m8yf","tag_id":"cjl4vatac00071hn9ke2q36zt","_id":"cjl4vatan000i1hn9ooq5134r"},{"post_id":"cjl4vat9x00001hn9nsy7m8yf","tag_id":"cjl4vatai000a1hn9jx2s7glx","_id":"cjl4vatao000k1hn9yhnn5hye"},{"post_id":"cjl4vata000011hn9mizjdgi0","tag_id":"cjl4vatal000e1hn9xi39jgwc","_id":"cjl4vatao000n1hn9ljyu29i6"},{"post_id":"cjl4vata000011hn9mizjdgi0","tag_id":"cjl4vatao000j1hn97izh86hq","_id":"cjl4vatap000o1hn9olr1cvy9"},{"post_id":"cjl4vata000011hn9mizjdgi0","tag_id":"cjl4vatao000l1hn9a20bb224","_id":"cjl4vatap000q1hn9j8z0yu4j"},{"post_id":"cjl4vata400031hn9uzcj3lzi","tag_id":"cjl4vatao000m1hn92cdlmofi","_id":"cjl4vataq000t1hn9i8e1gqb9"},{"post_id":"cjl4vata400031hn9uzcj3lzi","tag_id":"cjl4vatap000p1hn9duff0dye","_id":"cjl4vataq000u1hn9jw3ncvuw"},{"post_id":"cjl4vata400031hn9uzcj3lzi","tag_id":"cjl4vatai000a1hn9jx2s7glx","_id":"cjl4vatar000w1hn9rrrfcplb"},{"post_id":"cjl4vata700051hn94qwnhaqt","tag_id":"cjl4vataq000s1hn94s4yq1sx","_id":"cjl4vatar000x1hn9dci0owte"},{"post_id":"cjl4vatae00081hn93k24rqhh","tag_id":"cjl4vataq000v1hn9ooygt6q2","_id":"cjl4vatar00101hn9u5ol04vq"},{"post_id":"cjl4vatae00081hn93k24rqhh","tag_id":"cjl4vatar000y1hn97adt0me8","_id":"cjl4vatar00111hn9775nc1jo"},{"post_id":"cjl4vatah00091hn9zz0oy1h3","tag_id":"cjl4vatar000z1hn9sbq94vqp","_id":"cjl4vatas00141hn974962z53"},{"post_id":"cjl4vatah00091hn9zz0oy1h3","tag_id":"cjl4vatai000a1hn9jx2s7glx","_id":"cjl4vatas00151hn93zmpuo3d"},{"post_id":"cjl4vatak000c1hn9x1b4gpqr","tag_id":"cjl4vatas00131hn9r7jppkjc","_id":"cjl4vatat00181hn9wmvexlpz"},{"post_id":"cjl4vatak000c1hn9x1b4gpqr","tag_id":"cjl4vatat00161hn9pnu3hr7r","_id":"cjl4vatat00191hn9a6e0ni81"},{"post_id":"cjl4vatal000d1hn9kh575zzi","tag_id":"cjl4vatat00171hn98jcihvls","_id":"cjl4vatau001b1hn9jrfwfsia"},{"post_id":"cjl4vatal000d1hn9kh575zzi","tag_id":"cjl4vatai000a1hn9jx2s7glx","_id":"cjl4vatau001c1hn922ymvayi"},{"post_id":"cjl4vatal000d1hn9kh575zzi","tag_id":"cjl4vatac00071hn9ke2q36zt","_id":"cjl4vatau001e1hn9jflcik20"},{"post_id":"cjl4vatam000f1hn9rven9ng7","tag_id":"cjl4vatat001a1hn9mgnu7gj6","_id":"cjl4vatav001g1hn9diujy0wm"},{"post_id":"cjl4vatam000f1hn9rven9ng7","tag_id":"cjl4vatau001d1hn90f9gh21w","_id":"cjl4vatav001h1hn9krhvibeg"},{"post_id":"cjl4vatam000f1hn9rven9ng7","tag_id":"cjl4vatai000a1hn9jx2s7glx","_id":"cjl4vatav001j1hn9zsrjeson"},{"post_id":"cjl4vatam000f1hn9rven9ng7","tag_id":"cjl4vatac00071hn9ke2q36zt","_id":"cjl4vataw001k1hn9ioy28f99"},{"post_id":"cjl4vatan000h1hn9y2ms2g1k","tag_id":"cjl4vatav001f1hn9vk86qgcl","_id":"cjl4vataw001m1hn9mnzqyzlu"},{"post_id":"cjl4vatan000h1hn9y2ms2g1k","tag_id":"cjl4vatai000a1hn9jx2s7glx","_id":"cjl4vataw001n1hn998fhmrru"},{"post_id":"cjl4vatan000h1hn9y2ms2g1k","tag_id":"cjl4vatav001i1hn9f9eezisr","_id":"cjl4vataw001o1hn9cahzsswg"},{"post_id":"cjl4vatan000h1hn9y2ms2g1k","tag_id":"cjl4vataw001l1hn9crm2xoy0","_id":"cjl4vataw001p1hn9cjndeb0w"}],"Tag":[{"name":"IE6","_id":"cjl4vata200021hn92xm7j9gj"},{"name":"内存泄露","_id":"cjl4vatac00071hn9ke2q36zt"},{"name":"优化","_id":"cjl4vatai000a1hn9jx2s7glx"},{"name":"内存","_id":"cjl4vatal000e1hn9xi39jgwc"},{"name":"CG","_id":"cjl4vatao000j1hn97izh86hq"},{"name":"垃圾回收","_id":"cjl4vatao000l1hn9a20bb224"},{"name":"defer","_id":"cjl4vatao000m1hn92cdlmofi"},{"name":"async","_id":"cjl4vatap000p1hn9duff0dye"},{"name":"css","_id":"cjl4vataq000s1hn94s4yq1sx"},{"name":"requestAnimationFrame","_id":"cjl4vataq000v1hn9ooygt6q2"},{"name":"动画","_id":"cjl4vatar000y1hn97adt0me8"},{"name":"style-sheet","_id":"cjl4vatar000z1hn9sbq94vqp"},{"name":"闭包","_id":"cjl4vatas00131hn9r7jppkjc"},{"name":"closure","_id":"cjl4vatat00161hn9pnu3hr7r"},{"name":"listeners","_id":"cjl4vatat00171hn98jcihvls"},{"name":"$.cache","_id":"cjl4vatat001a1hn9mgnu7gj6"},{"name":"jquery","_id":"cjl4vatau001d1hn90f9gh21w"},{"name":"渲染","_id":"cjl4vatav001f1hn9vk86qgcl"},{"name":"render","_id":"cjl4vatav001i1hn9f9eezisr"},{"name":"硬件加速","_id":"cjl4vataw001l1hn9crm2xoy0"}]}}